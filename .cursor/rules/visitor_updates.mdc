---
description: Adding any language feature, fixing bugs in code generation, find descrepancies in generated go code
globs: 
alwaysApply: false
---
# Updating Go Visitor Logic

After modifying the grammar (`.g4` files) and regenerating the parser (`make generate_parser`), the Go visitor code often needs updates to reflect these changes.

1.  **Visitor Files**:
    *   The primary visitor logic is located in `[visitor.go](mdc:internal/visitor/visitor.go)` (for main structure and helpers) and `[statements.go](mdc:internal/visitor/statements.go)` (and other similar files for specific AST node types).

2.  **Implement/Update `VisitXyz` Methods**:
    *   For new or changed parser rules (e.g., `forStmt`), you'll need to add or modify corresponding `VisitForStmt` methods in the visitor.
    *   These methods take a context object (e.g., `*parser.ForStmtContext`) as an argument.

3.  **Use Correct ANTLR Context Accessors**:
    *   When accessing elements defined in your grammar rules (like `block`, `condition`, `loopVars`, `cStyleInit`), use the getter methods provided on the context object.
    *   These are typically named `GetXyz()` (e.g., `ctx.GetBlock()`, `ctx.GetLoopVars()`).
    *   Refer to the generated parser code in `[manuscript_parser.go](mdc:internal/parser/manuscript_parser.go)` to find the exact names of these context structs and their accessor methods if you are unsure.

4.  **AST Node Generation**:
    *   Visitor methods should return appropriate `go/ast` nodes that represent the Manuscript code.
    *   Ensure correct `token.Pos` is used, though `gotoken.NoPos` can be a placeholder during initial development.

5.  **Error Handling**:
    *   Use the `addError(message string, token antlr.Token)` method, which utilizes `NewCompilationError` from `[errors.go](mdc:internal/visitor/errors.go)`, for reporting compilation errors.

## **Accessing ANTLR Grammar Rules in Go Visitor Package**

When you generate a Go visitor package from an ANTLR grammar, ANTLR creates a set of Go files that define interfaces and structs for your parser, lexer, and most importantly, your visitor. This document explains how to navigate and access the data associated with your grammar rules within the Visit methods of your custom visitor, including how to handle rule labels, inline labels, and alternative labels (\# labels).

### **1\. Understanding the Generated Structure**

For each rule in your ANTLR grammar, ANTLR generates a corresponding Context struct (e.g., \*parser.MyRuleContext) and a VisitMyRule method in the YourGrammarVisitor interface. Your custom visitor will implement this interface.  
Let's consider a simple ANTLR grammar snippet, now including **rule labels**, **inline labels**, and an **alternative label (\# label)**:  
grammar MyLang;

program : statement+ EOF;

// Rule labels for alternatives: printStatement and assignStatement  
// Using '\#' for printStatement is a common way to label alternatives.  
statement : 'print' expression ';' \#printStatement  
          | 'assign' ID '=' expression ';' \#assignStatement  
          ;

// Inline labels for components: exprID and exprNum  
expression : exprID=ID  
           | exprNum=NUMBER  
           ;

ID : \[a-zA-Z\]+ ;  
NUMBER : \[0-9\]+ ;  
WS : \[ \\t\\r\\n\]+ \-\> skip ;

From this, ANTLR will generate:

* parser/mylangparser.go: Contains MyLangParser and context structs like ProgramContext, StatementContext, ExpressionContext, etc. For labeled alternatives (using either ruleLabel= or \#label), it will generate specific context structs, e.g., \*parser.PrintStatementContext and \*parser.AssignStatementContext.  
* parser/mylang\_base\_visitor.go: Provides a base implementation of the visitor interface.  
* parser/mylang\_visitor.go: Defines the MyLangVisitor interface with methods like VisitProgram, VisitPrintStatement, VisitAssignStatement, VisitExpression.

### **2\. Accessing Rule Contexts within Visit Methods**

Your custom visitor will embed \*parser.BaseMyLangVisitor and override the Visit methods for the rules you want to process. Inside these Visit methods, you receive a Context object specific to that rule. This context object is your primary way to access the components of that rule.

#### **Example Visitor Structure with Labels:**

package main

import (  
	"fmt"  
	"your\_module\_path/parser" // Replace with your actual module path  
)

// MyCustomVisitor implements the MyLangVisitor interface  
type MyCustomVisitor struct {  
	\*parser.BaseMyLangVisitor  
}

// NewMyCustomVisitor creates a new instance of MyCustomVisitor  
func NewMyCustomVisitor() \*MyCustomVisitor {  
	return \&MyCustomVisitor{  
		BaseMyLangVisitor: \&parser.BaseMyLangVisitor{},  
	}  
}

// VisitProgram is called when the 'program' rule is matched  
func (v \*MyCustomVisitor) VisitProgram(ctx \*parser.ProgramContext) interface{} {  
	fmt.Println("Visiting Program")  
	// Iterate over child statements  
	for \_, stmtCtx := range ctx.AllStatement() {  
		v.Visit(stmtCtx) // Recursively visit each statement  
	}  
	return nil  
}

// VisitStatement is called when the 'statement' rule is matched.  
// With rule labels (including '\#' labels), ANTLR generates separate Visit methods  
// for each labeled alternative. So, you'll typically implement VisitPrintStatement  
// and VisitAssignStatement instead.  
func (v \*MyCustomVisitor) VisitStatement(ctx \*parser.StatementContext) interface{} {  
	// This method might still be called if you don't override the specific labeled  
	// alternative methods. However, it's generally better to use the specific ones.  
	fmt.Println("Visiting generic Statement (consider using specific labeled methods)")  
	return v.BaseMyLangVisitor.VisitStatement(ctx) // Default behavior  
}

// VisitPrintStatement is called when the 'printStatement' alternative of 'statement' is matched.  
// This method is generated whether you use 'printStatement=...' or '\#printStatement'.  
func (v \*MyCustomVisitor) VisitPrintStatement(ctx \*parser.PrintStatementContext) interface{} {  
	fmt.Println("  Found 'print' statement (via alternative label \#printStatement)")  
	// Access the expression child of the print statement  
	if exprCtx := ctx.Expression(); exprCtx \!= nil {  
		v.Visit(exprCtx) // Visit the expression  
	}  
	return nil  
}

// VisitAssignStatement is called when the 'assignStatement' alternative of 'statement' is matched.  
// This method is generated whether you use 'assignStatement=...' or '\#assignStatement'.  
func (v \*MyCustomVisitor) VisitAssignStatement(ctx \*parser.AssignStatementContext) interface{} {  
	fmt.Println("  Found 'assign' statement (via alternative label \#assignStatement)")  
	// Access the ID and Expression children directly from the labeled context  
	if idToken := ctx.ID(); idToken \!= nil {  
		fmt.Printf("    Assigned variable: %s\\n", idToken.GetText())  
	}  
	if exprCtx := ctx.Expression(); exprCtx \!= nil {  
		v.Visit(exprCtx) // Visit the expression  
	}  
	return nil  
}

// VisitExpression is called when the 'expression' rule is matched  
func (v \*MyCustomVisitor) VisitExpression(ctx \*parser.ExpressionContext) interface{} {  
	fmt.Println("Visiting Expression")  
	// Access the specific terminal node (token) that forms the expression using inline labels  
	if idToken := ctx.ExprID(); idToken \!= nil { // Access via inline label 'exprID'  
		fmt.Printf("  Expression is an ID: %s\\n", idToken.GetText())  
	} else if numToken := ctx.ExprNum(); numToken \!= nil { // Access via inline label 'exprNum'  
		fmt.Printf("  Expression is a NUMBER: %s\\n", numToken.GetText())  
	}  
	return nil  
}

// You would also typically override VisitTerminal and VisitErrorNode if needed  
// func (v \*MyCustomVisitor) VisitTerminal(node antlr.TerminalNode) interface{} {  
// 	// fmt.Printf("Terminal: %s\\n", node.GetText())  
// 	return v.BaseMyLangVisitor.VisitTerminal(node)  
// }

### **3\. Key Methods for Accessing Children**

For each rule context struct (e.g., \*parser.StatementContext), ANTLR generates helper methods to access its children. The presence of labels significantly impacts these methods.

* **Rule Context Children (Unlabeled):**  
  * ctx.RuleName(): Returns the *first* child context of a specific rule type (e.g., ctx.Expression() returns \*parser.ExpressionContext). If there are multiple, it returns the first.  
  * ctx.AllRuleName(): Returns a slice of all child contexts of a specific rule type (e.g., ctx.AllStatement() returns \[\]\*parser.StatementContext). This is useful for rules that can have multiple occurrences of another rule.  
* **Terminal Node (Token) Children (Unlabeled):**  
  * ctx.TOKEN\_NAME(): Returns the antlr.TerminalNode for a specific token type (e.g., ctx.PRINT() for the 'print' keyword, ctx.ID() for the ID token). If there are multiple, it returns the first.  
  * ctx.AllTOKEN\_NAME(): Returns a slice of all antlr.TerminalNode for a specific token type.  
* Accessing Rule Labels and Alternative Labels (\# labels):  
  When you apply a rule label (e.g., ruleLabel=alternative) or an alternative label (\#label) to an alternative within a rule, ANTLR generates:  
  1. A specific Context struct for that alternative (e.g., \*parser.PrintStatementContext, \*parser.AssignStatementContext).  
  2. A corresponding Visit method in the visitor interface (e.g., VisitPrintStatement, VisitAssignStatement).

You should override these specific Visit methods to handle the logic for each labeled alternative. Inside these methods, you can directly access the elements of that specific alternative. The behavior for accessing elements within the Visit method is the same whether you use ruleLabel= or \#label. The \#label syntax is often preferred for clarity when labeling alternatives.

* Accessing Inline Labels:  
  When you apply an inline label to a rule reference or a terminal node (e.g., exprID=ID, exprNum=NUMBER in our expression rule), ANTLR generates a direct accessor method on the parent rule's context:  
  * ctx.LabelName(): Returns the specific rule context or antlr.TerminalNode that was labeled (e.g., ctx.ExprID() returns antlr.TerminalNode, ctx.ExprNum() returns antlr.TerminalNode). This provides a more direct and type-safe way to access specific components of a rule.  
* Accessing Token Text:  
  Once you have an antlr.TerminalNode, you can get its text content using node.GetText(). For example, ctx.ID().GetText() or ctx.ExprID().GetText().

### **4\. Important Considerations**

* **Return Type (interface{}):** The Visit methods in the ANTLR Go visitor interface return interface{}. This allows you to return any Go type from your visitor methods, which can be useful for building an Abstract Syntax Tree (AST) or performing calculations. If you don't need to return a value, nil is a common return.  
* **Recursive Visiting:** To traverse the parse tree, you typically call v.Visit(childContext) on the child rule contexts within your Visit methods.  
* **Error Handling:** Remember to consider how you'll handle parsing errors. ANTLR provides mechanisms for error listeners, which are separate from the visitor pattern.  
* **Type Assertions:** While ANTLR's generated methods often provide direct access to the correct context types, in more complex scenarios or when dealing with generic antlr.ParseTree objects, you might need to use type assertions (e.g., childCtx, ok := ctx.(type \*parser.MyRuleContext)).

By understanding the generated Context structs and their helper methods, especially those created by rule, inline, and alternative labels, you can effectively traverse the parse tree and extract the information you need from your ANTLR grammar rules using the Go visitor pattern.