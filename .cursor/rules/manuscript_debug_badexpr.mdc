---
description: Debugging `BadExpr` in Manuscript Compilation
globs: 
alwaysApply: false
---
# Debugging `BadExpr` in Manuscript Compilation

Encountering `BadExpr` in the generated Go code during testing (e.g., `x := BadExpr` in the diff from `make test-file`) indicates an issue in the AST visitor, where an expression was not correctly converted into a Go `ast.Expr` node.

## Trace the Expression
1.  Identify the problematic Manuscript code in the test file (e.g., from `[tests/compilation/basic.md](mdc:tests/compilation/basic.md)`).
2.  Trace how this code is parsed through the expression grammar rules in `[internal/grammar/Manuscript.g4](mdc:internal/grammar/Manuscript.g4)`. The typical precedence chain for expressions is:
    *   `expr` (entry point)
    *   `assignmentExpr`
    *   `logicalOrExpr`
    *   `logicalAndExpr`
    *   `bitwiseOrExpr`
    *   `bitwiseXorExpr`
    *   `bitwiseAndExpr`
    *   `equalityExpr`
    *   `comparisonExpr`
    *   `shiftExpr`
    *   `additiveExpr`
    *   `multiplicativeExpr`
    *   `unaryExpr`
    *   `postfixExpr`
    *   `primaryExpr` (often leads to `literal`)
    *   `literal` (handled in `[internal/visitor/literal.go](mdc:internal/visitor/literal.go)`)

## Examine Visitor Methods
For each grammar rule in the traced path, inspect its corresponding `Visit<RuleName>` method. Most expression visitors are in:
-   `[internal/visitor/binary_expressions.go](mdc:internal/visitor/binary_expressions.go)` (for binary operator expressions)
-   `[internal/visitor/expr.go](mdc:internal/visitor/expr.go)` (for unary, primary, etc.)
-   `[internal/visitor/literal.go](mdc:internal/visitor/literal.go)` (for literals)

### Key Checks for `BadExpr` Causes:

1.  **Missing Visitor Method**:
    *   If a `Visit<RuleName>` method is missing for a specific expression rule in the grammar chain, the default ANTLR visitor behavior (e.g., `VisitChildren`) might be invoked. This often doesn't return the single `ast.Expr` node expected by calling visitor methods, leading to a `BadExpr`.
    *   **Solution**: Ensure an explicit visitor method is implemented for every relevant expression rule. We encountered this with `VisitShiftExpr`, `VisitBitwiseOrExpr`, etc., which needed to be added.

2.  **Incorrect Operand Type Assertion**:
    *   This is a common cause. Visitor methods (or helpers like `buildChainedBinaryExpressionAst`) often assert the type of their child ANTLR contexts (operands).
    *   The expected type is dictated by the grammar. For a rule like `currentExpr: childExpr (OPERATOR childExpr)*;`, the `VisitCurrentExpr` method (or its `assertAndGetOperand` function) must expect `parser.IChildExprContext` for its operands.
    *   **Example**: If `VisitComparisonExpr` (grammar: `comparisonExpr: shiftExpr ...`) incorrectly asserts its child as `parser.IAdditiveExprContext` instead of `parser.IShiftExprContext`, it will fail the assertion for a valid `shiftExpr` child and likely return `BadExpr`.
    *   **Solution**: Verify that all type assertions for operand contexts match the types defined in the right-hand side of the corresponding grammar rules in `[internal/grammar/Manuscript.g4](mdc:internal/grammar/Manuscript.g4)`.

3.  **Visitor Not Returning `ast.Expr`**:
    *   Ensure that the visitor method, after processing, ultimately returns a valid Go `ast.Expr` interface.
    *   If a genuine parsing/conversion error occurs at a node, the visitor should add an error using `v.addError(message, token)` and then return an `&ast.BadExpr{}` (or `&ast.EmptyStmt{}` if appropriate for statement contexts, though `BadExpr` is typical for expression failures).

By systematically checking these points along the expression's path through the visitor, the source of the `BadExpr` can usually be identified and fixed.
