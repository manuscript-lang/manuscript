package visitor

import (
	"fmt"
	"go/ast"
	gotoken "go/token"
	"strconv"

	// For parsing numbers
	msParser "manuscript-co/manuscript/internal/parser"

	"github.com/antlr4-go/antlr/v4" // Use aliased import for antlr
)

// ManuscriptAstVisitor implements the antlr.ParseTreeVisitor interface.
// It traverses the parse tree generated by ANTLR and constructs a Go AST.
type ManuscriptAstVisitor struct {
	*msParser.BaseManuscriptVisitor // Embed the base visitor

	Errors         []string
	loopDepth      int    // To track if we are inside a loop for break/continue
	currentPackage string // Name of the current Manuscript package/module
	currentFile    string // Name of the current Manuscript file being processed

	// For Go AST generation specific details
	goPackageName string // Target Go package name
	goImports     []*ast.ImportSpec
	goFileSet     *gotoken.FileSet // For position information in Go AST
	tempVarCount  int              // For unique temporary variables like __val1, __val2
}

// NewManuscriptAstVisitor creates a new visitor instance.
func NewManuscriptAstVisitor(pkgName, fileName string) *ManuscriptAstVisitor {
	fs := gotoken.NewFileSet()
	// Initialize other fields as necessary, e.g., symbolTable
	return &ManuscriptAstVisitor{
		BaseManuscriptVisitor: &msParser.BaseManuscriptVisitor{},
		Errors:                []string{},
		currentPackage:        pkgName,
		currentFile:           fileName,
		goPackageName:         "main", // Default, can be overridden
		goImports:             []*ast.ImportSpec{},
		goFileSet:             fs,
		tempVarCount:          0, // Initialize the counter
	}
}

// Helper to add an error with position information if available
func (v *ManuscriptAstVisitor) addError(message string, token antlr.Token) {
	line := 0
	column := 0
	if token != nil {
		line = token.GetLine()
		column = token.GetColumn()
	}
	fullMessage := fmt.Sprintf("Error: %s (file: %s, line: %d, col: %d)", message, v.currentFile, line, column)
	v.Errors = append(v.Errors, fullMessage)
}

// General Visit methods (delegation and error handling)
// VisitChildren visits the children of a node.
// It returns the result of visiting the last child, or nil if no children produce a result.
func (v *ManuscriptAstVisitor) VisitChildren(node antlr.RuleNode) interface{} {
	for _, child := range node.GetRuleContext().GetChildren() {
		if child == nil {
			continue
		}
		if pt, ok := child.(antlr.ParseTree); ok {
			childResult := v.Visit(pt)
			if childResult != nil {
				return childResult
			}
		}
	}
	return nil
}

func (v *ManuscriptAstVisitor) Visit(tree antlr.ParseTree) interface{} {
	if tree == nil {
		v.addError("Attempted to visit a nil tree node", nil)
		return &ast.BadStmt{From: gotoken.NoPos, To: gotoken.NoPos}
	}
	return tree.Accept(v)
}

func (v *ManuscriptAstVisitor) VisitErrorNode(node antlr.ErrorNode) interface{} {
	text := node.GetText()
	// Check for common ANTLR error node texts that might be ignorable or handled differently
	if text == "<EOF>" { // Often an error node at the end if parsing didn't consume all input
		v.addError(fmt.Sprintf("Encountered unexpected EOF or extra input near: %s", text), node.GetSymbol())
		return &ast.BadStmt{From: v.pos(node.GetSymbol()), To: v.pos(node.GetSymbol())}
	}

	// Special handling for break and continue error nodes - but only when within proper context
	if text == "break" || text == "continue" {
		if v.isInLoop() {
			tok := gotoken.BREAK
			if text == "continue" {
				tok = gotoken.CONTINUE
			}
			return &ast.BranchStmt{
				TokPos: v.pos(node.GetSymbol()),
				Tok:    tok,
			}
		}
	}

	v.addError("Error node encountered: "+node.GetText(), node.GetSymbol())
	return &ast.BadStmt{From: v.pos(node.GetSymbol()), To: v.pos(node.GetSymbol())}
}

// pos function to convert ANTLR token positions to Go token positions
// For this simplified example, we'll use a placeholder.
// A real implementation would need a more robust way to map line/column or use a token.FileSet.
func (v *ManuscriptAstVisitor) pos(token antlr.Token) gotoken.Pos {
	if token == nil || v.goFileSet == nil {
		return gotoken.NoPos
	}
	// This is a very rough approximation. A proper implementation would add files
	// to the FileSet and use their line/offset information.
	// For now, using TokenIndex as a pseudo-offset.
	// The +1 is because gotoken.Pos(0) is NoPos.
	// This will not give correct line numbers in Go output.
	// TODO: Properly map ANTLR token positions to Go token.Pos using goFileSet.
	return gotoken.Pos(token.GetTokenIndex() + 1)
}

// enterLoop and exitLoop manage the loop depth counter
func (v *ManuscriptAstVisitor) enterLoop() {
	v.loopDepth++
}

func (v *ManuscriptAstVisitor) exitLoop() {
	if v.loopDepth > 0 {
		v.loopDepth--
	}
}

// isInLoop checks if the visitor is currently inside a loop construct
func (v *ManuscriptAstVisitor) isInLoop() bool {
	return v.loopDepth > 0
}

// nextTempVarCounter generates a unique string suffix for temporary variables.
func (v *ManuscriptAstVisitor) nextTempVarCounter() string {
	v.tempVarCount++
	return strconv.Itoa(v.tempVarCount) // strconv needs to be imported in this file if not already.
}
