package visitor

import (
	"fmt"
	"go/ast"
	gotoken "go/token"

	// For parsing numbers
	msParser "manuscript-co/manuscript/internal/parser"

	"github.com/antlr4-go/antlr/v4" // Use aliased import for antlr
)

// ManuscriptAstVisitor implements the antlr.ParseTreeVisitor interface.
// It traverses the parse tree generated by ANTLR and constructs a Go AST.
type ManuscriptAstVisitor struct {
	*msParser.BaseManuscriptVisitor // Embed the base visitor

	Errors         []string
	symbolTable    *SymbolTable
	currentScope   *Scope
	loopDepth      int    // To track if we are inside a loop for break/continue
	currentPackage string // Name of the current Manuscript package/module
	currentFile    string // Name of the current Manuscript file being processed

	// For Go AST generation specific details
	goPackageName string                // Target Go package name
	goImports     map[string]string     // Map from import path to alias (if any, "" for no alias)
	goFileSet     *gotoken.FileSet      // For position information in Go AST
	goTypeSpecs   []*ast.TypeSpec       // For collecting type definitions
	goFuncDecls   []*ast.FuncDecl       // For collecting function declarations
	goVarDecls    []*ast.GenDecl        // For collecting global variable declarations
	goStmtList    []ast.Stmt            // For collecting statements (e.g. in main or init)
	deferredStmts map[string][]ast.Stmt // For defer statements, key might be function name or scope ID
}

// NewManuscriptAstVisitor creates a new visitor instance.
func NewManuscriptAstVisitor(pkgName, fileName string) *ManuscriptAstVisitor {
	fs := gotoken.NewFileSet()
	// Initialize other fields as necessary, e.g., symbolTable
	return &ManuscriptAstVisitor{
		BaseManuscriptVisitor: &msParser.BaseManuscriptVisitor{},
		Errors:                []string{},
		symbolTable:           NewSymbolTable(),
		currentScope:          nil, // Will be set up with global scope
		currentPackage:        pkgName,
		currentFile:           fileName,
		goPackageName:         "main", // Default, can be overridden
		goImports:             make(map[string]string),
		goFileSet:             fs,
		// Initialize slices/maps
		deferredStmts: make(map[string][]ast.Stmt),
	}
}

// Helper to add an error with position information if available
func (v *ManuscriptAstVisitor) addError(message string, token antlr.Token) {
	line := 0
	column := 0
	if token != nil {
		line = token.GetLine()
		column = token.GetColumn()
	}
	fullMessage := fmt.Sprintf("Error: %s (file: %s, line: %d, col: %d)", message, v.currentFile, line, column)
	v.Errors = append(v.Errors, fullMessage)
}

// General Visit methods (delegation and error handling)
// VisitChildren visits the children of a node.
// It returns the result of visiting the last child, or nil if no children produce a result.
func (v *ManuscriptAstVisitor) VisitChildren(node antlr.RuleNode) interface{} {
	var result interface{}
	for i := 0; i < node.GetChildCount(); i++ {
		child := node.GetChild(i)
		if pt, ok := child.(antlr.ParseTree); ok {
			childResult := pt.Accept(v)
			if childResult != nil {
				result = childResult // Keep the last non-nil result
			}
		}
	}
	return result
}

func (v *ManuscriptAstVisitor) Visit(tree antlr.ParseTree) interface{} {
	if tree == nil {
		v.addError("Attempted to visit a nil tree node", nil)
		return &ast.BadStmt{From: gotoken.NoPos, To: gotoken.NoPos}
	}
	return tree.Accept(v)
}

func (v *ManuscriptAstVisitor) VisitErrorNode(node antlr.ErrorNode) interface{} {
	text := node.GetText()
	// Check for common ANTLR error node texts that might be ignorable or handled differently
	if text == "<EOF>" { // Often an error node at the end if parsing didn't consume all input
		v.addError(fmt.Sprintf("Encountered unexpected EOF or extra input near: %s", text), node.GetSymbol())
		return &ast.BadStmt{From: v.pos(node.GetSymbol()), To: v.pos(node.GetSymbol())}
	}

	// Special handling for break and continue error nodes - but only when within proper context
	if text == "break" || text == "continue" {
		if v.isInLoop() {
			tok := gotoken.BREAK
			if text == "continue" {
				tok = gotoken.CONTINUE
			}
			return &ast.BranchStmt{
				TokPos: v.pos(node.GetSymbol()),
				Tok:    tok,
			}
		}
		// If not in a loop, it's a genuine error handled by the generic message below.
	}

	v.addError("Error node encountered: "+node.GetText(), node.GetSymbol())
	return &ast.BadStmt{From: v.pos(node.GetSymbol()), To: v.pos(node.GetSymbol())}
}

// pos function to convert ANTLR token positions to Go token positions
// For this simplified example, we'll use a placeholder.
// A real implementation would need a more robust way to map line/column or use a token.FileSet.
func (v *ManuscriptAstVisitor) pos(token antlr.Token) gotoken.Pos {
	if token == nil || v.goFileSet == nil {
		return gotoken.NoPos
	}
	// This is a very rough approximation. A proper implementation would add files
	// to the FileSet and use their line/offset information.
	// For now, using TokenIndex as a pseudo-offset.
	// The +1 is because gotoken.Pos(0) is NoPos.
	// This will not give correct line numbers in Go output.
	// TODO: Properly map ANTLR token positions to Go token.Pos using goFileSet.
	return gotoken.Pos(token.GetTokenIndex() + 1)
}

// enterLoop and exitLoop manage the loop depth counter
func (v *ManuscriptAstVisitor) enterLoop() {
	v.loopDepth++
}

func (v *ManuscriptAstVisitor) exitLoop() {
	if v.loopDepth > 0 {
		v.loopDepth--
	}
}

// isInLoop checks if the visitor is currently inside a loop construct
func (v *ManuscriptAstVisitor) isInLoop() bool {
	return v.loopDepth > 0
}

// Scope management (simplified)
func (v *ManuscriptAstVisitor) enterScope() {
	v.currentScope = NewScope(v.currentScope) // Create new scope with current as parent
}

func (v *ManuscriptAstVisitor) exitScope() {
	if v.currentScope != nil && v.currentScope.parent != nil { // Don't exit global scope
		v.currentScope = v.currentScope.parent
	}
}

// --- Additional Semantic Analysis and Helper Methods would go here ---
// e.g., type checking, symbol resolution helpers not part of ANTLR visitor overrides.

// --- Symbol Table and Scope Definitions (Simplified) ---

// SymbolKind defines the type of a symbol (variable, function, type, etc.)
type SymbolKind int

const (
	VarSymbol SymbolKind = iota
	FuncSymbol
	TypeSymbol
	PackageSymbol
	// ... other kinds
)

// Symbol represents an entry in the symbol table
type Symbol struct {
	Name string
	Kind SymbolKind
	Type string // Type of the symbol (e.g., "int", "string", "MyStruct", "func(int) string")
	// Add other info: e.g., a pointer to the AST node, scope where defined, etc.
	Pos gotoken.Pos // Position of declaration
}

// Scope represents a lexical scope
type Scope struct {
	parent  *Scope
	symbols map[string]*Symbol
}

func NewScope(parent *Scope) *Scope {
	return &Scope{
		parent:  parent,
		symbols: make(map[string]*Symbol),
	}
}

func (s *Scope) Define(name string, kind SymbolKind, symType string, pos gotoken.Pos) (*Symbol, error) {
	if _, exists := s.symbols[name]; exists {
		return nil, fmt.Errorf("symbol '%s' already defined in this scope", name)
	}
	sym := &Symbol{Name: name, Kind: kind, Type: symType, Pos: pos}
	s.symbols[name] = sym
	return sym, nil
}

func (s *Scope) Resolve(name string) (*Symbol, *Scope) {
	for sc := s; sc != nil; sc = sc.parent {
		if sym, found := sc.symbols[name]; found {
			return sym, sc
		}
	}
	return nil, nil
}

// SymbolTable manages scopes
type SymbolTable struct {
	Global *Scope
	// current *Scope // Managed by visitor's currentScope
}

func NewSymbolTable() *SymbolTable {
	globalScope := NewScope(nil)
	// TODO: Add predefined symbols/types to global scope if any
	return &SymbolTable{
		Global: globalScope,
	}
}
