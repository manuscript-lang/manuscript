package visitor

import (
	"fmt"
	"go/ast"
	gotoken "go/token"
	"strconv"

	// For parsing numbers
	msParser "manuscript-co/manuscript/internal/parser"

	"github.com/antlr4-go/antlr/v4" // Use aliased import for antlr
)

// ManuscriptAstVisitor implements the antlr.ParseTreeVisitor interface.
// It traverses the parse tree generated by ANTLR and constructs a Go AST.
type ManuscriptAstVisitor struct {
	*msParser.BaseManuscriptVisitor // Embed the base visitor

	// Error handling
	Errors []string

	// Symbol management
	symbolTable    *SymbolTable
	currentScope   *Scope
	loopDepth      int    // Track nesting level inside loops for break/continue
	currentPackage string // Name of the current Manuscript package/module
	currentFile    string // Name of the current Manuscript file being processed

	// Go AST generation
	goPackageName string                // Target Go package name
	goImports     map[string]string     // Map from import path to alias (or "" for no alias)
	goFileSet     *gotoken.FileSet      // For position information in Go AST
	goTypeSpecs   []*ast.TypeSpec       // Collected type definitions
	goFuncDecls   []*ast.FuncDecl       // Collected function declarations
	goVarDecls    []*ast.GenDecl        // Collected global variable declarations
	goStmtList    []ast.Stmt            // Collected statements (e.g. in main or init)
	deferredStmts map[string][]ast.Stmt // For defer statements, key is function name or scope ID
	tempVarCount  int                   // Counter for generating unique temporary variables
}

// NewManuscriptAstVisitor creates a new visitor instance with initialized fields.
func NewManuscriptAstVisitor(pkgName, fileName string) *ManuscriptAstVisitor {
	return &ManuscriptAstVisitor{
		BaseManuscriptVisitor: &msParser.BaseManuscriptVisitor{},
		Errors:                []string{},
		symbolTable:           NewSymbolTable(),
		currentScope:          nil, // Will be set to global scope during initialization
		loopDepth:             0,
		currentPackage:        pkgName,
		currentFile:           fileName,
		goPackageName:         "main", // Default, can be overridden
		goImports:             make(map[string]string),
		goFileSet:             gotoken.NewFileSet(),
		goTypeSpecs:           make([]*ast.TypeSpec, 0),
		goFuncDecls:           make([]*ast.FuncDecl, 0),
		goVarDecls:            make([]*ast.GenDecl, 0),
		goStmtList:            make([]ast.Stmt, 0),
		deferredStmts:         make(map[string][]ast.Stmt),
		tempVarCount:          0,
	}
}

// addError adds an error with position information if available
func (v *ManuscriptAstVisitor) addError(message string, token antlr.Token) {
	var line, column int
	if token != nil {
		line = token.GetLine()
		column = token.GetColumn()
	}

	errMsg := fmt.Sprintf("Error: %s (file: %s, line: %d, col: %d)",
		message, v.currentFile, line, column)
	v.Errors = append(v.Errors, errMsg)
}

// ANTLR Visitor Pattern Core Methods

// Visit dispatches to the appropriate visitor method based on the node type
func (v *ManuscriptAstVisitor) Visit(tree antlr.ParseTree) interface{} {
	if tree == nil {
		v.addError("Attempted to visit a nil tree node", nil)
		return &ast.BadStmt{From: gotoken.NoPos, To: gotoken.NoPos}
	}
	return tree.Accept(v)
}

// VisitChildren visits all child nodes of the given node
// Returns the result of the last non-nil child visit
func (v *ManuscriptAstVisitor) VisitChildren(node antlr.RuleNode) interface{} {
	var result interface{}

	for i := 0; i < node.GetChildCount(); i++ {
		child := node.GetChild(i)
		if child == nil {
			continue
		}

		if parseTree, ok := child.(antlr.ParseTree); ok {
			childResult := v.Visit(parseTree)
			if childResult != nil {
				result = childResult
			}
		}
	}

	return result
}

// VisitErrorNode handles ANTLR error nodes
func (v *ManuscriptAstVisitor) VisitErrorNode(node antlr.ErrorNode) interface{} {
	text := node.GetText()
	pos := v.pos(node.GetSymbol())

	// Handle special cases
	if text == "<EOF>" {
		v.addError("Unexpected EOF or extra input", node.GetSymbol())
		return &ast.BadStmt{From: pos, To: pos}
	}

	// Handle break/continue keywords correctly when in loop context
	if (text == "break" || text == "continue") && v.isInLoop() {
		tok := gotoken.BREAK
		if text == "continue" {
			tok = gotoken.CONTINUE
		}
		return &ast.BranchStmt{
			TokPos: pos,
			Tok:    tok,
		}
	}

	v.addError("Error node encountered: "+text, node.GetSymbol())
	return &ast.BadStmt{From: pos, To: pos}
}

// Position Utilities

// pos converts an ANTLR token position to a Go token position
func (v *ManuscriptAstVisitor) pos(token antlr.Token) gotoken.Pos {
	if token == nil || v.goFileSet == nil {
		return gotoken.NoPos
	}

	// TODO: Implement proper position mapping with line/column information
	// This is a temporary implementation that uses token indices
	return gotoken.Pos(token.GetTokenIndex() + 1)
}

// Context Tracking Methods

// enterLoop increments the loop nesting counter
func (v *ManuscriptAstVisitor) enterLoop() {
	v.loopDepth++
}

// exitLoop decrements the loop nesting counter
func (v *ManuscriptAstVisitor) exitLoop() {
	if v.loopDepth > 0 {
		v.loopDepth--
	}
}

// isInLoop checks if currently inside a loop construct
func (v *ManuscriptAstVisitor) isInLoop() bool {
	return v.loopDepth > 0
}

// Scope Management

// enterScope creates a new scope with the current scope as parent
func (v *ManuscriptAstVisitor) enterScope() {
	v.currentScope = NewScope(v.currentScope)
}

// exitScope returns to the parent scope
func (v *ManuscriptAstVisitor) exitScope() {
	if v.currentScope != nil && v.currentScope.parent != nil {
		v.currentScope = v.currentScope.parent
	}
}

// Symbol Table Types and Methods

// SymbolKind defines the type of a symbol
type SymbolKind int

const (
	VarSymbol SymbolKind = iota
	FuncSymbol
	TypeSymbol
	PackageSymbol
	// Add other kinds as needed
)

// Symbol represents an entry in the symbol table
type Symbol struct {
	Name string
	Kind SymbolKind
	Type string // Type name e.g., "int", "string", "MyStruct"
	Pos  gotoken.Pos
}

// Scope represents a lexical scope
type Scope struct {
	parent  *Scope
	symbols map[string]*Symbol
}

// NewScope creates a new scope with the given parent
func NewScope(parent *Scope) *Scope {
	return &Scope{
		parent:  parent,
		symbols: make(map[string]*Symbol),
	}
}

// Define adds a symbol to the current scope
func (s *Scope) Define(name string, kind SymbolKind, symType string, pos gotoken.Pos) (*Symbol, error) {
	if _, exists := s.symbols[name]; exists {
		return nil, fmt.Errorf("symbol '%s' already defined in this scope", name)
	}

	sym := &Symbol{
		Name: name,
		Kind: kind,
		Type: symType,
		Pos:  pos,
	}
	s.symbols[name] = sym
	return sym, nil
}

// Resolve looks up a symbol by name in the current scope and parent scopes
func (s *Scope) Resolve(name string) (*Symbol, *Scope) {
	for scope := s; scope != nil; scope = scope.parent {
		if sym, found := scope.symbols[name]; found {
			return sym, scope
		}
	}
	return nil, nil
}

// SymbolTable manages the global scope
type SymbolTable struct {
	Global *Scope
}

// NewSymbolTable creates a new symbol table with initialized global scope
func NewSymbolTable() *SymbolTable {
	globalScope := NewScope(nil)
	// Add predefined symbols/types to global scope if needed
	return &SymbolTable{
		Global: globalScope,
	}
}

// Utility Methods

// nextTempVarCounter generates a unique sequential identifier for temporary variables
func (v *ManuscriptAstVisitor) nextTempVarCounter() string {
	v.tempVarCount++
	return strconv.Itoa(v.tempVarCount)
}
