// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "'\\n'", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'",
		"'interface'", "'import'", "'export'", "'extern'", "'void'", "'check'",
		"'try'", "'catch'", "'in'", "'as'", "'is'", "'extends'", "'from'", "'null'",
		"'if'", "'else'", "'for'", "'while'", "'true'", "'false'", "'match'",
		"'case'", "'async'", "'await'", "'methods'", "'break'", "'continue'",
		"'default'", "'defer'", "'go'", "", "", "'['", "']'", "'('", "')'",
		"'<'", "'>'", "'<='", "'>='", "':'", "';'", "','", "'='", "'=='", "'+'",
		"'-'", "'++'", "'--'", "'||'", "'&&'", "'*'", "'/'", "'%'", "'!'", "'?'",
		"'.'", "'!='", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'|'",
		"'&'", "'^'", "'<<'", "'>>'",
	}
	staticData.SymbolicNames = []string{
		"", "NEWLINE", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN",
		"YIELD", "TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID",
		"CHECK", "TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL",
		"IF", "ELSE", "FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC",
		"AWAIT", "METHODS", "BREAK", "CONTINUE", "DEFAULT", "DEFER", "GO", "LBRACE",
		"RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN", "LT", "GT", "LT_EQUALS",
		"GT_EQUALS", "COLON", "SEMICOLON", "COMMA", "EQUALS", "EQUALS_EQUALS",
		"PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS", "PIPE_PIPE", "AMP_AMP",
		"STAR", "SLASH", "MOD", "EXCLAMATION", "QUESTION", "DOT", "NEQ", "PLUS_EQUALS",
		"MINUS_EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "MOD_EQUALS", "CARET_EQUALS",
		"PIPE", "AMP", "CARET", "LSHIFT", "RSHIFT", "HEX_LITERAL", "BINARY_LITERAL",
		"OCTAL_LITERAL", "FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"DOUBLE_QUOTE_START", "MULTI_DOUBLE_QUOTE_START", "SINGLE_STR_INTERP_START",
		"SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START", "MULTI_STR_CONTENT",
		"MULTI_STR_END", "DOUBLE_STR_INTERP_START", "DOUBLE_STR_CONTENT", "DOUBLE_STR_END",
		"MULTI_DOUBLE_STR_INTERP_START", "MULTI_DOUBLE_STR_CONTENT", "MULTI_DOUBLE_STR_END",
		"INTERP_LBRACE", "INTERP_RBRACE", "INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "declaration", "importDecl", "exportDecl", "externDecl",
		"exportedItem", "moduleImport", "destructuredImport", "targetImport",
		"importItemList", "importItem", "letDecl", "letSingle", "letBlock",
		"letBlockItemList", "letBlockItemSep", "letBlockItem", "letDestructuredObj",
		"letDestructuredArray", "typedIDList", "typedID", "typeDecl", "typeDefBody",
		"typeAlias", "fieldList", "fieldDecl", "typeList", "interfaceDecl",
		"interfaceMethod", "fnDecl", "fnSignature", "parameters", "param", "methodsDecl",
		"methodImplList", "methodImpl", "stmt", "returnStmt", "yieldStmt", "deferStmt",
		"asyncStmt", "goStmt", "exprList", "ifStmt", "forStmt", "forLoopType",
		"forTrinity", "forInit", "forCond", "forPost", "whileStmt", "loopBody",
		"codeBlock", "breakStmt", "continueStmt", "checkStmt", "pipedStmt",
		"pipedArgs", "pipedArg", "expr", "assignmentExpr", "assignmentOp", "ternaryExpr",
		"logicalOrExpr", "logicalAndExpr", "bitwiseXorExpr", "bitwiseAndExpr",
		"equalityExpr", "comparisonOp", "comparisonExpr", "additiveExpr", "multiplicativeExpr",
		"unaryExpr", "postfixExpr", "postfixOp", "primaryExpr", "tryExpr", "fnExpr",
		"matchExpr", "caseClause", "defaultClause", "singleQuotedString", "multiQuotedString",
		"doubleQuotedString", "multiDoubleQuotedString", "stringPart", "interpolation",
		"literal", "stringLiteral", "numberLiteral", "booleanLiteral", "arrayLiteral",
		"objectLiteral", "objectFieldList", "objectField", "objectFieldName",
		"mapLiteral", "mapFieldList", "mapField", "setLiteral", "taggedBlockString",
		"typedObjectLiteral", "typeAnnotation", "tupleType", "arrayType", "fnType",
		"stmt_sep",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 103, 1211, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 1, 0, 5, 0, 216, 8, 0, 10,
		0, 12, 0, 219, 9, 0, 1, 0, 1, 0, 4, 0, 223, 8, 0, 11, 0, 12, 0, 224, 1,
		0, 1, 0, 5, 0, 229, 8, 0, 10, 0, 12, 0, 232, 9, 0, 3, 0, 234, 8, 0, 1,
		0, 5, 0, 237, 8, 0, 10, 0, 12, 0, 240, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 252, 8, 1, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1,
		5, 3, 5, 270, 8, 5, 1, 6, 1, 6, 3, 6, 274, 8, 6, 1, 7, 1, 7, 3, 7, 278,
		8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9,
		5, 9, 291, 8, 9, 10, 9, 12, 9, 294, 9, 9, 1, 9, 3, 9, 297, 8, 9, 1, 10,
		1, 10, 1, 10, 3, 10, 302, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		3, 11, 320, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 326, 8, 12, 3, 12,
		328, 8, 12, 1, 13, 1, 13, 3, 13, 332, 8, 13, 1, 13, 1, 13, 1, 14, 5, 14,
		337, 8, 14, 10, 14, 12, 14, 340, 9, 14, 1, 14, 1, 14, 4, 14, 344, 8, 14,
		11, 14, 12, 14, 345, 1, 14, 1, 14, 5, 14, 350, 8, 14, 10, 14, 12, 14, 353,
		9, 14, 1, 14, 5, 14, 356, 8, 14, 10, 14, 12, 14, 359, 9, 14, 1, 15, 1,
		15, 3, 15, 363, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1,
		19, 1, 19, 5, 19, 384, 8, 19, 10, 19, 12, 19, 387, 9, 19, 1, 19, 3, 19,
		390, 8, 19, 1, 20, 1, 20, 3, 20, 394, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21,
		3, 21, 400, 8, 21, 1, 22, 1, 22, 3, 22, 404, 8, 22, 1, 22, 1, 22, 5, 22,
		408, 8, 22, 10, 22, 12, 22, 411, 9, 22, 1, 22, 1, 22, 5, 22, 415, 8, 22,
		10, 22, 12, 22, 418, 9, 22, 1, 22, 1, 22, 5, 22, 422, 8, 22, 10, 22, 12,
		22, 425, 9, 22, 1, 22, 5, 22, 428, 8, 22, 10, 22, 12, 22, 431, 9, 22, 1,
		22, 5, 22, 434, 8, 22, 10, 22, 12, 22, 437, 9, 22, 1, 22, 3, 22, 440, 8,
		22, 1, 22, 5, 22, 443, 8, 22, 10, 22, 12, 22, 446, 9, 22, 3, 22, 448, 8,
		22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 456, 8, 23, 1, 24,
		1, 24, 1, 24, 5, 24, 461, 8, 24, 10, 24, 12, 24, 464, 9, 24, 1, 24, 3,
		24, 467, 8, 24, 1, 25, 1, 25, 3, 25, 471, 8, 25, 1, 25, 1, 25, 1, 26, 1,
		26, 1, 26, 5, 26, 478, 8, 26, 10, 26, 12, 26, 481, 9, 26, 1, 26, 3, 26,
		484, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 490, 8, 27, 1, 27, 1, 27,
		5, 27, 494, 8, 27, 10, 27, 12, 27, 497, 9, 27, 1, 27, 1, 27, 5, 27, 501,
		8, 27, 10, 27, 12, 27, 504, 9, 27, 4, 27, 506, 8, 27, 11, 27, 12, 27, 507,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 515, 8, 28, 1, 28, 1, 28, 3,
		28, 519, 8, 28, 1, 28, 3, 28, 522, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 531, 8, 30, 1, 30, 1, 30, 3, 30, 535, 8, 30, 1,
		30, 3, 30, 538, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 543, 8, 31, 10, 31,
		12, 31, 546, 9, 31, 1, 31, 3, 31, 549, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		3, 32, 555, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 563,
		8, 33, 1, 33, 1, 33, 1, 34, 5, 34, 568, 8, 34, 10, 34, 12, 34, 571, 9,
		34, 1, 34, 1, 34, 4, 34, 575, 8, 34, 11, 34, 12, 34, 576, 1, 34, 1, 34,
		5, 34, 581, 8, 34, 10, 34, 12, 34, 584, 9, 34, 1, 34, 5, 34, 587, 8, 34,
		10, 34, 12, 34, 590, 9, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 615, 8, 36, 1, 37, 1,
		37, 3, 37, 619, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 625, 8, 38, 1,
		38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 42, 5, 42, 644, 8, 42, 10, 42, 12,
		42, 647, 9, 42, 1, 42, 3, 42, 650, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 3, 43, 657, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 666, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 672, 8, 45, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 683, 8,
		47, 1, 48, 1, 48, 3, 48, 687, 8, 48, 1, 49, 1, 49, 3, 49, 691, 8, 49, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 5, 51, 699, 8, 51, 10, 51, 12, 51,
		702, 9, 51, 1, 51, 1, 51, 4, 51, 706, 8, 51, 11, 51, 12, 51, 707, 1, 51,
		1, 51, 5, 51, 712, 8, 51, 10, 51, 12, 51, 715, 9, 51, 3, 51, 717, 8, 51,
		1, 51, 5, 51, 720, 8, 51, 10, 51, 12, 51, 723, 9, 51, 1, 51, 1, 51, 1,
		52, 1, 52, 5, 52, 729, 8, 52, 10, 52, 12, 52, 732, 9, 52, 1, 52, 1, 52,
		4, 52, 736, 8, 52, 11, 52, 12, 52, 737, 1, 52, 1, 52, 5, 52, 742, 8, 52,
		10, 52, 12, 52, 745, 9, 52, 3, 52, 747, 8, 52, 1, 52, 5, 52, 750, 8, 52,
		10, 52, 12, 52, 753, 9, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1,
		54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 773, 8, 56, 4, 56, 775, 8, 56, 11, 56, 12, 56, 776, 1, 56,
		1, 56, 1, 57, 4, 57, 782, 8, 57, 11, 57, 12, 57, 783, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 797,
		8, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3,
		62, 808, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 816, 8,
		63, 10, 63, 12, 63, 819, 9, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64,
		5, 64, 827, 8, 64, 10, 64, 12, 64, 830, 9, 64, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 5, 65, 838, 8, 65, 10, 65, 12, 65, 841, 9, 65, 1, 66,
		1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 849, 8, 66, 10, 66, 12, 66, 852,
		9, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 860, 8, 67, 10,
		67, 12, 67, 863, 9, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 1, 69, 5, 69, 874, 8, 69, 10, 69, 12, 69, 877, 9, 69, 1, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 885, 8, 70, 10, 70, 12, 70, 888,
		9, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 5, 71, 896, 8, 71, 10,
		71, 12, 71, 899, 9, 71, 1, 72, 1, 72, 1, 72, 3, 72, 904, 8, 72, 1, 73,
		1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 911, 8, 73, 10, 73, 12, 73, 914, 9,
		73, 1, 74, 1, 74, 3, 74, 918, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74,
		1, 74, 1, 74, 3, 74, 927, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		3, 75, 945, 8, 75, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 3, 77, 953,
		8, 77, 1, 77, 1, 77, 3, 77, 957, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1,
		78, 1, 78, 5, 78, 965, 8, 78, 10, 78, 12, 78, 968, 9, 78, 1, 78, 1, 78,
		4, 78, 972, 8, 78, 11, 78, 12, 78, 973, 1, 78, 1, 78, 5, 78, 978, 8, 78,
		10, 78, 12, 78, 981, 9, 78, 1, 78, 5, 78, 984, 8, 78, 10, 78, 12, 78, 987,
		9, 78, 1, 78, 3, 78, 990, 8, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1,
		79, 3, 79, 998, 8, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80,
		1006, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 5, 81, 1012, 8, 81, 10, 81, 12,
		81, 1015, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82, 5, 82, 1021, 8, 82, 10, 82,
		12, 82, 1024, 9, 82, 1, 82, 1, 82, 1, 83, 1, 83, 5, 83, 1030, 8, 83, 10,
		83, 12, 83, 1033, 9, 83, 1, 83, 1, 83, 1, 84, 1, 84, 5, 84, 1039, 8, 84,
		10, 84, 12, 84, 1042, 9, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85,
		1, 85, 3, 85, 1051, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1,
		87, 1, 87, 1, 87, 3, 87, 1062, 8, 87, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88,
		1068, 8, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1075, 8, 89, 1,
		90, 1, 90, 3, 90, 1079, 8, 90, 1, 91, 1, 91, 3, 91, 1083, 8, 91, 1, 91,
		1, 91, 1, 92, 1, 92, 3, 92, 1089, 8, 92, 1, 92, 1, 92, 1, 93, 5, 93, 1094,
		8, 93, 10, 93, 12, 93, 1097, 9, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93,
		3, 93, 1104, 8, 93, 1, 93, 5, 93, 1107, 8, 93, 10, 93, 12, 93, 1110, 9,
		93, 1, 93, 3, 93, 1113, 8, 93, 1, 93, 5, 93, 1116, 8, 93, 10, 93, 12, 93,
		1119, 9, 93, 1, 94, 1, 94, 1, 94, 3, 94, 1124, 8, 94, 1, 95, 1, 95, 3,
		95, 1128, 8, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 1135, 8, 96,
		1, 96, 3, 96, 1138, 8, 96, 1, 97, 1, 97, 1, 97, 5, 97, 1143, 8, 97, 10,
		97, 12, 97, 1146, 9, 97, 1, 97, 3, 97, 1149, 8, 97, 1, 98, 1, 98, 1, 98,
		1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1159, 8, 99, 10, 99, 12, 99,
		1162, 9, 99, 1, 99, 3, 99, 1165, 8, 99, 3, 99, 1167, 8, 99, 1, 99, 1, 99,
		1, 100, 1, 100, 1, 100, 3, 100, 1174, 8, 100, 1, 101, 1, 101, 1, 101, 3,
		101, 1179, 8, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102,
		3, 102, 1188, 8, 102, 1, 103, 1, 103, 3, 103, 1192, 8, 103, 1, 103, 1,
		103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 3, 105, 1203,
		8, 105, 1, 105, 1, 105, 3, 105, 1207, 8, 105, 1, 106, 1, 106, 1, 106, 0,
		9, 126, 128, 130, 132, 134, 138, 140, 142, 146, 107, 0, 2, 4, 6, 8, 10,
		12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,
		48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82,
		84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114,
		116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144,
		146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174,
		176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204,
		206, 208, 210, 212, 0, 7, 2, 0, 53, 53, 68, 73, 2, 0, 54, 54, 67, 67, 1,
		0, 46, 49, 1, 0, 55, 56, 1, 0, 61, 63, 2, 0, 55, 56, 64, 64, 4, 0, 89,
		89, 92, 92, 95, 95, 98, 98, 1291, 0, 217, 1, 0, 0, 0, 2, 251, 1, 0, 0,
		0, 4, 253, 1, 0, 0, 0, 6, 257, 1, 0, 0, 0, 8, 261, 1, 0, 0, 0, 10, 269,
		1, 0, 0, 0, 12, 273, 1, 0, 0, 0, 14, 275, 1, 0, 0, 0, 16, 283, 1, 0, 0,
		0, 18, 287, 1, 0, 0, 0, 20, 298, 1, 0, 0, 0, 22, 319, 1, 0, 0, 0, 24, 321,
		1, 0, 0, 0, 26, 329, 1, 0, 0, 0, 28, 338, 1, 0, 0, 0, 30, 362, 1, 0, 0,
		0, 32, 364, 1, 0, 0, 0, 34, 368, 1, 0, 0, 0, 36, 374, 1, 0, 0, 0, 38, 380,
		1, 0, 0, 0, 40, 391, 1, 0, 0, 0, 42, 395, 1, 0, 0, 0, 44, 403, 1, 0, 0,
		0, 46, 451, 1, 0, 0, 0, 48, 457, 1, 0, 0, 0, 50, 468, 1, 0, 0, 0, 52, 474,
		1, 0, 0, 0, 54, 485, 1, 0, 0, 0, 56, 511, 1, 0, 0, 0, 58, 523, 1, 0, 0,
		0, 60, 526, 1, 0, 0, 0, 62, 539, 1, 0, 0, 0, 64, 550, 1, 0, 0, 0, 66, 556,
		1, 0, 0, 0, 68, 569, 1, 0, 0, 0, 70, 591, 1, 0, 0, 0, 72, 614, 1, 0, 0,
		0, 74, 616, 1, 0, 0, 0, 76, 622, 1, 0, 0, 0, 78, 628, 1, 0, 0, 0, 80, 632,
		1, 0, 0, 0, 82, 636, 1, 0, 0, 0, 84, 640, 1, 0, 0, 0, 86, 651, 1, 0, 0,
		0, 88, 658, 1, 0, 0, 0, 90, 671, 1, 0, 0, 0, 92, 673, 1, 0, 0, 0, 94, 682,
		1, 0, 0, 0, 96, 686, 1, 0, 0, 0, 98, 690, 1, 0, 0, 0, 100, 692, 1, 0, 0,
		0, 102, 696, 1, 0, 0, 0, 104, 726, 1, 0, 0, 0, 106, 756, 1, 0, 0, 0, 108,
		759, 1, 0, 0, 0, 110, 762, 1, 0, 0, 0, 112, 768, 1, 0, 0, 0, 114, 781,
		1, 0, 0, 0, 116, 785, 1, 0, 0, 0, 118, 789, 1, 0, 0, 0, 120, 796, 1, 0,
		0, 0, 122, 798, 1, 0, 0, 0, 124, 807, 1, 0, 0, 0, 126, 809, 1, 0, 0, 0,
		128, 820, 1, 0, 0, 0, 130, 831, 1, 0, 0, 0, 132, 842, 1, 0, 0, 0, 134,
		853, 1, 0, 0, 0, 136, 864, 1, 0, 0, 0, 138, 866, 1, 0, 0, 0, 140, 878,
		1, 0, 0, 0, 142, 889, 1, 0, 0, 0, 144, 903, 1, 0, 0, 0, 146, 905, 1, 0,
		0, 0, 148, 926, 1, 0, 0, 0, 150, 944, 1, 0, 0, 0, 152, 946, 1, 0, 0, 0,
		154, 949, 1, 0, 0, 0, 156, 960, 1, 0, 0, 0, 158, 993, 1, 0, 0, 0, 160,
		1001, 1, 0, 0, 0, 162, 1009, 1, 0, 0, 0, 164, 1018, 1, 0, 0, 0, 166, 1027,
		1, 0, 0, 0, 168, 1036, 1, 0, 0, 0, 170, 1050, 1, 0, 0, 0, 172, 1052, 1,
		0, 0, 0, 174, 1061, 1, 0, 0, 0, 176, 1067, 1, 0, 0, 0, 178, 1074, 1, 0,
		0, 0, 180, 1078, 1, 0, 0, 0, 182, 1080, 1, 0, 0, 0, 184, 1086, 1, 0, 0,
		0, 186, 1095, 1, 0, 0, 0, 188, 1120, 1, 0, 0, 0, 190, 1127, 1, 0, 0, 0,
		192, 1137, 1, 0, 0, 0, 194, 1139, 1, 0, 0, 0, 196, 1150, 1, 0, 0, 0, 198,
		1154, 1, 0, 0, 0, 200, 1170, 1, 0, 0, 0, 202, 1175, 1, 0, 0, 0, 204, 1187,
		1, 0, 0, 0, 206, 1189, 1, 0, 0, 0, 208, 1195, 1, 0, 0, 0, 210, 1199, 1,
		0, 0, 0, 212, 1208, 1, 0, 0, 0, 214, 216, 3, 212, 106, 0, 215, 214, 1,
		0, 0, 0, 216, 219, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 217, 218, 1, 0, 0,
		0, 218, 233, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 220, 230, 3, 2, 1, 0, 221,
		223, 3, 212, 106, 0, 222, 221, 1, 0, 0, 0, 223, 224, 1, 0, 0, 0, 224, 222,
		1, 0, 0, 0, 224, 225, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 227, 3, 2,
		1, 0, 227, 229, 1, 0, 0, 0, 228, 222, 1, 0, 0, 0, 229, 232, 1, 0, 0, 0,
		230, 228, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0, 231, 234, 1, 0, 0, 0, 232,
		230, 1, 0, 0, 0, 233, 220, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 238,
		1, 0, 0, 0, 235, 237, 3, 212, 106, 0, 236, 235, 1, 0, 0, 0, 237, 240, 1,
		0, 0, 0, 238, 236, 1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239, 241, 1, 0, 0,
		0, 240, 238, 1, 0, 0, 0, 241, 242, 5, 0, 0, 1, 242, 1, 1, 0, 0, 0, 243,
		252, 3, 4, 2, 0, 244, 252, 3, 6, 3, 0, 245, 252, 3, 8, 4, 0, 246, 252,
		3, 22, 11, 0, 247, 252, 3, 42, 21, 0, 248, 252, 3, 54, 27, 0, 249, 252,
		3, 58, 29, 0, 250, 252, 3, 66, 33, 0, 251, 243, 1, 0, 0, 0, 251, 244, 1,
		0, 0, 0, 251, 245, 1, 0, 0, 0, 251, 246, 1, 0, 0, 0, 251, 247, 1, 0, 0,
		0, 251, 248, 1, 0, 0, 0, 251, 249, 1, 0, 0, 0, 251, 250, 1, 0, 0, 0, 252,
		3, 1, 0, 0, 0, 253, 254, 5, 11, 0, 0, 254, 255, 3, 12, 6, 0, 255, 256,
		5, 51, 0, 0, 256, 5, 1, 0, 0, 0, 257, 258, 5, 12, 0, 0, 258, 259, 3, 10,
		5, 0, 259, 260, 5, 51, 0, 0, 260, 7, 1, 0, 0, 0, 261, 262, 5, 13, 0, 0,
		262, 263, 3, 12, 6, 0, 263, 264, 5, 51, 0, 0, 264, 9, 1, 0, 0, 0, 265,
		270, 3, 58, 29, 0, 266, 270, 3, 22, 11, 0, 267, 270, 3, 42, 21, 0, 268,
		270, 3, 54, 27, 0, 269, 265, 1, 0, 0, 0, 269, 266, 1, 0, 0, 0, 269, 267,
		1, 0, 0, 0, 269, 268, 1, 0, 0, 0, 270, 11, 1, 0, 0, 0, 271, 274, 3, 14,
		7, 0, 272, 274, 3, 16, 8, 0, 273, 271, 1, 0, 0, 0, 273, 272, 1, 0, 0, 0,
		274, 13, 1, 0, 0, 0, 275, 277, 5, 40, 0, 0, 276, 278, 3, 18, 9, 0, 277,
		276, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 280,
		5, 41, 0, 0, 280, 281, 5, 22, 0, 0, 281, 282, 3, 162, 81, 0, 282, 15, 1,
		0, 0, 0, 283, 284, 5, 84, 0, 0, 284, 285, 5, 22, 0, 0, 285, 286, 3, 162,
		81, 0, 286, 17, 1, 0, 0, 0, 287, 292, 3, 20, 10, 0, 288, 289, 5, 52, 0,
		0, 289, 291, 3, 20, 10, 0, 290, 288, 1, 0, 0, 0, 291, 294, 1, 0, 0, 0,
		292, 290, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 296, 1, 0, 0, 0, 294,
		292, 1, 0, 0, 0, 295, 297, 5, 52, 0, 0, 296, 295, 1, 0, 0, 0, 296, 297,
		1, 0, 0, 0, 297, 19, 1, 0, 0, 0, 298, 301, 5, 84, 0, 0, 299, 300, 5, 19,
		0, 0, 300, 302, 5, 84, 0, 0, 301, 299, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0,
		302, 21, 1, 0, 0, 0, 303, 304, 5, 5, 0, 0, 304, 305, 3, 24, 12, 0, 305,
		306, 5, 51, 0, 0, 306, 320, 1, 0, 0, 0, 307, 308, 5, 5, 0, 0, 308, 309,
		3, 26, 13, 0, 309, 310, 5, 51, 0, 0, 310, 320, 1, 0, 0, 0, 311, 312, 5,
		5, 0, 0, 312, 313, 3, 34, 17, 0, 313, 314, 5, 51, 0, 0, 314, 320, 1, 0,
		0, 0, 315, 316, 5, 5, 0, 0, 316, 317, 3, 36, 18, 0, 317, 318, 5, 51, 0,
		0, 318, 320, 1, 0, 0, 0, 319, 303, 1, 0, 0, 0, 319, 307, 1, 0, 0, 0, 319,
		311, 1, 0, 0, 0, 319, 315, 1, 0, 0, 0, 320, 23, 1, 0, 0, 0, 321, 327, 3,
		40, 20, 0, 322, 325, 5, 53, 0, 0, 323, 326, 3, 118, 59, 0, 324, 326, 3,
		152, 76, 0, 325, 323, 1, 0, 0, 0, 325, 324, 1, 0, 0, 0, 326, 328, 1, 0,
		0, 0, 327, 322, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 25, 1, 0, 0, 0,
		329, 331, 5, 44, 0, 0, 330, 332, 3, 28, 14, 0, 331, 330, 1, 0, 0, 0, 331,
		332, 1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333, 334, 5, 45, 0, 0, 334, 27,
		1, 0, 0, 0, 335, 337, 3, 30, 15, 0, 336, 335, 1, 0, 0, 0, 337, 340, 1,
		0, 0, 0, 338, 336, 1, 0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 341, 1, 0, 0,
		0, 340, 338, 1, 0, 0, 0, 341, 351, 3, 32, 16, 0, 342, 344, 3, 30, 15, 0,
		343, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0, 345,
		346, 1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 348, 3, 32, 16, 0, 348, 350,
		1, 0, 0, 0, 349, 343, 1, 0, 0, 0, 350, 353, 1, 0, 0, 0, 351, 349, 1, 0,
		0, 0, 351, 352, 1, 0, 0, 0, 352, 357, 1, 0, 0, 0, 353, 351, 1, 0, 0, 0,
		354, 356, 3, 30, 15, 0, 355, 354, 1, 0, 0, 0, 356, 359, 1, 0, 0, 0, 357,
		355, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358, 29, 1, 0, 0, 0, 359, 357, 1,
		0, 0, 0, 360, 363, 5, 52, 0, 0, 361, 363, 3, 212, 106, 0, 362, 360, 1,
		0, 0, 0, 362, 361, 1, 0, 0, 0, 363, 31, 1, 0, 0, 0, 364, 365, 3, 40, 20,
		0, 365, 366, 5, 53, 0, 0, 366, 367, 3, 118, 59, 0, 367, 33, 1, 0, 0, 0,
		368, 369, 5, 40, 0, 0, 369, 370, 3, 38, 19, 0, 370, 371, 5, 41, 0, 0, 371,
		372, 5, 53, 0, 0, 372, 373, 3, 118, 59, 0, 373, 35, 1, 0, 0, 0, 374, 375,
		5, 42, 0, 0, 375, 376, 3, 38, 19, 0, 376, 377, 5, 43, 0, 0, 377, 378, 5,
		53, 0, 0, 378, 379, 3, 118, 59, 0, 379, 37, 1, 0, 0, 0, 380, 385, 3, 40,
		20, 0, 381, 382, 5, 52, 0, 0, 382, 384, 3, 40, 20, 0, 383, 381, 1, 0, 0,
		0, 384, 387, 1, 0, 0, 0, 385, 383, 1, 0, 0, 0, 385, 386, 1, 0, 0, 0, 386,
		389, 1, 0, 0, 0, 387, 385, 1, 0, 0, 0, 388, 390, 5, 52, 0, 0, 389, 388,
		1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 39, 1, 0, 0, 0, 391, 393, 5, 84,
		0, 0, 392, 394, 3, 204, 102, 0, 393, 392, 1, 0, 0, 0, 393, 394, 1, 0, 0,
		0, 394, 41, 1, 0, 0, 0, 395, 396, 5, 9, 0, 0, 396, 399, 5, 84, 0, 0, 397,
		400, 3, 44, 22, 0, 398, 400, 3, 46, 23, 0, 399, 397, 1, 0, 0, 0, 399, 398,
		1, 0, 0, 0, 400, 43, 1, 0, 0, 0, 401, 402, 5, 21, 0, 0, 402, 404, 3, 52,
		26, 0, 403, 401, 1, 0, 0, 0, 403, 404, 1, 0, 0, 0, 404, 405, 1, 0, 0, 0,
		405, 447, 5, 40, 0, 0, 406, 408, 3, 212, 106, 0, 407, 406, 1, 0, 0, 0,
		408, 411, 1, 0, 0, 0, 409, 407, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410,
		412, 1, 0, 0, 0, 411, 409, 1, 0, 0, 0, 412, 429, 3, 50, 25, 0, 413, 415,
		3, 212, 106, 0, 414, 413, 1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 414, 1,
		0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 419, 1, 0, 0, 0, 418, 416, 1, 0, 0,
		0, 419, 423, 5, 52, 0, 0, 420, 422, 3, 212, 106, 0, 421, 420, 1, 0, 0,
		0, 422, 425, 1, 0, 0, 0, 423, 421, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424,
		426, 1, 0, 0, 0, 425, 423, 1, 0, 0, 0, 426, 428, 3, 50, 25, 0, 427, 416,
		1, 0, 0, 0, 428, 431, 1, 0, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430, 1, 0,
		0, 0, 430, 439, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 432, 434, 3, 212, 106,
		0, 433, 432, 1, 0, 0, 0, 434, 437, 1, 0, 0, 0, 435, 433, 1, 0, 0, 0, 435,
		436, 1, 0, 0, 0, 436, 438, 1, 0, 0, 0, 437, 435, 1, 0, 0, 0, 438, 440,
		5, 52, 0, 0, 439, 435, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 444, 1, 0,
		0, 0, 441, 443, 3, 212, 106, 0, 442, 441, 1, 0, 0, 0, 443, 446, 1, 0, 0,
		0, 444, 442, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 448, 1, 0, 0, 0, 446,
		444, 1, 0, 0, 0, 447, 409, 1, 0, 0, 0, 447, 448, 1, 0, 0, 0, 448, 449,
		1, 0, 0, 0, 449, 450, 5, 41, 0, 0, 450, 45, 1, 0, 0, 0, 451, 452, 5, 53,
		0, 0, 452, 455, 3, 204, 102, 0, 453, 454, 5, 21, 0, 0, 454, 456, 3, 52,
		26, 0, 455, 453, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 47, 1, 0, 0, 0,
		457, 462, 3, 50, 25, 0, 458, 459, 5, 52, 0, 0, 459, 461, 3, 50, 25, 0,
		460, 458, 1, 0, 0, 0, 461, 464, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 462,
		463, 1, 0, 0, 0, 463, 466, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 465, 467,
		5, 52, 0, 0, 466, 465, 1, 0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 49, 1, 0,
		0, 0, 468, 470, 5, 84, 0, 0, 469, 471, 5, 65, 0, 0, 470, 469, 1, 0, 0,
		0, 470, 471, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 473, 3, 204, 102, 0,
		473, 51, 1, 0, 0, 0, 474, 479, 3, 204, 102, 0, 475, 476, 5, 52, 0, 0, 476,
		478, 3, 204, 102, 0, 477, 475, 1, 0, 0, 0, 478, 481, 1, 0, 0, 0, 479, 477,
		1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 483, 1, 0, 0, 0, 481, 479, 1, 0,
		0, 0, 482, 484, 5, 52, 0, 0, 483, 482, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0,
		484, 53, 1, 0, 0, 0, 485, 486, 5, 10, 0, 0, 486, 489, 5, 84, 0, 0, 487,
		488, 5, 21, 0, 0, 488, 490, 3, 52, 26, 0, 489, 487, 1, 0, 0, 0, 489, 490,
		1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491, 505, 5, 40, 0, 0, 492, 494, 3, 212,
		106, 0, 493, 492, 1, 0, 0, 0, 494, 497, 1, 0, 0, 0, 495, 493, 1, 0, 0,
		0, 495, 496, 1, 0, 0, 0, 496, 498, 1, 0, 0, 0, 497, 495, 1, 0, 0, 0, 498,
		502, 3, 56, 28, 0, 499, 501, 3, 212, 106, 0, 500, 499, 1, 0, 0, 0, 501,
		504, 1, 0, 0, 0, 502, 500, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 506,
		1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 505, 495, 1, 0, 0, 0, 506, 507, 1, 0,
		0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0,
		509, 510, 5, 41, 0, 0, 510, 55, 1, 0, 0, 0, 511, 512, 5, 84, 0, 0, 512,
		514, 5, 44, 0, 0, 513, 515, 3, 62, 31, 0, 514, 513, 1, 0, 0, 0, 514, 515,
		1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 518, 5, 45, 0, 0, 517, 519, 3, 204,
		102, 0, 518, 517, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 521, 1, 0, 0,
		0, 520, 522, 5, 64, 0, 0, 521, 520, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522,
		57, 1, 0, 0, 0, 523, 524, 3, 60, 30, 0, 524, 525, 3, 104, 52, 0, 525, 59,
		1, 0, 0, 0, 526, 527, 5, 6, 0, 0, 527, 528, 5, 84, 0, 0, 528, 530, 5, 44,
		0, 0, 529, 531, 3, 62, 31, 0, 530, 529, 1, 0, 0, 0, 530, 531, 1, 0, 0,
		0, 531, 532, 1, 0, 0, 0, 532, 534, 5, 45, 0, 0, 533, 535, 3, 204, 102,
		0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 537, 1, 0, 0, 0, 536,
		538, 5, 64, 0, 0, 537, 536, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 61,
		1, 0, 0, 0, 539, 544, 3, 64, 32, 0, 540, 541, 5, 52, 0, 0, 541, 543, 3,
		64, 32, 0, 542, 540, 1, 0, 0, 0, 543, 546, 1, 0, 0, 0, 544, 542, 1, 0,
		0, 0, 544, 545, 1, 0, 0, 0, 545, 548, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0,
		547, 549, 5, 52, 0, 0, 548, 547, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549,
		63, 1, 0, 0, 0, 550, 551, 5, 84, 0, 0, 551, 554, 3, 204, 102, 0, 552, 553,
		5, 53, 0, 0, 553, 555, 3, 118, 59, 0, 554, 552, 1, 0, 0, 0, 554, 555, 1,
		0, 0, 0, 555, 65, 1, 0, 0, 0, 556, 557, 5, 34, 0, 0, 557, 558, 5, 84, 0,
		0, 558, 559, 5, 19, 0, 0, 559, 560, 5, 84, 0, 0, 560, 562, 5, 40, 0, 0,
		561, 563, 3, 68, 34, 0, 562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563,
		564, 1, 0, 0, 0, 564, 565, 5, 41, 0, 0, 565, 67, 1, 0, 0, 0, 566, 568,
		3, 212, 106, 0, 567, 566, 1, 0, 0, 0, 568, 571, 1, 0, 0, 0, 569, 567, 1,
		0, 0, 0, 569, 570, 1, 0, 0, 0, 570, 572, 1, 0, 0, 0, 571, 569, 1, 0, 0,
		0, 572, 582, 3, 70, 35, 0, 573, 575, 3, 212, 106, 0, 574, 573, 1, 0, 0,
		0, 575, 576, 1, 0, 0, 0, 576, 574, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577,
		578, 1, 0, 0, 0, 578, 579, 3, 70, 35, 0, 579, 581, 1, 0, 0, 0, 580, 574,
		1, 0, 0, 0, 581, 584, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 582, 583, 1, 0,
		0, 0, 583, 588, 1, 0, 0, 0, 584, 582, 1, 0, 0, 0, 585, 587, 3, 212, 106,
		0, 586, 585, 1, 0, 0, 0, 587, 590, 1, 0, 0, 0, 588, 586, 1, 0, 0, 0, 588,
		589, 1, 0, 0, 0, 589, 69, 1, 0, 0, 0, 590, 588, 1, 0, 0, 0, 591, 592, 3,
		56, 28, 0, 592, 593, 3, 104, 52, 0, 593, 71, 1, 0, 0, 0, 594, 615, 3, 22,
		11, 0, 595, 596, 3, 118, 59, 0, 596, 597, 5, 51, 0, 0, 597, 615, 1, 0,
		0, 0, 598, 615, 3, 74, 37, 0, 599, 615, 3, 76, 38, 0, 600, 615, 3, 86,
		43, 0, 601, 615, 3, 88, 44, 0, 602, 615, 3, 100, 50, 0, 603, 615, 3, 104,
		52, 0, 604, 615, 3, 106, 53, 0, 605, 615, 3, 108, 54, 0, 606, 615, 3, 110,
		55, 0, 607, 615, 3, 78, 39, 0, 608, 609, 3, 152, 76, 0, 609, 610, 5, 51,
		0, 0, 610, 615, 1, 0, 0, 0, 611, 615, 3, 112, 56, 0, 612, 615, 3, 80, 40,
		0, 613, 615, 3, 82, 41, 0, 614, 594, 1, 0, 0, 0, 614, 595, 1, 0, 0, 0,
		614, 598, 1, 0, 0, 0, 614, 599, 1, 0, 0, 0, 614, 600, 1, 0, 0, 0, 614,
		601, 1, 0, 0, 0, 614, 602, 1, 0, 0, 0, 614, 603, 1, 0, 0, 0, 614, 604,
		1, 0, 0, 0, 614, 605, 1, 0, 0, 0, 614, 606, 1, 0, 0, 0, 614, 607, 1, 0,
		0, 0, 614, 608, 1, 0, 0, 0, 614, 611, 1, 0, 0, 0, 614, 612, 1, 0, 0, 0,
		614, 613, 1, 0, 0, 0, 615, 73, 1, 0, 0, 0, 616, 618, 5, 7, 0, 0, 617, 619,
		3, 84, 42, 0, 618, 617, 1, 0, 0, 0, 618, 619, 1, 0, 0, 0, 619, 620, 1,
		0, 0, 0, 620, 621, 5, 51, 0, 0, 621, 75, 1, 0, 0, 0, 622, 624, 5, 8, 0,
		0, 623, 625, 3, 84, 42, 0, 624, 623, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0,
		625, 626, 1, 0, 0, 0, 626, 627, 5, 51, 0, 0, 627, 77, 1, 0, 0, 0, 628,
		629, 5, 38, 0, 0, 629, 630, 3, 118, 59, 0, 630, 631, 5, 51, 0, 0, 631,
		79, 1, 0, 0, 0, 632, 633, 5, 32, 0, 0, 633, 634, 3, 118, 59, 0, 634, 635,
		5, 51, 0, 0, 635, 81, 1, 0, 0, 0, 636, 637, 5, 39, 0, 0, 637, 638, 3, 118,
		59, 0, 638, 639, 5, 51, 0, 0, 639, 83, 1, 0, 0, 0, 640, 645, 3, 118, 59,
		0, 641, 642, 5, 52, 0, 0, 642, 644, 3, 118, 59, 0, 643, 641, 1, 0, 0, 0,
		644, 647, 1, 0, 0, 0, 645, 643, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646,
		649, 1, 0, 0, 0, 647, 645, 1, 0, 0, 0, 648, 650, 5, 52, 0, 0, 649, 648,
		1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 85, 1, 0, 0, 0, 651, 652, 5, 24,
		0, 0, 652, 653, 3, 118, 59, 0, 653, 656, 3, 104, 52, 0, 654, 655, 5, 25,
		0, 0, 655, 657, 3, 104, 52, 0, 656, 654, 1, 0, 0, 0, 656, 657, 1, 0, 0,
		0, 657, 87, 1, 0, 0, 0, 658, 659, 5, 26, 0, 0, 659, 660, 3, 90, 45, 0,
		660, 89, 1, 0, 0, 0, 661, 672, 3, 92, 46, 0, 662, 665, 5, 84, 0, 0, 663,
		664, 5, 52, 0, 0, 664, 666, 5, 84, 0, 0, 665, 663, 1, 0, 0, 0, 665, 666,
		1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667, 668, 5, 18, 0, 0, 668, 669, 3, 118,
		59, 0, 669, 670, 3, 102, 51, 0, 670, 672, 1, 0, 0, 0, 671, 661, 1, 0, 0,
		0, 671, 662, 1, 0, 0, 0, 672, 91, 1, 0, 0, 0, 673, 674, 3, 94, 47, 0, 674,
		675, 5, 51, 0, 0, 675, 676, 3, 96, 48, 0, 676, 677, 5, 51, 0, 0, 677, 678,
		3, 98, 49, 0, 678, 679, 3, 102, 51, 0, 679, 93, 1, 0, 0, 0, 680, 683, 3,
		24, 12, 0, 681, 683, 1, 0, 0, 0, 682, 680, 1, 0, 0, 0, 682, 681, 1, 0,
		0, 0, 683, 95, 1, 0, 0, 0, 684, 687, 3, 118, 59, 0, 685, 687, 1, 0, 0,
		0, 686, 684, 1, 0, 0, 0, 686, 685, 1, 0, 0, 0, 687, 97, 1, 0, 0, 0, 688,
		691, 3, 118, 59, 0, 689, 691, 1, 0, 0, 0, 690, 688, 1, 0, 0, 0, 690, 689,
		1, 0, 0, 0, 691, 99, 1, 0, 0, 0, 692, 693, 5, 27, 0, 0, 693, 694, 3, 118,
		59, 0, 694, 695, 3, 102, 51, 0, 695, 101, 1, 0, 0, 0, 696, 700, 5, 40,
		0, 0, 697, 699, 3, 212, 106, 0, 698, 697, 1, 0, 0, 0, 699, 702, 1, 0, 0,
		0, 700, 698, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 716, 1, 0, 0, 0, 702,
		700, 1, 0, 0, 0, 703, 713, 3, 72, 36, 0, 704, 706, 3, 212, 106, 0, 705,
		704, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 705, 1, 0, 0, 0, 707, 708,
		1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 710, 3, 72, 36, 0, 710, 712, 1,
		0, 0, 0, 711, 705, 1, 0, 0, 0, 712, 715, 1, 0, 0, 0, 713, 711, 1, 0, 0,
		0, 713, 714, 1, 0, 0, 0, 714, 717, 1, 0, 0, 0, 715, 713, 1, 0, 0, 0, 716,
		703, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 721, 1, 0, 0, 0, 718, 720,
		3, 212, 106, 0, 719, 718, 1, 0, 0, 0, 720, 723, 1, 0, 0, 0, 721, 719, 1,
		0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 724, 1, 0, 0, 0, 723, 721, 1, 0, 0,
		0, 724, 725, 5, 41, 0, 0, 725, 103, 1, 0, 0, 0, 726, 730, 5, 40, 0, 0,
		727, 729, 3, 212, 106, 0, 728, 727, 1, 0, 0, 0, 729, 732, 1, 0, 0, 0, 730,
		728, 1, 0, 0, 0, 730, 731, 1, 0, 0, 0, 731, 746, 1, 0, 0, 0, 732, 730,
		1, 0, 0, 0, 733, 743, 3, 72, 36, 0, 734, 736, 3, 212, 106, 0, 735, 734,
		1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 737, 738, 1, 0,
		0, 0, 738, 739, 1, 0, 0, 0, 739, 740, 3, 72, 36, 0, 740, 742, 1, 0, 0,
		0, 741, 735, 1, 0, 0, 0, 742, 745, 1, 0, 0, 0, 743, 741, 1, 0, 0, 0, 743,
		744, 1, 0, 0, 0, 744, 747, 1, 0, 0, 0, 745, 743, 1, 0, 0, 0, 746, 733,
		1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 751, 1, 0, 0, 0, 748, 750, 3, 212,
		106, 0, 749, 748, 1, 0, 0, 0, 750, 753, 1, 0, 0, 0, 751, 749, 1, 0, 0,
		0, 751, 752, 1, 0, 0, 0, 752, 754, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 754,
		755, 5, 41, 0, 0, 755, 105, 1, 0, 0, 0, 756, 757, 5, 35, 0, 0, 757, 758,
		5, 51, 0, 0, 758, 107, 1, 0, 0, 0, 759, 760, 5, 36, 0, 0, 760, 761, 5,
		51, 0, 0, 761, 109, 1, 0, 0, 0, 762, 763, 5, 15, 0, 0, 763, 764, 3, 118,
		59, 0, 764, 765, 5, 52, 0, 0, 765, 766, 3, 176, 88, 0, 766, 767, 5, 51,
		0, 0, 767, 111, 1, 0, 0, 0, 768, 774, 3, 146, 73, 0, 769, 770, 5, 74, 0,
		0, 770, 772, 3, 146, 73, 0, 771, 773, 3, 114, 57, 0, 772, 771, 1, 0, 0,
		0, 772, 773, 1, 0, 0, 0, 773, 775, 1, 0, 0, 0, 774, 769, 1, 0, 0, 0, 775,
		776, 1, 0, 0, 0, 776, 774, 1, 0, 0, 0, 776, 777, 1, 0, 0, 0, 777, 778,
		1, 0, 0, 0, 778, 779, 5, 51, 0, 0, 779, 113, 1, 0, 0, 0, 780, 782, 3, 116,
		58, 0, 781, 780, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783, 781, 1, 0, 0, 0,
		783, 784, 1, 0, 0, 0, 784, 115, 1, 0, 0, 0, 785, 786, 5, 84, 0, 0, 786,
		787, 5, 53, 0, 0, 787, 788, 3, 118, 59, 0, 788, 117, 1, 0, 0, 0, 789, 790,
		3, 120, 60, 0, 790, 119, 1, 0, 0, 0, 791, 797, 3, 124, 62, 0, 792, 793,
		3, 124, 62, 0, 793, 794, 3, 122, 61, 0, 794, 795, 3, 120, 60, 0, 795, 797,
		1, 0, 0, 0, 796, 791, 1, 0, 0, 0, 796, 792, 1, 0, 0, 0, 797, 121, 1, 0,
		0, 0, 798, 799, 7, 0, 0, 0, 799, 123, 1, 0, 0, 0, 800, 808, 3, 126, 63,
		0, 801, 802, 3, 126, 63, 0, 802, 803, 5, 65, 0, 0, 803, 804, 3, 118, 59,
		0, 804, 805, 5, 50, 0, 0, 805, 806, 3, 124, 62, 0, 806, 808, 1, 0, 0, 0,
		807, 800, 1, 0, 0, 0, 807, 801, 1, 0, 0, 0, 808, 125, 1, 0, 0, 0, 809,
		810, 6, 63, -1, 0, 810, 811, 3, 128, 64, 0, 811, 817, 1, 0, 0, 0, 812,
		813, 10, 1, 0, 0, 813, 814, 5, 59, 0, 0, 814, 816, 3, 128, 64, 0, 815,
		812, 1, 0, 0, 0, 816, 819, 1, 0, 0, 0, 817, 815, 1, 0, 0, 0, 817, 818,
		1, 0, 0, 0, 818, 127, 1, 0, 0, 0, 819, 817, 1, 0, 0, 0, 820, 821, 6, 64,
		-1, 0, 821, 822, 3, 130, 65, 0, 822, 828, 1, 0, 0, 0, 823, 824, 10, 1,
		0, 0, 824, 825, 5, 60, 0, 0, 825, 827, 3, 130, 65, 0, 826, 823, 1, 0, 0,
		0, 827, 830, 1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 828, 829, 1, 0, 0, 0, 829,
		129, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 831, 832, 6, 65, -1, 0, 832, 833,
		3, 132, 66, 0, 833, 839, 1, 0, 0, 0, 834, 835, 10, 1, 0, 0, 835, 836, 5,
		76, 0, 0, 836, 838, 3, 132, 66, 0, 837, 834, 1, 0, 0, 0, 838, 841, 1, 0,
		0, 0, 839, 837, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 131, 1, 0, 0, 0,
		841, 839, 1, 0, 0, 0, 842, 843, 6, 66, -1, 0, 843, 844, 3, 134, 67, 0,
		844, 850, 1, 0, 0, 0, 845, 846, 10, 1, 0, 0, 846, 847, 5, 75, 0, 0, 847,
		849, 3, 134, 67, 0, 848, 845, 1, 0, 0, 0, 849, 852, 1, 0, 0, 0, 850, 848,
		1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851, 133, 1, 0, 0, 0, 852, 850, 1, 0,
		0, 0, 853, 854, 6, 67, -1, 0, 854, 855, 3, 138, 69, 0, 855, 861, 1, 0,
		0, 0, 856, 857, 10, 1, 0, 0, 857, 858, 7, 1, 0, 0, 858, 860, 3, 138, 69,
		0, 859, 856, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861, 859, 1, 0, 0, 0, 861,
		862, 1, 0, 0, 0, 862, 135, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0, 864, 865,
		7, 2, 0, 0, 865, 137, 1, 0, 0, 0, 866, 867, 6, 69, -1, 0, 867, 868, 3,
		140, 70, 0, 868, 875, 1, 0, 0, 0, 869, 870, 10, 1, 0, 0, 870, 871, 3, 136,
		68, 0, 871, 872, 3, 140, 70, 0, 872, 874, 1, 0, 0, 0, 873, 869, 1, 0, 0,
		0, 874, 877, 1, 0, 0, 0, 875, 873, 1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876,
		139, 1, 0, 0, 0, 877, 875, 1, 0, 0, 0, 878, 879, 6, 70, -1, 0, 879, 880,
		3, 142, 71, 0, 880, 886, 1, 0, 0, 0, 881, 882, 10, 1, 0, 0, 882, 883, 7,
		3, 0, 0, 883, 885, 3, 142, 71, 0, 884, 881, 1, 0, 0, 0, 885, 888, 1, 0,
		0, 0, 886, 884, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887, 141, 1, 0, 0, 0,
		888, 886, 1, 0, 0, 0, 889, 890, 6, 71, -1, 0, 890, 891, 3, 144, 72, 0,
		891, 897, 1, 0, 0, 0, 892, 893, 10, 1, 0, 0, 893, 894, 7, 4, 0, 0, 894,
		896, 3, 144, 72, 0, 895, 892, 1, 0, 0, 0, 896, 899, 1, 0, 0, 0, 897, 895,
		1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 143, 1, 0, 0, 0, 899, 897, 1, 0,
		0, 0, 900, 901, 7, 5, 0, 0, 901, 904, 3, 144, 72, 0, 902, 904, 3, 146,
		73, 0, 903, 900, 1, 0, 0, 0, 903, 902, 1, 0, 0, 0, 904, 145, 1, 0, 0, 0,
		905, 906, 6, 73, -1, 0, 906, 907, 3, 150, 75, 0, 907, 912, 1, 0, 0, 0,
		908, 909, 10, 1, 0, 0, 909, 911, 3, 148, 74, 0, 910, 908, 1, 0, 0, 0, 911,
		914, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 147,
		1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 915, 917, 5, 44, 0, 0, 916, 918, 3, 84,
		42, 0, 917, 916, 1, 0, 0, 0, 917, 918, 1, 0, 0, 0, 918, 919, 1, 0, 0, 0,
		919, 927, 5, 45, 0, 0, 920, 921, 5, 66, 0, 0, 921, 927, 5, 84, 0, 0, 922,
		923, 5, 42, 0, 0, 923, 924, 3, 118, 59, 0, 924, 925, 5, 43, 0, 0, 925,
		927, 1, 0, 0, 0, 926, 915, 1, 0, 0, 0, 926, 920, 1, 0, 0, 0, 926, 922,
		1, 0, 0, 0, 927, 149, 1, 0, 0, 0, 928, 945, 3, 174, 87, 0, 929, 945, 3,
		202, 101, 0, 930, 945, 5, 84, 0, 0, 931, 932, 5, 44, 0, 0, 932, 933, 3,
		118, 59, 0, 933, 934, 5, 45, 0, 0, 934, 945, 1, 0, 0, 0, 935, 945, 3, 182,
		91, 0, 936, 945, 3, 184, 92, 0, 937, 945, 3, 192, 96, 0, 938, 945, 3, 198,
		99, 0, 939, 945, 3, 154, 77, 0, 940, 945, 3, 156, 78, 0, 941, 945, 5, 14,
		0, 0, 942, 945, 5, 23, 0, 0, 943, 945, 3, 200, 100, 0, 944, 928, 1, 0,
		0, 0, 944, 929, 1, 0, 0, 0, 944, 930, 1, 0, 0, 0, 944, 931, 1, 0, 0, 0,
		944, 935, 1, 0, 0, 0, 944, 936, 1, 0, 0, 0, 944, 937, 1, 0, 0, 0, 944,
		938, 1, 0, 0, 0, 944, 939, 1, 0, 0, 0, 944, 940, 1, 0, 0, 0, 944, 941,
		1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 944, 943, 1, 0, 0, 0, 945, 151, 1, 0,
		0, 0, 946, 947, 5, 16, 0, 0, 947, 948, 3, 118, 59, 0, 948, 153, 1, 0, 0,
		0, 949, 950, 5, 6, 0, 0, 950, 952, 5, 44, 0, 0, 951, 953, 3, 62, 31, 0,
		952, 951, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 954, 1, 0, 0, 0, 954,
		956, 5, 45, 0, 0, 955, 957, 3, 204, 102, 0, 956, 955, 1, 0, 0, 0, 956,
		957, 1, 0, 0, 0, 957, 958, 1, 0, 0, 0, 958, 959, 3, 104, 52, 0, 959, 155,
		1, 0, 0, 0, 960, 961, 5, 30, 0, 0, 961, 962, 3, 118, 59, 0, 962, 966, 5,
		40, 0, 0, 963, 965, 3, 212, 106, 0, 964, 963, 1, 0, 0, 0, 965, 968, 1,
		0, 0, 0, 966, 964, 1, 0, 0, 0, 966, 967, 1, 0, 0, 0, 967, 969, 1, 0, 0,
		0, 968, 966, 1, 0, 0, 0, 969, 979, 3, 158, 79, 0, 970, 972, 3, 212, 106,
		0, 971, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 973,
		974, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0, 975, 976, 3, 158, 79, 0, 976, 978,
		1, 0, 0, 0, 977, 971, 1, 0, 0, 0, 978, 981, 1, 0, 0, 0, 979, 977, 1, 0,
		0, 0, 979, 980, 1, 0, 0, 0, 980, 985, 1, 0, 0, 0, 981, 979, 1, 0, 0, 0,
		982, 984, 3, 212, 106, 0, 983, 982, 1, 0, 0, 0, 984, 987, 1, 0, 0, 0, 985,
		983, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 989, 1, 0, 0, 0, 987, 985,
		1, 0, 0, 0, 988, 990, 3, 160, 80, 0, 989, 988, 1, 0, 0, 0, 989, 990, 1,
		0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 992, 5, 41, 0, 0, 992, 157, 1, 0, 0,
		0, 993, 997, 3, 118, 59, 0, 994, 995, 5, 50, 0, 0, 995, 998, 3, 118, 59,
		0, 996, 998, 3, 104, 52, 0, 997, 994, 1, 0, 0, 0, 997, 996, 1, 0, 0, 0,
		998, 999, 1, 0, 0, 0, 999, 1000, 5, 51, 0, 0, 1000, 159, 1, 0, 0, 0, 1001,
		1005, 5, 37, 0, 0, 1002, 1003, 5, 50, 0, 0, 1003, 1006, 3, 118, 59, 0,
		1004, 1006, 3, 104, 52, 0, 1005, 1002, 1, 0, 0, 0, 1005, 1004, 1, 0, 0,
		0, 1006, 1007, 1, 0, 0, 0, 1007, 1008, 5, 51, 0, 0, 1008, 161, 1, 0, 0,
		0, 1009, 1013, 5, 85, 0, 0, 1010, 1012, 3, 170, 85, 0, 1011, 1010, 1, 0,
		0, 0, 1012, 1015, 1, 0, 0, 0, 1013, 1011, 1, 0, 0, 0, 1013, 1014, 1, 0,
		0, 0, 1014, 1016, 1, 0, 0, 0, 1015, 1013, 1, 0, 0, 0, 1016, 1017, 5, 91,
		0, 0, 1017, 163, 1, 0, 0, 0, 1018, 1022, 5, 86, 0, 0, 1019, 1021, 3, 170,
		85, 0, 1020, 1019, 1, 0, 0, 0, 1021, 1024, 1, 0, 0, 0, 1022, 1020, 1, 0,
		0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 1025, 1, 0, 0, 0, 1024, 1022, 1, 0,
		0, 0, 1025, 1026, 5, 94, 0, 0, 1026, 165, 1, 0, 0, 0, 1027, 1031, 5, 87,
		0, 0, 1028, 1030, 3, 170, 85, 0, 1029, 1028, 1, 0, 0, 0, 1030, 1033, 1,
		0, 0, 0, 1031, 1029, 1, 0, 0, 0, 1031, 1032, 1, 0, 0, 0, 1032, 1034, 1,
		0, 0, 0, 1033, 1031, 1, 0, 0, 0, 1034, 1035, 5, 97, 0, 0, 1035, 167, 1,
		0, 0, 0, 1036, 1040, 5, 88, 0, 0, 1037, 1039, 3, 170, 85, 0, 1038, 1037,
		1, 0, 0, 0, 1039, 1042, 1, 0, 0, 0, 1040, 1038, 1, 0, 0, 0, 1040, 1041,
		1, 0, 0, 0, 1041, 1043, 1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1043, 1044,
		5, 100, 0, 0, 1044, 169, 1, 0, 0, 0, 1045, 1051, 5, 90, 0, 0, 1046, 1051,
		5, 93, 0, 0, 1047, 1051, 5, 96, 0, 0, 1048, 1051, 5, 99, 0, 0, 1049, 1051,
		3, 172, 86, 0, 1050, 1045, 1, 0, 0, 0, 1050, 1046, 1, 0, 0, 0, 1050, 1047,
		1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1050, 1049, 1, 0, 0, 0, 1051, 171,
		1, 0, 0, 0, 1052, 1053, 7, 6, 0, 0, 1053, 1054, 3, 118, 59, 0, 1054, 1055,
		5, 102, 0, 0, 1055, 173, 1, 0, 0, 0, 1056, 1062, 3, 176, 88, 0, 1057, 1062,
		3, 178, 89, 0, 1058, 1062, 3, 180, 90, 0, 1059, 1062, 5, 23, 0, 0, 1060,
		1062, 5, 14, 0, 0, 1061, 1056, 1, 0, 0, 0, 1061, 1057, 1, 0, 0, 0, 1061,
		1058, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1061, 1060, 1, 0, 0, 0, 1062,
		175, 1, 0, 0, 0, 1063, 1068, 3, 162, 81, 0, 1064, 1068, 3, 164, 82, 0,
		1065, 1068, 3, 166, 83, 0, 1066, 1068, 3, 168, 84, 0, 1067, 1063, 1, 0,
		0, 0, 1067, 1064, 1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1067, 1066, 1, 0,
		0, 0, 1068, 177, 1, 0, 0, 0, 1069, 1075, 5, 83, 0, 0, 1070, 1075, 5, 82,
		0, 0, 1071, 1075, 5, 79, 0, 0, 1072, 1075, 5, 80, 0, 0, 1073, 1075, 5,
		81, 0, 0, 1074, 1069, 1, 0, 0, 0, 1074, 1070, 1, 0, 0, 0, 1074, 1071, 1,
		0, 0, 0, 1074, 1072, 1, 0, 0, 0, 1074, 1073, 1, 0, 0, 0, 1075, 179, 1,
		0, 0, 0, 1076, 1079, 5, 28, 0, 0, 1077, 1079, 5, 29, 0, 0, 1078, 1076,
		1, 0, 0, 0, 1078, 1077, 1, 0, 0, 0, 1079, 181, 1, 0, 0, 0, 1080, 1082,
		5, 42, 0, 0, 1081, 1083, 3, 84, 42, 0, 1082, 1081, 1, 0, 0, 0, 1082, 1083,
		1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1085, 5, 43, 0, 0, 1085, 183,
		1, 0, 0, 0, 1086, 1088, 5, 40, 0, 0, 1087, 1089, 3, 186, 93, 0, 1088, 1087,
		1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1090, 1, 0, 0, 0, 1090, 1091,
		5, 41, 0, 0, 1091, 185, 1, 0, 0, 0, 1092, 1094, 5, 1, 0, 0, 1093, 1092,
		1, 0, 0, 0, 1094, 1097, 1, 0, 0, 0, 1095, 1093, 1, 0, 0, 0, 1095, 1096,
		1, 0, 0, 0, 1096, 1098, 1, 0, 0, 0, 1097, 1095, 1, 0, 0, 0, 1098, 1108,
		3, 188, 94, 0, 1099, 1104, 5, 1, 0, 0, 1100, 1104, 5, 52, 0, 0, 1101, 1102,
		5, 52, 0, 0, 1102, 1104, 5, 1, 0, 0, 1103, 1099, 1, 0, 0, 0, 1103, 1100,
		1, 0, 0, 0, 1103, 1101, 1, 0, 0, 0, 1104, 1105, 1, 0, 0, 0, 1105, 1107,
		3, 188, 94, 0, 1106, 1103, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106,
		1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1112, 1, 0, 0, 0, 1110, 1108,
		1, 0, 0, 0, 1111, 1113, 5, 52, 0, 0, 1112, 1111, 1, 0, 0, 0, 1112, 1113,
		1, 0, 0, 0, 1113, 1117, 1, 0, 0, 0, 1114, 1116, 5, 1, 0, 0, 1115, 1114,
		1, 0, 0, 0, 1116, 1119, 1, 0, 0, 0, 1117, 1115, 1, 0, 0, 0, 1117, 1118,
		1, 0, 0, 0, 1118, 187, 1, 0, 0, 0, 1119, 1117, 1, 0, 0, 0, 1120, 1123,
		3, 190, 95, 0, 1121, 1122, 5, 50, 0, 0, 1122, 1124, 3, 118, 59, 0, 1123,
		1121, 1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 189, 1, 0, 0, 0, 1125,
		1128, 5, 84, 0, 0, 1126, 1128, 3, 176, 88, 0, 1127, 1125, 1, 0, 0, 0, 1127,
		1126, 1, 0, 0, 0, 1128, 191, 1, 0, 0, 0, 1129, 1130, 5, 42, 0, 0, 1130,
		1131, 5, 50, 0, 0, 1131, 1138, 5, 43, 0, 0, 1132, 1134, 5, 42, 0, 0, 1133,
		1135, 3, 194, 97, 0, 1134, 1133, 1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135,
		1136, 1, 0, 0, 0, 1136, 1138, 5, 43, 0, 0, 1137, 1129, 1, 0, 0, 0, 1137,
		1132, 1, 0, 0, 0, 1138, 193, 1, 0, 0, 0, 1139, 1144, 3, 196, 98, 0, 1140,
		1141, 5, 52, 0, 0, 1141, 1143, 3, 196, 98, 0, 1142, 1140, 1, 0, 0, 0, 1143,
		1146, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145,
		1148, 1, 0, 0, 0, 1146, 1144, 1, 0, 0, 0, 1147, 1149, 5, 52, 0, 0, 1148,
		1147, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 195, 1, 0, 0, 0, 1150,
		1151, 3, 118, 59, 0, 1151, 1152, 5, 50, 0, 0, 1152, 1153, 3, 118, 59, 0,
		1153, 197, 1, 0, 0, 0, 1154, 1166, 5, 46, 0, 0, 1155, 1160, 3, 118, 59,
		0, 1156, 1157, 5, 52, 0, 0, 1157, 1159, 3, 118, 59, 0, 1158, 1156, 1, 0,
		0, 0, 1159, 1162, 1, 0, 0, 0, 1160, 1158, 1, 0, 0, 0, 1160, 1161, 1, 0,
		0, 0, 1161, 1164, 1, 0, 0, 0, 1162, 1160, 1, 0, 0, 0, 1163, 1165, 5, 52,
		0, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165, 1, 0, 0, 0, 1165, 1167, 1, 0,
		0, 0, 1166, 1155, 1, 0, 0, 0, 1166, 1167, 1, 0, 0, 0, 1167, 1168, 1, 0,
		0, 0, 1168, 1169, 5, 47, 0, 0, 1169, 199, 1, 0, 0, 0, 1170, 1173, 5, 84,
		0, 0, 1171, 1174, 3, 164, 82, 0, 1172, 1174, 3, 168, 84, 0, 1173, 1171,
		1, 0, 0, 0, 1173, 1172, 1, 0, 0, 0, 1174, 201, 1, 0, 0, 0, 1175, 1176,
		5, 84, 0, 0, 1176, 1178, 5, 40, 0, 0, 1177, 1179, 3, 186, 93, 0, 1178,
		1177, 1, 0, 0, 0, 1178, 1179, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180,
		1181, 5, 41, 0, 0, 1181, 203, 1, 0, 0, 0, 1182, 1188, 5, 84, 0, 0, 1183,
		1188, 3, 208, 104, 0, 1184, 1188, 3, 206, 103, 0, 1185, 1188, 3, 210, 105,
		0, 1186, 1188, 5, 14, 0, 0, 1187, 1182, 1, 0, 0, 0, 1187, 1183, 1, 0, 0,
		0, 1187, 1184, 1, 0, 0, 0, 1187, 1185, 1, 0, 0, 0, 1187, 1186, 1, 0, 0,
		0, 1188, 205, 1, 0, 0, 0, 1189, 1191, 5, 44, 0, 0, 1190, 1192, 3, 52, 26,
		0, 1191, 1190, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 1, 0, 0,
		0, 1193, 1194, 5, 45, 0, 0, 1194, 207, 1, 0, 0, 0, 1195, 1196, 5, 84, 0,
		0, 1196, 1197, 5, 42, 0, 0, 1197, 1198, 5, 43, 0, 0, 1198, 209, 1, 0, 0,
		0, 1199, 1200, 5, 6, 0, 0, 1200, 1202, 5, 44, 0, 0, 1201, 1203, 3, 62,
		31, 0, 1202, 1201, 1, 0, 0, 0, 1202, 1203, 1, 0, 0, 0, 1203, 1204, 1, 0,
		0, 0, 1204, 1206, 5, 45, 0, 0, 1205, 1207, 3, 204, 102, 0, 1206, 1205,
		1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 211, 1, 0, 0, 0, 1208, 1209,
		5, 51, 0, 0, 1209, 213, 1, 0, 0, 0, 137, 217, 224, 230, 233, 238, 251,
		269, 273, 277, 292, 296, 301, 319, 325, 327, 331, 338, 345, 351, 357, 362,
		385, 389, 393, 399, 403, 409, 416, 423, 429, 435, 439, 444, 447, 455, 462,
		466, 470, 479, 483, 489, 495, 502, 507, 514, 518, 521, 530, 534, 537, 544,
		548, 554, 562, 569, 576, 582, 588, 614, 618, 624, 645, 649, 656, 665, 671,
		682, 686, 690, 700, 707, 713, 716, 721, 730, 737, 743, 746, 751, 772, 776,
		783, 796, 807, 817, 828, 839, 850, 861, 875, 886, 897, 903, 912, 917, 926,
		944, 952, 956, 966, 973, 979, 985, 989, 997, 1005, 1013, 1022, 1031, 1040,
		1050, 1061, 1067, 1074, 1078, 1082, 1088, 1095, 1103, 1108, 1112, 1117,
		1123, 1127, 1134, 1137, 1144, 1148, 1160, 1164, 1166, 1173, 1178, 1187,
		1191, 1202, 1206,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                           = antlr.TokenEOF
	ManuscriptNEWLINE                       = 1
	ManuscriptWS                            = 2
	ManuscriptCOMMENT                       = 3
	ManuscriptMULTI_LINE_COMMENT            = 4
	ManuscriptLET                           = 5
	ManuscriptFN                            = 6
	ManuscriptRETURN                        = 7
	ManuscriptYIELD                         = 8
	ManuscriptTYPE                          = 9
	ManuscriptINTERFACE                     = 10
	ManuscriptIMPORT                        = 11
	ManuscriptEXPORT                        = 12
	ManuscriptEXTERN                        = 13
	ManuscriptVOID                          = 14
	ManuscriptCHECK                         = 15
	ManuscriptTRY                           = 16
	ManuscriptCATCH                         = 17
	ManuscriptIN                            = 18
	ManuscriptAS                            = 19
	ManuscriptIS                            = 20
	ManuscriptEXTENDS                       = 21
	ManuscriptFROM                          = 22
	ManuscriptNULL                          = 23
	ManuscriptIF                            = 24
	ManuscriptELSE                          = 25
	ManuscriptFOR                           = 26
	ManuscriptWHILE                         = 27
	ManuscriptTRUE                          = 28
	ManuscriptFALSE                         = 29
	ManuscriptMATCH                         = 30
	ManuscriptCASE                          = 31
	ManuscriptASYNC                         = 32
	ManuscriptAWAIT                         = 33
	ManuscriptMETHODS                       = 34
	ManuscriptBREAK                         = 35
	ManuscriptCONTINUE                      = 36
	ManuscriptDEFAULT                       = 37
	ManuscriptDEFER                         = 38
	ManuscriptGO                            = 39
	ManuscriptLBRACE                        = 40
	ManuscriptRBRACE                        = 41
	ManuscriptLSQBR                         = 42
	ManuscriptRSQBR                         = 43
	ManuscriptLPAREN                        = 44
	ManuscriptRPAREN                        = 45
	ManuscriptLT                            = 46
	ManuscriptGT                            = 47
	ManuscriptLT_EQUALS                     = 48
	ManuscriptGT_EQUALS                     = 49
	ManuscriptCOLON                         = 50
	ManuscriptSEMICOLON                     = 51
	ManuscriptCOMMA                         = 52
	ManuscriptEQUALS                        = 53
	ManuscriptEQUALS_EQUALS                 = 54
	ManuscriptPLUS                          = 55
	ManuscriptMINUS                         = 56
	ManuscriptPLUS_PLUS                     = 57
	ManuscriptMINUS_MINUS                   = 58
	ManuscriptPIPE_PIPE                     = 59
	ManuscriptAMP_AMP                       = 60
	ManuscriptSTAR                          = 61
	ManuscriptSLASH                         = 62
	ManuscriptMOD                           = 63
	ManuscriptEXCLAMATION                   = 64
	ManuscriptQUESTION                      = 65
	ManuscriptDOT                           = 66
	ManuscriptNEQ                           = 67
	ManuscriptPLUS_EQUALS                   = 68
	ManuscriptMINUS_EQUALS                  = 69
	ManuscriptSTAR_EQUALS                   = 70
	ManuscriptSLASH_EQUALS                  = 71
	ManuscriptMOD_EQUALS                    = 72
	ManuscriptCARET_EQUALS                  = 73
	ManuscriptPIPE                          = 74
	ManuscriptAMP                           = 75
	ManuscriptCARET                         = 76
	ManuscriptLSHIFT                        = 77
	ManuscriptRSHIFT                        = 78
	ManuscriptHEX_LITERAL                   = 79
	ManuscriptBINARY_LITERAL                = 80
	ManuscriptOCTAL_LITERAL                 = 81
	ManuscriptFLOAT                         = 82
	ManuscriptINTEGER                       = 83
	ManuscriptID                            = 84
	ManuscriptSINGLE_QUOTE_START            = 85
	ManuscriptMULTI_QUOTE_START             = 86
	ManuscriptDOUBLE_QUOTE_START            = 87
	ManuscriptMULTI_DOUBLE_QUOTE_START      = 88
	ManuscriptSINGLE_STR_INTERP_START       = 89
	ManuscriptSINGLE_STR_CONTENT            = 90
	ManuscriptSINGLE_STR_END                = 91
	ManuscriptMULTI_STR_INTERP_START        = 92
	ManuscriptMULTI_STR_CONTENT             = 93
	ManuscriptMULTI_STR_END                 = 94
	ManuscriptDOUBLE_STR_INTERP_START       = 95
	ManuscriptDOUBLE_STR_CONTENT            = 96
	ManuscriptDOUBLE_STR_END                = 97
	ManuscriptMULTI_DOUBLE_STR_INTERP_START = 98
	ManuscriptMULTI_DOUBLE_STR_CONTENT      = 99
	ManuscriptMULTI_DOUBLE_STR_END          = 100
	ManuscriptINTERP_LBRACE                 = 101
	ManuscriptINTERP_RBRACE                 = 102
	ManuscriptINTERP_WS                     = 103
)

// Manuscript rules.
const (
	ManuscriptRULE_program                 = 0
	ManuscriptRULE_declaration             = 1
	ManuscriptRULE_importDecl              = 2
	ManuscriptRULE_exportDecl              = 3
	ManuscriptRULE_externDecl              = 4
	ManuscriptRULE_exportedItem            = 5
	ManuscriptRULE_moduleImport            = 6
	ManuscriptRULE_destructuredImport      = 7
	ManuscriptRULE_targetImport            = 8
	ManuscriptRULE_importItemList          = 9
	ManuscriptRULE_importItem              = 10
	ManuscriptRULE_letDecl                 = 11
	ManuscriptRULE_letSingle               = 12
	ManuscriptRULE_letBlock                = 13
	ManuscriptRULE_letBlockItemList        = 14
	ManuscriptRULE_letBlockItemSep         = 15
	ManuscriptRULE_letBlockItem            = 16
	ManuscriptRULE_letDestructuredObj      = 17
	ManuscriptRULE_letDestructuredArray    = 18
	ManuscriptRULE_typedIDList             = 19
	ManuscriptRULE_typedID                 = 20
	ManuscriptRULE_typeDecl                = 21
	ManuscriptRULE_typeDefBody             = 22
	ManuscriptRULE_typeAlias               = 23
	ManuscriptRULE_fieldList               = 24
	ManuscriptRULE_fieldDecl               = 25
	ManuscriptRULE_typeList                = 26
	ManuscriptRULE_interfaceDecl           = 27
	ManuscriptRULE_interfaceMethod         = 28
	ManuscriptRULE_fnDecl                  = 29
	ManuscriptRULE_fnSignature             = 30
	ManuscriptRULE_parameters              = 31
	ManuscriptRULE_param                   = 32
	ManuscriptRULE_methodsDecl             = 33
	ManuscriptRULE_methodImplList          = 34
	ManuscriptRULE_methodImpl              = 35
	ManuscriptRULE_stmt                    = 36
	ManuscriptRULE_returnStmt              = 37
	ManuscriptRULE_yieldStmt               = 38
	ManuscriptRULE_deferStmt               = 39
	ManuscriptRULE_asyncStmt               = 40
	ManuscriptRULE_goStmt                  = 41
	ManuscriptRULE_exprList                = 42
	ManuscriptRULE_ifStmt                  = 43
	ManuscriptRULE_forStmt                 = 44
	ManuscriptRULE_forLoopType             = 45
	ManuscriptRULE_forTrinity              = 46
	ManuscriptRULE_forInit                 = 47
	ManuscriptRULE_forCond                 = 48
	ManuscriptRULE_forPost                 = 49
	ManuscriptRULE_whileStmt               = 50
	ManuscriptRULE_loopBody                = 51
	ManuscriptRULE_codeBlock               = 52
	ManuscriptRULE_breakStmt               = 53
	ManuscriptRULE_continueStmt            = 54
	ManuscriptRULE_checkStmt               = 55
	ManuscriptRULE_pipedStmt               = 56
	ManuscriptRULE_pipedArgs               = 57
	ManuscriptRULE_pipedArg                = 58
	ManuscriptRULE_expr                    = 59
	ManuscriptRULE_assignmentExpr          = 60
	ManuscriptRULE_assignmentOp            = 61
	ManuscriptRULE_ternaryExpr             = 62
	ManuscriptRULE_logicalOrExpr           = 63
	ManuscriptRULE_logicalAndExpr          = 64
	ManuscriptRULE_bitwiseXorExpr          = 65
	ManuscriptRULE_bitwiseAndExpr          = 66
	ManuscriptRULE_equalityExpr            = 67
	ManuscriptRULE_comparisonOp            = 68
	ManuscriptRULE_comparisonExpr          = 69
	ManuscriptRULE_additiveExpr            = 70
	ManuscriptRULE_multiplicativeExpr      = 71
	ManuscriptRULE_unaryExpr               = 72
	ManuscriptRULE_postfixExpr             = 73
	ManuscriptRULE_postfixOp               = 74
	ManuscriptRULE_primaryExpr             = 75
	ManuscriptRULE_tryExpr                 = 76
	ManuscriptRULE_fnExpr                  = 77
	ManuscriptRULE_matchExpr               = 78
	ManuscriptRULE_caseClause              = 79
	ManuscriptRULE_defaultClause           = 80
	ManuscriptRULE_singleQuotedString      = 81
	ManuscriptRULE_multiQuotedString       = 82
	ManuscriptRULE_doubleQuotedString      = 83
	ManuscriptRULE_multiDoubleQuotedString = 84
	ManuscriptRULE_stringPart              = 85
	ManuscriptRULE_interpolation           = 86
	ManuscriptRULE_literal                 = 87
	ManuscriptRULE_stringLiteral           = 88
	ManuscriptRULE_numberLiteral           = 89
	ManuscriptRULE_booleanLiteral          = 90
	ManuscriptRULE_arrayLiteral            = 91
	ManuscriptRULE_objectLiteral           = 92
	ManuscriptRULE_objectFieldList         = 93
	ManuscriptRULE_objectField             = 94
	ManuscriptRULE_objectFieldName         = 95
	ManuscriptRULE_mapLiteral              = 96
	ManuscriptRULE_mapFieldList            = 97
	ManuscriptRULE_mapField                = 98
	ManuscriptRULE_setLiteral              = 99
	ManuscriptRULE_taggedBlockString       = 100
	ManuscriptRULE_typedObjectLiteral      = 101
	ManuscriptRULE_typeAnnotation          = 102
	ManuscriptRULE_tupleType               = 103
	ManuscriptRULE_arrayType               = 104
	ManuscriptRULE_fnType                  = 105
	ManuscriptRULE_stmt_sep                = 106
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *ProgramContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(214)
				p.Stmt_sep()
			}

		}
		p.SetState(219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179885152) != 0 {
		{
			p.SetState(220)
			p.Declaration()
		}
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(222)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptSEMICOLON {
					{
						p.SetState(221)
						p.Stmt_sep()
					}

					p.SetState(224)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(226)
					p.Declaration()
				}

			}
			p.SetState(232)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(235)
			p.Stmt_sep()
		}

		p.SetState(240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(241)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportDecl() IImportDeclContext
	ExportDecl() IExportDeclContext
	ExternDecl() IExternDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext
	FnDecl() IFnDeclContext
	MethodsDecl() IMethodsDeclContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ImportDecl() IImportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *DeclarationContext) ExportDecl() IExportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportDeclContext)
}

func (s *DeclarationContext) ExternDecl() IExternDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternDeclContext)
}

func (s *DeclarationContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *DeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclarationContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *DeclarationContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *DeclarationContext) MethodsDecl() IMethodsDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodsDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodsDeclContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_declaration)
	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(243)
			p.ImportDecl()
		}

	case ManuscriptEXPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(244)
			p.ExportDecl()
		}

	case ManuscriptEXTERN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(245)
			p.ExternDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(246)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(247)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(248)
			p.InterfaceDecl()
		}

	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(249)
			p.FnDecl()
		}

	case ManuscriptMETHODS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(250)
			p.MethodsDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ImportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(253)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(254)
		p.ModuleImport()
	}
	{
		p.SetState(255)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportDeclContext is an interface to support dynamic dispatch.
type IExportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	ExportedItem() IExportedItemContext
	SEMICOLON() antlr.TerminalNode

	// IsExportDeclContext differentiates from other interfaces.
	IsExportDeclContext()
}

type ExportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportDeclContext() *ExportDeclContext {
	var p = new(ExportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
	return p
}

func InitEmptyExportDeclContext(p *ExportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
}

func (*ExportDeclContext) IsExportDeclContext() {}

func NewExportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportDeclContext {
	var p = new(ExportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportDecl

	return p
}

func (s *ExportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportDeclContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportDeclContext) ExportedItem() IExportedItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedItemContext)
}

func (s *ExportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportDecl(s)
	}
}

func (s *ExportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportDecl(s)
	}
}

func (s *ExportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportDecl() (localctx IExportDeclContext) {
	localctx = NewExportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_exportDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)
		p.ExportedItem()
	}
	{
		p.SetState(259)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternDeclContext is an interface to support dynamic dispatch.
type IExternDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsExternDeclContext differentiates from other interfaces.
	IsExternDeclContext()
}

type ExternDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternDeclContext() *ExternDeclContext {
	var p = new(ExternDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
	return p
}

func InitEmptyExternDeclContext(p *ExternDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
}

func (*ExternDeclContext) IsExternDeclContext() {}

func NewExternDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternDeclContext {
	var p = new(ExternDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externDecl

	return p
}

func (s *ExternDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternDeclContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ExternDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExternDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternDecl(s)
	}
}

func (s *ExternDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternDecl(s)
	}
}

func (s *ExternDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternDecl() (localctx IExternDeclContext) {
	localctx = NewExternDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_externDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(262)
		p.ModuleImport()
	}
	{
		p.SetState(263)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportedItemContext is an interface to support dynamic dispatch.
type IExportedItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnDecl() IFnDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext

	// IsExportedItemContext differentiates from other interfaces.
	IsExportedItemContext()
}

type ExportedItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportedItemContext() *ExportedItemContext {
	var p = new(ExportedItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
	return p
}

func InitEmptyExportedItemContext(p *ExportedItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
}

func (*ExportedItemContext) IsExportedItemContext() {}

func NewExportedItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportedItemContext {
	var p = new(ExportedItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportedItem

	return p
}

func (s *ExportedItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportedItemContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportedItemContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportedItemContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportedItemContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ExportedItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportedItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedItem(s)
	}
}

func (s *ExportedItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedItem(s)
	}
}

func (s *ExportedItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportedItem() (localctx IExportedItemContext) {
	localctx = NewExportedItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_exportedItem)
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(265)
			p.FnDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(266)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(267)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(268)
			p.InterfaceDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleImportContext is an interface to support dynamic dispatch.
type IModuleImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DestructuredImport() IDestructuredImportContext
	TargetImport() ITargetImportContext

	// IsModuleImportContext differentiates from other interfaces.
	IsModuleImportContext()
}

type ModuleImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleImportContext() *ModuleImportContext {
	var p = new(ModuleImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
	return p
}

func InitEmptyModuleImportContext(p *ModuleImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
}

func (*ModuleImportContext) IsModuleImportContext() {}

func NewModuleImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleImportContext {
	var p = new(ModuleImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_moduleImport

	return p
}

func (s *ModuleImportContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleImportContext) DestructuredImport() IDestructuredImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestructuredImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestructuredImportContext)
}

func (s *ModuleImportContext) TargetImport() ITargetImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetImportContext)
}

func (s *ModuleImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterModuleImport(s)
	}
}

func (s *ModuleImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitModuleImport(s)
	}
}

func (s *ModuleImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitModuleImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ModuleImport() (localctx IModuleImportContext) {
	localctx = NewModuleImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_moduleImport)
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(271)
			p.DestructuredImport()
		}

	case ManuscriptID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(272)
			p.TargetImport()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestructuredImportContext is an interface to support dynamic dispatch.
type IDestructuredImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext
	ImportItemList() IImportItemListContext

	// IsDestructuredImportContext differentiates from other interfaces.
	IsDestructuredImportContext()
}

type DestructuredImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestructuredImportContext() *DestructuredImportContext {
	var p = new(DestructuredImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
	return p
}

func InitEmptyDestructuredImportContext(p *DestructuredImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
}

func (*DestructuredImportContext) IsDestructuredImportContext() {}

func NewDestructuredImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestructuredImportContext {
	var p = new(DestructuredImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_destructuredImport

	return p
}

func (s *DestructuredImportContext) GetParser() antlr.Parser { return s.parser }

func (s *DestructuredImportContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *DestructuredImportContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *DestructuredImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *DestructuredImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *DestructuredImportContext) ImportItemList() IImportItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemListContext)
}

func (s *DestructuredImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestructuredImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestructuredImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDestructuredImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DestructuredImport() (localctx IDestructuredImportContext) {
	localctx = NewDestructuredImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_destructuredImport)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(276)
			p.ImportItemList()
		}

	}
	{
		p.SetState(279)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(280)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetImportContext is an interface to support dynamic dispatch.
type ITargetImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext

	// IsTargetImportContext differentiates from other interfaces.
	IsTargetImportContext()
}

type TargetImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetImportContext() *TargetImportContext {
	var p = new(TargetImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
	return p
}

func InitEmptyTargetImportContext(p *TargetImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
}

func (*TargetImportContext) IsTargetImportContext() {}

func NewTargetImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetImportContext {
	var p = new(TargetImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_targetImport

	return p
}

func (s *TargetImportContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetImportContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TargetImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *TargetImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *TargetImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTargetImport(s)
	}
}

func (s *TargetImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTargetImport(s)
	}
}

func (s *TargetImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTargetImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TargetImport() (localctx ITargetImportContext) {
	localctx = NewTargetImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_targetImport)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(284)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(285)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemListContext is an interface to support dynamic dispatch.
type IImportItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportItem() []IImportItemContext
	ImportItem(i int) IImportItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportItemListContext differentiates from other interfaces.
	IsImportItemListContext()
}

type ImportItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemListContext() *ImportItemListContext {
	var p = new(ImportItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
	return p
}

func InitEmptyImportItemListContext(p *ImportItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
}

func (*ImportItemListContext) IsImportItemListContext() {}

func NewImportItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemListContext {
	var p = new(ImportItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItemList

	return p
}

func (s *ImportItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemListContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *ImportItemListContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *ImportItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ImportItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ImportItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItemList(s)
	}
}

func (s *ImportItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItemList(s)
	}
}

func (s *ImportItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItemList() (localctx IImportItemListContext) {
	localctx = NewImportItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_importItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.ImportItem()
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(288)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(289)
				p.ImportItem()
			}

		}
		p.SetState(294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(295)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(298)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(299)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(300)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	LetSingle() ILetSingleContext
	SEMICOLON() antlr.TerminalNode
	LetBlock() ILetBlockContext
	LetDestructuredObj() ILetDestructuredObjContext
	LetDestructuredArray() ILetDestructuredArrayContext

	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LetDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclContext) LetBlock() ILetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockContext)
}

func (s *LetDeclContext) LetDestructuredObj() ILetDestructuredObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredObjContext)
}

func (s *LetDeclContext) LetDestructuredArray() ILetDestructuredArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredArrayContext)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDecl(s)
	}
}

func (s *LetDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDecl(s)
	}
}

func (s *LetDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_letDecl)
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(303)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(304)
			p.LetSingle()
		}
		{
			p.SetState(305)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(307)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)
			p.LetBlock()
		}
		{
			p.SetState(309)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(311)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(312)
			p.LetDestructuredObj()
		}
		{
			p.SetState(313)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(315)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(316)
			p.LetDestructuredArray()
		}
		{
			p.SetState(317)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetSingleContext is an interface to support dynamic dispatch.
type ILetSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedID() ITypedIDContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext
	TryExpr() ITryExprContext

	// IsLetSingleContext differentiates from other interfaces.
	IsLetSingleContext()
}

type LetSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetSingleContext() *LetSingleContext {
	var p = new(LetSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
	return p
}

func InitEmptyLetSingleContext(p *LetSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
}

func (*LetSingleContext) IsLetSingleContext() {}

func NewLetSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetSingleContext {
	var p = new(LetSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letSingle

	return p
}

func (s *LetSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LetSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetSingleContext) TryExpr() ITryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExprContext)
}

func (s *LetSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetSingle(s)
	}
}

func (s *LetSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetSingle(s)
	}
}

func (s *LetSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetSingle() (localctx ILetSingleContext) {
	localctx = NewLetSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_letSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.TypedID()
	}
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(322)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(325)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
			{
				p.SetState(323)
				p.Expr()
			}

		case ManuscriptTRY:
			{
				p.SetState(324)
				p.TryExpr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockContext is an interface to support dynamic dispatch.
type ILetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LetBlockItemList() ILetBlockItemListContext

	// IsLetBlockContext differentiates from other interfaces.
	IsLetBlockContext()
}

type LetBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockContext() *LetBlockContext {
	var p = new(LetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
	return p
}

func InitEmptyLetBlockContext(p *LetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
}

func (*LetBlockContext) IsLetBlockContext() {}

func NewLetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockContext {
	var p = new(LetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlock

	return p
}

func (s *LetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LetBlockContext) LetBlockItemList() ILetBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemListContext)
}

func (s *LetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlock(s)
	}
}

func (s *LetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlock(s)
	}
}

func (s *LetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlock() (localctx ILetBlockContext) {
	localctx = NewLetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_letBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(329)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&8589934595) != 0 {
		{
			p.SetState(330)
			p.LetBlockItemList()
		}

	}
	{
		p.SetState(333)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemListContext is an interface to support dynamic dispatch.
type ILetBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetBlockItem() []ILetBlockItemContext
	LetBlockItem(i int) ILetBlockItemContext
	AllLetBlockItemSep() []ILetBlockItemSepContext
	LetBlockItemSep(i int) ILetBlockItemSepContext

	// IsLetBlockItemListContext differentiates from other interfaces.
	IsLetBlockItemListContext()
}

type LetBlockItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemListContext() *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
	return p
}

func InitEmptyLetBlockItemListContext(p *LetBlockItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
}

func (*LetBlockItemListContext) IsLetBlockItemListContext() {}

func NewLetBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemList

	return p
}

func (s *LetBlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemListContext) AllLetBlockItem() []ILetBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemContext); ok {
			tst[i] = t.(ILetBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItem(i int) ILetBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemContext)
}

func (s *LetBlockItemListContext) AllLetBlockItemSep() []ILetBlockItemSepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemSepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemSepContext); ok {
			tst[i] = t.(ILetBlockItemSepContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItemSep(i int) ILetBlockItemSepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemSepContext)
}

func (s *LetBlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemList() (localctx ILetBlockItemListContext) {
	localctx = NewLetBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_letBlockItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON || _la == ManuscriptCOMMA {
		{
			p.SetState(335)
			p.LetBlockItemSep()
		}

		p.SetState(340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(341)
		p.LetBlockItem()
	}
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptSEMICOLON || _la == ManuscriptCOMMA {
				{
					p.SetState(342)
					p.LetBlockItemSep()
				}

				p.SetState(345)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(347)
				p.LetBlockItem()
			}

		}
		p.SetState(353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON || _la == ManuscriptCOMMA {
		{
			p.SetState(354)
			p.LetBlockItemSep()
		}

		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemSepContext is an interface to support dynamic dispatch.
type ILetBlockItemSepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	Stmt_sep() IStmt_sepContext

	// IsLetBlockItemSepContext differentiates from other interfaces.
	IsLetBlockItemSepContext()
}

type LetBlockItemSepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemSepContext() *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
	return p
}

func InitEmptyLetBlockItemSepContext(p *LetBlockItemSepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
}

func (*LetBlockItemSepContext) IsLetBlockItemSepContext() {}

func NewLetBlockItemSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemSep

	return p
}

func (s *LetBlockItemSepContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemSepContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LetBlockItemSepContext) Stmt_sep() IStmt_sepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LetBlockItemSepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemSepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemSep() (localctx ILetBlockItemSepContext) {
	localctx = NewLetBlockItemSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_letBlockItemSep)
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(360)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(361)
			p.Stmt_sep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemContext is an interface to support dynamic dispatch.
type ILetBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetBlockItemContext differentiates from other interfaces.
	IsLetBlockItemContext()
}

type LetBlockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemContext() *LetBlockItemContext {
	var p = new(LetBlockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
	return p
}

func InitEmptyLetBlockItemContext(p *LetBlockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
}

func (*LetBlockItemContext) IsLetBlockItemContext() {}

func NewLetBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemContext {
	var p = new(LetBlockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItem

	return p
}

func (s *LetBlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemContext) CopyAll(ctx *LetBlockItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetBlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLetBlockItemSingleContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemSingleContext {
	var p = new(LabelLetBlockItemSingleContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LabelLetBlockItemSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItem() (localctx ILetBlockItemContext) {
	localctx = NewLetBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_letBlockItem)
	localctx = NewLabelLetBlockItemSingleContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.TypedID()
	}
	{
		p.SetState(365)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(366)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredObjContext is an interface to support dynamic dispatch.
type ILetDestructuredObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RBRACE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredObjContext differentiates from other interfaces.
	IsLetDestructuredObjContext()
}

type LetDestructuredObjContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredObjContext() *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
	return p
}

func InitEmptyLetDestructuredObjContext(p *LetDestructuredObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
}

func (*LetDestructuredObjContext) IsLetDestructuredObjContext() {}

func NewLetDestructuredObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredObj

	return p
}

func (s *LetDestructuredObjContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredObj() (localctx ILetDestructuredObjContext) {
	localctx = NewLetDestructuredObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_letDestructuredObj)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(369)
		p.TypedIDList()
	}
	{
		p.SetState(370)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(371)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredArrayContext is an interface to support dynamic dispatch.
type ILetDestructuredArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RSQBR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredArrayContext differentiates from other interfaces.
	IsLetDestructuredArrayContext()
}

type LetDestructuredArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredArrayContext() *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
	return p
}

func InitEmptyLetDestructuredArrayContext(p *LetDestructuredArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
}

func (*LetDestructuredArrayContext) IsLetDestructuredArrayContext() {}

func NewLetDestructuredArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredArray

	return p
}

func (s *LetDestructuredArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredArray() (localctx ILetDestructuredArrayContext) {
	localctx = NewLetDestructuredArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_letDestructuredArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.TypedIDList()
	}
	{
		p.SetState(376)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(377)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(378)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDListContext is an interface to support dynamic dispatch.
type ITypedIDListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedID() []ITypedIDContext
	TypedID(i int) ITypedIDContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedIDListContext differentiates from other interfaces.
	IsTypedIDListContext()
}

type TypedIDListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDListContext() *TypedIDListContext {
	var p = new(TypedIDListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
	return p
}

func InitEmptyTypedIDListContext(p *TypedIDListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
}

func (*TypedIDListContext) IsTypedIDListContext() {}

func NewTypedIDListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDListContext {
	var p = new(TypedIDListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedIDList

	return p
}

func (s *TypedIDListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDListContext) AllTypedID() []ITypedIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIDContext); ok {
			len++
		}
	}

	tst := make([]ITypedIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIDContext); ok {
			tst[i] = t.(ITypedIDContext)
			i++
		}
	}

	return tst
}

func (s *TypedIDListContext) TypedID(i int) ITypedIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *TypedIDListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypedIDListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypedIDListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedIDList(s)
	}
}

func (s *TypedIDListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedIDList(s)
	}
}

func (s *TypedIDListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedIDList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedIDList() (localctx ITypedIDListContext) {
	localctx = NewTypedIDListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_typedIDList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.TypedID()
	}
	p.SetState(385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(381)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(382)
				p.TypedID()
			}

		}
		p.SetState(387)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(388)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDContext is an interface to support dynamic dispatch.
type ITypedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsTypedIDContext differentiates from other interfaces.
	IsTypedIDContext()
}

type TypedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDContext() *TypedIDContext {
	var p = new(TypedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
	return p
}

func InitEmptyTypedIDContext(p *TypedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
}

func (*TypedIDContext) IsTypedIDContext() {}

func NewTypedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDContext {
	var p = new(TypedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedID

	return p
}

func (s *TypedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypedIDContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedID(s)
	}
}

func (s *TypedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedID(s)
	}
}

func (s *TypedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedID() (localctx ITypedIDContext) {
	localctx = NewTypedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_typedID)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(392)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	ID() antlr.TerminalNode
	TypeDefBody() ITypeDefBodyContext
	TypeAlias() ITypeAliasContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeDeclContext) TypeDefBody() ITypeDefBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefBodyContext)
}

func (s *TypeDeclContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_typeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(395)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(396)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEXTENDS, ManuscriptLBRACE:
		{
			p.SetState(397)
			p.TypeDefBody()
		}

	case ManuscriptEQUALS:
		{
			p.SetState(398)
			p.TypeAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefBodyContext is an interface to support dynamic dispatch.
type ITypeDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDefBodyContext differentiates from other interfaces.
	IsTypeDefBodyContext()
}

type TypeDefBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefBodyContext() *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
	return p
}

func InitEmptyTypeDefBodyContext(p *TypeDefBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
}

func (*TypeDefBodyContext) IsTypeDefBodyContext() {}

func NewTypeDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDefBody

	return p
}

func (s *TypeDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDefBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDefBodyContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDefBodyContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeDefBodyContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDefBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *TypeDefBodyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDefBodyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDefBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDefBody() (localctx ITypeDefBodyContext) {
	localctx = NewTypeDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_typeDefBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(401)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(402)
			p.TypeList()
		}

	}
	{
		p.SetState(405)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptSEMICOLON {
			{
				p.SetState(406)
				p.Stmt_sep()
			}

			p.SetState(411)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(412)
			p.FieldDecl()
		}
		p.SetState(429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(416)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptSEMICOLON {
					{
						p.SetState(413)
						p.Stmt_sep()
					}

					p.SetState(418)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(419)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(423)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptSEMICOLON {
					{
						p.SetState(420)
						p.Stmt_sep()
					}

					p.SetState(425)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(426)
					p.FieldDecl()
				}

			}
			p.SetState(431)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(439)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			p.SetState(435)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptSEMICOLON {
				{
					p.SetState(432)
					p.Stmt_sep()
				}

				p.SetState(437)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(438)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptSEMICOLON {
			{
				p.SetState(441)
				p.Stmt_sep()
			}

			p.SetState(446)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(449)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *TypeAliasContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAliasContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeAliasContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)
		p.TypeAnnotation()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(453)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.TypeList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.FieldDecl()
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(458)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(459)
				p.FieldDecl()
			}

		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(465)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(468)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(469)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(472)
		p.TypeAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(474)
		p.TypeAnnotation()
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(475)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(476)
				p.TypeAnnotation()
			}

		}
		p.SetState(481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(482)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *InterfaceDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *InterfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *InterfaceDeclContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceDeclContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_interfaceDecl)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(485)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(486)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(487)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(488)
			p.TypeList()
		}

	}
	{
		p.SetState(491)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptSEMICOLON {
			{
				p.SetState(492)
				p.Stmt_sep()
			}

			p.SetState(497)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(498)
			p.InterfaceMethod()
		}
		p.SetState(502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(499)
					p.Stmt_sep()
				}

			}
			p.SetState(504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(509)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *InterfaceMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *InterfaceMethodContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *InterfaceMethodContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *InterfaceMethodContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(512)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(513)
			p.Parameters()
		}

	}
	{
		p.SetState(516)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(517)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(520)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnSignature() IFnSignatureContext
	CodeBlock() ICodeBlockContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_fnDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(523)
		p.FnSignature()
	}
	{
		p.SetState(524)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnSignatureContext is an interface to support dynamic dispatch.
type IFnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsFnSignatureContext differentiates from other interfaces.
	IsFnSignatureContext()
}

type FnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnSignatureContext() *FnSignatureContext {
	var p = new(FnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
	return p
}

func InitEmptyFnSignatureContext(p *FnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
}

func (*FnSignatureContext) IsFnSignatureContext() {}

func NewFnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnSignatureContext {
	var p = new(FnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnSignature

	return p
}

func (s *FnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FnSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnSignatureContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FnSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnSignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnSignatureContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnSignature(s)
	}
}

func (s *FnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnSignature(s)
	}
}

func (s *FnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnSignature() (localctx IFnSignatureContext) {
	localctx = NewFnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_fnSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(526)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(527)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(529)
			p.Parameters()
		}

	}
	{
		p.SetState(532)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(533)
			p.TypeAnnotation()
		}

	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(536)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Param()
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(540)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(541)
				p.Param()
			}

		}
		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(547)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(551)
		p.TypeAnnotation()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(552)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodsDeclContext is an interface to support dynamic dispatch.
type IMethodsDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	METHODS() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MethodImplList() IMethodImplListContext

	// IsMethodsDeclContext differentiates from other interfaces.
	IsMethodsDeclContext()
}

type MethodsDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodsDeclContext() *MethodsDeclContext {
	var p = new(MethodsDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
	return p
}

func InitEmptyMethodsDeclContext(p *MethodsDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
}

func (*MethodsDeclContext) IsMethodsDeclContext() {}

func NewMethodsDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodsDeclContext {
	var p = new(MethodsDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodsDecl

	return p
}

func (s *MethodsDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodsDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodsDeclContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *MethodsDeclContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *MethodsDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *MethodsDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodsDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodsDeclContext) MethodImplList() IMethodImplListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplListContext)
}

func (s *MethodsDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodsDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodsDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodsDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodsDecl() (localctx IMethodsDeclContext) {
	localctx = NewMethodsDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_methodsDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(557)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(558)
		p.Match(ManuscriptAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(559)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		{
			p.SetState(561)
			p.MethodImplList()
		}

	}
	{
		p.SetState(564)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplListContext is an interface to support dynamic dispatch.
type IMethodImplListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsMethodImplListContext differentiates from other interfaces.
	IsMethodImplListContext()
}

type MethodImplListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplListContext() *MethodImplListContext {
	var p = new(MethodImplListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
	return p
}

func InitEmptyMethodImplListContext(p *MethodImplListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
}

func (*MethodImplListContext) IsMethodImplListContext() {}

func NewMethodImplListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplListContext {
	var p = new(MethodImplListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImplList

	return p
}

func (s *MethodImplListContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplListContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodImplListContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MethodImplListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImplList(s)
	}
}

func (s *MethodImplListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImplList(s)
	}
}

func (s *MethodImplListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImplList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImplList() (localctx IMethodImplListContext) {
	localctx = NewMethodImplListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_methodImplList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(566)
			p.Stmt_sep()
		}

		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(572)
		p.MethodImpl()
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptSEMICOLON {
				{
					p.SetState(573)
					p.Stmt_sep()
				}

				p.SetState(576)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(578)
				p.MethodImpl()
			}

		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(585)
			p.Stmt_sep()
		}

		p.SetState(590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceMethod() IInterfaceMethodContext
	CodeBlock() ICodeBlockContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) InterfaceMethod() IInterfaceMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_methodImpl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.InterfaceMethod()
	}
	{
		p.SetState(592)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyAll(ctx *StmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelStmtIfContext struct {
	StmtContext
}

func NewLabelStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtIfContext {
	var p = new(LabelStmtIfContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtIfContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *LabelStmtIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtDeferContext struct {
	StmtContext
}

func NewLabelStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtDeferContext {
	var p = new(LabelStmtDeferContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtDeferContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *LabelStmtDeferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtExprContext struct {
	StmtContext
}

func NewLabelStmtExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtExprContext {
	var p = new(LabelStmtExprContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelStmtExprContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelStmtExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtForContext struct {
	StmtContext
}

func NewLabelStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtForContext {
	var p = new(LabelStmtForContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtForContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *LabelStmtForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtPipedContext struct {
	StmtContext
}

func NewLabelStmtPipedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtPipedContext {
	var p = new(LabelStmtPipedContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtPipedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtPipedContext) PipedStmt() IPipedStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedStmtContext)
}

func (s *LabelStmtPipedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtPiped(s)
	}
}

func (s *LabelStmtPipedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtPiped(s)
	}
}

func (s *LabelStmtPipedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtPiped(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtContinueContext struct {
	StmtContext
}

func NewLabelStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtContinueContext {
	var p = new(LabelStmtContinueContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtContinueContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *LabelStmtContinueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBlockContext struct {
	StmtContext
}

func NewLabelStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBlockContext {
	var p = new(LabelStmtBlockContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LabelStmtBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtCheckContext struct {
	StmtContext
}

func NewLabelStmtCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtCheckContext {
	var p = new(LabelStmtCheckContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtCheckContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *LabelStmtCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtYieldContext struct {
	StmtContext
}

func NewLabelStmtYieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtYieldContext {
	var p = new(LabelStmtYieldContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtYieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtYieldContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *LabelStmtYieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtYield(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtAsyncContext struct {
	StmtContext
}

func NewLabelStmtAsyncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtAsyncContext {
	var p = new(LabelStmtAsyncContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtAsyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtAsyncContext) AsyncStmt() IAsyncStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsyncStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsyncStmtContext)
}

func (s *LabelStmtAsyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtAsync(s)
	}
}

func (s *LabelStmtAsyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtAsync(s)
	}
}

func (s *LabelStmtAsyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtAsync(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtLetContext struct {
	StmtContext
}

func NewLabelStmtLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtLetContext {
	var p = new(LabelStmtLetContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *LabelStmtLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtTryContext struct {
	StmtContext
}

func NewLabelStmtTryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtTryContext {
	var p = new(LabelStmtTryContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtTryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtTryContext) TryExpr() ITryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExprContext)
}

func (s *LabelStmtTryContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelStmtTryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtTry(s)
	}
}

func (s *LabelStmtTryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtTry(s)
	}
}

func (s *LabelStmtTryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtTry(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtReturnContext struct {
	StmtContext
}

func NewLabelStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtReturnContext {
	var p = new(LabelStmtReturnContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtReturnContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *LabelStmtReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtWhileContext struct {
	StmtContext
}

func NewLabelStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtWhileContext {
	var p = new(LabelStmtWhileContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtWhileContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *LabelStmtWhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBreakContext struct {
	StmtContext
}

func NewLabelStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBreakContext {
	var p = new(LabelStmtBreakContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBreakContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *LabelStmtBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtGoContext struct {
	StmtContext
}

func NewLabelStmtGoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtGoContext {
	var p = new(LabelStmtGoContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtGoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtGoContext) GoStmt() IGoStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoStmtContext)
}

func (s *LabelStmtGoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtGo(s)
	}
}

func (s *LabelStmtGoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtGo(s)
	}
}

func (s *LabelStmtGoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtGo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_stmt)
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelStmtLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(594)
			p.LetDecl()
		}

	case 2:
		localctx = NewLabelStmtExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(595)
			p.Expr()
		}
		{
			p.SetState(596)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLabelStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(598)
			p.ReturnStmt()
		}

	case 4:
		localctx = NewLabelStmtYieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(599)
			p.YieldStmt()
		}

	case 5:
		localctx = NewLabelStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(600)
			p.IfStmt()
		}

	case 6:
		localctx = NewLabelStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(601)
			p.ForStmt()
		}

	case 7:
		localctx = NewLabelStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(602)
			p.WhileStmt()
		}

	case 8:
		localctx = NewLabelStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(603)
			p.CodeBlock()
		}

	case 9:
		localctx = NewLabelStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(604)
			p.BreakStmt()
		}

	case 10:
		localctx = NewLabelStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(605)
			p.ContinueStmt()
		}

	case 11:
		localctx = NewLabelStmtCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(606)
			p.CheckStmt()
		}

	case 12:
		localctx = NewLabelStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(607)
			p.DeferStmt()
		}

	case 13:
		localctx = NewLabelStmtTryContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(608)
			p.TryExpr()
		}
		{
			p.SetState(609)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewLabelStmtPipedContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(611)
			p.PipedStmt()
		}

	case 15:
		localctx = NewLabelStmtAsyncContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(612)
			p.AsyncStmt()
		}

	case 16:
		localctx = NewLabelStmtGoContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(613)
			p.GoStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	ExprList() IExprListContext

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ReturnStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_returnStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(617)
			p.ExprList()
		}

	}
	{
		p.SetState(620)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	ExprList() IExprListContext

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *YieldStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_yieldStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(622)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(623)
			p.ExprList()
		}

	}
	{
		p.SetState(626)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFER, 0)
}

func (s *DeferStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeferStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		p.Match(ManuscriptDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(629)
		p.Expr()
	}
	{
		p.SetState(630)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsyncStmtContext is an interface to support dynamic dispatch.
type IAsyncStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASYNC() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsAsyncStmtContext differentiates from other interfaces.
	IsAsyncStmtContext()
}

type AsyncStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsyncStmtContext() *AsyncStmtContext {
	var p = new(AsyncStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_asyncStmt
	return p
}

func InitEmptyAsyncStmtContext(p *AsyncStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_asyncStmt
}

func (*AsyncStmtContext) IsAsyncStmtContext() {}

func NewAsyncStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsyncStmtContext {
	var p = new(AsyncStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_asyncStmt

	return p
}

func (s *AsyncStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *AsyncStmtContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ManuscriptASYNC, 0)
}

func (s *AsyncStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AsyncStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *AsyncStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsyncStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsyncStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAsyncStmt(s)
	}
}

func (s *AsyncStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAsyncStmt(s)
	}
}

func (s *AsyncStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAsyncStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AsyncStmt() (localctx IAsyncStmtContext) {
	localctx = NewAsyncStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_asyncStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(ManuscriptASYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(633)
		p.Expr()
	}
	{
		p.SetState(634)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGoStmtContext is an interface to support dynamic dispatch.
type IGoStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GO() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsGoStmtContext differentiates from other interfaces.
	IsGoStmtContext()
}

type GoStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoStmtContext() *GoStmtContext {
	var p = new(GoStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_goStmt
	return p
}

func InitEmptyGoStmtContext(p *GoStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_goStmt
}

func (*GoStmtContext) IsGoStmtContext() {}

func NewGoStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoStmtContext {
	var p = new(GoStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_goStmt

	return p
}

func (s *GoStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *GoStmtContext) GO() antlr.TerminalNode {
	return s.GetToken(ManuscriptGO, 0)
}

func (s *GoStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GoStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *GoStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterGoStmt(s)
	}
}

func (s *GoStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitGoStmt(s)
	}
}

func (s *GoStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitGoStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) GoStmt() (localctx IGoStmtContext) {
	localctx = NewGoStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_goStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(636)
		p.Match(ManuscriptGO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(637)
		p.Expr()
	}
	{
		p.SetState(638)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Expr()
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(641)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(642)
				p.Expr()
			}

		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(648)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Expr()
	}
	{
		p.SetState(653)
		p.CodeBlock()
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(654)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(655)
			p.CodeBlock()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	ForLoopType() IForLoopTypeContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) ForLoopType() IForLoopTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForLoopTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForLoopTypeContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(659)
		p.ForLoopType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForLoopTypeContext is an interface to support dynamic dispatch.
type IForLoopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForLoopTypeContext differentiates from other interfaces.
	IsForLoopTypeContext()
}

type ForLoopTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopTypeContext() *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
	return p
}

func InitEmptyForLoopTypeContext(p *ForLoopTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
}

func (*ForLoopTypeContext) IsForLoopTypeContext() {}

func NewForLoopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forLoopType

	return p
}

func (s *ForLoopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopTypeContext) CopyAll(ctx *ForLoopTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForLoopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForLoopContext {
	var p = new(LabelForLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForLoopContext) ForTrinity() IForTrinityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForTrinityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForTrinityContext)
}

func (s *LabelForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForInLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInLoopContext {
	var p = new(LabelForInLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForInLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInLoopContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *LabelForInLoopContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForInLoopContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *LabelForInLoopContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *LabelForInLoopContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *LabelForInLoopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LabelForInLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForLoopType() (localctx IForLoopTypeContext) {
	localctx = NewForLoopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_forLoopType)
	var _la int

	p.SetState(671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(661)
			p.ForTrinity()
		}

	case 2:
		localctx = NewLabelForInLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(662)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(663)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(664)
				p.Match(ManuscriptID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(667)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(668)
			p.Expr()
		}
		{
			p.SetState(669)
			p.LoopBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForTrinityContext is an interface to support dynamic dispatch.
type IForTrinityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForInit() IForInitContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	ForCond() IForCondContext
	ForPost() IForPostContext
	LoopBody() ILoopBodyContext

	// IsForTrinityContext differentiates from other interfaces.
	IsForTrinityContext()
}

type ForTrinityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForTrinityContext() *ForTrinityContext {
	var p = new(ForTrinityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
	return p
}

func InitEmptyForTrinityContext(p *ForTrinityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
}

func (*ForTrinityContext) IsForTrinityContext() {}

func NewForTrinityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForTrinityContext {
	var p = new(ForTrinityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forTrinity

	return p
}

func (s *ForTrinityContext) GetParser() antlr.Parser { return s.parser }

func (s *ForTrinityContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForTrinityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForTrinityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForTrinityContext) ForCond() IForCondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForCondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForCondContext)
}

func (s *ForTrinityContext) ForPost() IForPostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForPostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForPostContext)
}

func (s *ForTrinityContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForTrinityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForTrinityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForTrinityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForTrinity(s)
	}
}

func (s *ForTrinityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForTrinity(s)
	}
}

func (s *ForTrinityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForTrinity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForTrinity() (localctx IForTrinityContext) {
	localctx = NewForTrinityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_forTrinity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.ForInit()
	}
	{
		p.SetState(674)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(675)
		p.ForCond()
	}
	{
		p.SetState(676)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(677)
		p.ForPost()
	}
	{
		p.SetState(678)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) CopyAll(ctx *ForInitContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForInitLetContext struct {
	ForInitContext
}

func NewLabelForInitLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitLetContext {
	var p = new(LabelForInitLetContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitLetContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LabelForInitLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInitEmptyContext struct {
	ForInitContext
}

func NewLabelForInitEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitEmptyContext {
	var p = new(LabelForInitEmptyContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_forInit)
	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelForInitLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(680)
			p.LetSingle()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForInitEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForCondContext is an interface to support dynamic dispatch.
type IForCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForCondContext differentiates from other interfaces.
	IsForCondContext()
}

type ForCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForCondContext() *ForCondContext {
	var p = new(ForCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
	return p
}

func InitEmptyForCondContext(p *ForCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
}

func (*ForCondContext) IsForCondContext() {}

func NewForCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForCondContext {
	var p = new(ForCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forCond

	return p
}

func (s *ForCondContext) GetParser() antlr.Parser { return s.parser }

func (s *ForCondContext) CopyAll(ctx *ForCondContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForCondEmptyContext struct {
	ForCondContext
}

func NewLabelForCondEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondEmptyContext {
	var p = new(LabelForCondEmptyContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForCondExprContext struct {
	ForCondContext
}

func NewLabelForCondExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondExprContext {
	var p = new(LabelForCondExprContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForCondExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForCond() (localctx IForCondContext) {
	localctx = NewForCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_forCond)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelForCondExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.Expr()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForCondEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForPostContext is an interface to support dynamic dispatch.
type IForPostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForPostContext differentiates from other interfaces.
	IsForPostContext()
}

type ForPostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForPostContext() *ForPostContext {
	var p = new(ForPostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
	return p
}

func InitEmptyForPostContext(p *ForPostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
}

func (*ForPostContext) IsForPostContext() {}

func NewForPostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForPostContext {
	var p = new(ForPostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forPost

	return p
}

func (s *ForPostContext) GetParser() antlr.Parser { return s.parser }

func (s *ForPostContext) CopyAll(ctx *ForPostContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForPostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForPostExprContext struct {
	ForPostContext
}

func NewLabelForPostExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostExprContext {
	var p = new(LabelForPostExprContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForPostExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForPostEmptyContext struct {
	ForPostContext
}

func NewLabelForPostEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostEmptyContext {
	var p = new(LabelForPostEmptyContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForPost() (localctx IForPostContext) {
	localctx = NewForPostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_forPost)
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForPostExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(688)
			p.Expr()
		}

	case 2:
		localctx = NewLabelForPostEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	LoopBody() ILoopBodyContext

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(693)
		p.Expr()
	}
	{
		p.SetState(694)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBodyContext is an interface to support dynamic dispatch.
type ILoopBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsLoopBodyContext differentiates from other interfaces.
	IsLoopBodyContext()
}

type LoopBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopBodyContext() *LoopBodyContext {
	var p = new(LoopBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
	return p
}

func InitEmptyLoopBodyContext(p *LoopBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
}

func (*LoopBodyContext) IsLoopBodyContext() {}

func NewLoopBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBodyContext {
	var p = new(LoopBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopBody

	return p
}

func (s *LoopBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LoopBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LoopBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LoopBodyContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *LoopBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopBody(s)
	}
}

func (s *LoopBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopBody(s)
	}
}

func (s *LoopBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopBody() (localctx ILoopBodyContext) {
	localctx = NewLoopBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_loopBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(696)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(697)
				p.Stmt_sep()
			}

		}
		p.SetState(702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180783658811872) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(703)
			p.Stmt()
		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(705)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptSEMICOLON {
					{
						p.SetState(704)
						p.Stmt_sep()
					}

					p.SetState(707)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(709)
					p.Stmt()
				}

			}
			p.SetState(715)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(718)
			p.Stmt_sep()
		}

		p.SetState(723)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(724)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_codeBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(726)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(727)
				p.Stmt_sep()
			}

		}
		p.SetState(732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180783658811872) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(733)
			p.Stmt()
		}
		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(735)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptSEMICOLON {
					{
						p.SetState(734)
						p.Stmt_sep()
					}

					p.SetState(737)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(739)
					p.Stmt()
				}

			}
			p.SetState(745)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(748)
			p.Stmt_sep()
		}

		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(754)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ManuscriptBREAK, 0)
}

func (s *BreakStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(756)
		p.Match(ManuscriptBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(757)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCONTINUE, 0)
}

func (s *ContinueStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(ManuscriptCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(760)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	SEMICOLON() antlr.TerminalNode

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *CheckStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *CheckStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CheckStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (s *CheckStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCheckStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_checkStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(ManuscriptCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(763)
		p.Expr()
	}
	{
		p.SetState(764)
		p.Match(ManuscriptCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(765)
		p.StringLiteral()
	}
	{
		p.SetState(766)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedStmtContext is an interface to support dynamic dispatch.
type IPipedStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPostfixExpr() []IPostfixExprContext
	PostfixExpr(i int) IPostfixExprContext
	SEMICOLON() antlr.TerminalNode
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	AllPipedArgs() []IPipedArgsContext
	PipedArgs(i int) IPipedArgsContext

	// IsPipedStmtContext differentiates from other interfaces.
	IsPipedStmtContext()
}

type PipedStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedStmtContext() *PipedStmtContext {
	var p = new(PipedStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedStmt
	return p
}

func InitEmptyPipedStmtContext(p *PipedStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedStmt
}

func (*PipedStmtContext) IsPipedStmtContext() {}

func NewPipedStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedStmtContext {
	var p = new(PipedStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedStmt

	return p
}

func (s *PipedStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedStmtContext) AllPostfixExpr() []IPostfixExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixExprContext); ok {
			len++
		}
	}

	tst := make([]IPostfixExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixExprContext); ok {
			tst[i] = t.(IPostfixExprContext)
			i++
		}
	}

	return tst
}

func (s *PipedStmtContext) PostfixExpr(i int) IPostfixExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PipedStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *PipedStmtContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPIPE)
}

func (s *PipedStmtContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE, i)
}

func (s *PipedStmtContext) AllPipedArgs() []IPipedArgsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPipedArgsContext); ok {
			len++
		}
	}

	tst := make([]IPipedArgsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPipedArgsContext); ok {
			tst[i] = t.(IPipedArgsContext)
			i++
		}
	}

	return tst
}

func (s *PipedStmtContext) PipedArgs(i int) IPipedArgsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedArgsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedArgsContext)
}

func (s *PipedStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedStmt(s)
	}
}

func (s *PipedStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedStmt(s)
	}
}

func (s *PipedStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedStmt() (localctx IPipedStmtContext) {
	localctx = NewPipedStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_pipedStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(768)
		p.postfixExpr(0)
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptPIPE {
		{
			p.SetState(769)
			p.Match(ManuscriptPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(770)
			p.postfixExpr(0)
		}
		p.SetState(772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptID {
			{
				p.SetState(771)
				p.PipedArgs()
			}

		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(778)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedArgsContext is an interface to support dynamic dispatch.
type IPipedArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPipedArg() []IPipedArgContext
	PipedArg(i int) IPipedArgContext

	// IsPipedArgsContext differentiates from other interfaces.
	IsPipedArgsContext()
}

type PipedArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedArgsContext() *PipedArgsContext {
	var p = new(PipedArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArgs
	return p
}

func InitEmptyPipedArgsContext(p *PipedArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArgs
}

func (*PipedArgsContext) IsPipedArgsContext() {}

func NewPipedArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedArgsContext {
	var p = new(PipedArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedArgs

	return p
}

func (s *PipedArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedArgsContext) AllPipedArg() []IPipedArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPipedArgContext); ok {
			len++
		}
	}

	tst := make([]IPipedArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPipedArgContext); ok {
			tst[i] = t.(IPipedArgContext)
			i++
		}
	}

	return tst
}

func (s *PipedArgsContext) PipedArg(i int) IPipedArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedArgContext)
}

func (s *PipedArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedArgs(s)
	}
}

func (s *PipedArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedArgs(s)
	}
}

func (s *PipedArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedArgs() (localctx IPipedArgsContext) {
	localctx = NewPipedArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_pipedArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptID {
		{
			p.SetState(780)
			p.PipedArg()
		}

		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedArgContext is an interface to support dynamic dispatch.
type IPipedArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsPipedArgContext differentiates from other interfaces.
	IsPipedArgContext()
}

type PipedArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedArgContext() *PipedArgContext {
	var p = new(PipedArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArg
	return p
}

func InitEmptyPipedArgContext(p *PipedArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArg
}

func (*PipedArgContext) IsPipedArgContext() {}

func NewPipedArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedArgContext {
	var p = new(PipedArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedArg

	return p
}

func (s *PipedArgContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedArgContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PipedArgContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *PipedArgContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PipedArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedArg(s)
	}
}

func (s *PipedArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedArg(s)
	}
}

func (s *PipedArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedArg() (localctx IPipedArgContext) {
	localctx = NewPipedArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ManuscriptRULE_pipedArg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(786)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(789)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() ITernaryExprContext

	// GetOp returns the op rule contexts.
	GetOp() IAssignmentOpContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ITernaryExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IAssignmentOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	TernaryExpr() ITernaryExprContext
	AssignmentOp() IAssignmentOpContext
	AssignmentExpr() IAssignmentExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ITernaryExprContext
	op     IAssignmentOpContext
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetLeft() ITernaryExprContext { return s.left }

func (s *AssignmentExprContext) GetOp() IAssignmentOpContext { return s.op }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ITernaryExprContext) { s.left = v }

func (s *AssignmentExprContext) SetOp(v IAssignmentOpContext) { s.op = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *AssignmentExprContext) AssignmentOp() IAssignmentOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOpContext)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ManuscriptRULE_assignmentExpr)
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(791)
			p.TernaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(792)

			var _x = p.TernaryExpr()

			localctx.(*AssignmentExprContext).left = _x
		}
		{
			p.SetState(793)

			var _x = p.AssignmentOp()

			localctx.(*AssignmentExprContext).op = _x
		}
		{
			p.SetState(794)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOpContext is an interface to support dynamic dispatch.
type IAssignmentOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	PLUS_EQUALS() antlr.TerminalNode
	MINUS_EQUALS() antlr.TerminalNode
	STAR_EQUALS() antlr.TerminalNode
	SLASH_EQUALS() antlr.TerminalNode
	MOD_EQUALS() antlr.TerminalNode
	CARET_EQUALS() antlr.TerminalNode

	// IsAssignmentOpContext differentiates from other interfaces.
	IsAssignmentOpContext()
}

type AssignmentOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOpContext() *AssignmentOpContext {
	var p = new(AssignmentOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
	return p
}

func InitEmptyAssignmentOpContext(p *AssignmentOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
}

func (*AssignmentOpContext) IsAssignmentOpContext() {}

func NewAssignmentOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOpContext {
	var p = new(AssignmentOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentOp

	return p
}

func (s *AssignmentOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOpContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *AssignmentOpContext) PLUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS_EQUALS, 0)
}

func (s *AssignmentOpContext) MINUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS_EQUALS, 0)
}

func (s *AssignmentOpContext) STAR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR_EQUALS, 0)
}

func (s *AssignmentOpContext) SLASH_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH_EQUALS, 0)
}

func (s *AssignmentOpContext) MOD_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD_EQUALS, 0)
}

func (s *AssignmentOpContext) CARET_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET_EQUALS, 0)
}

func (s *AssignmentOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentOp() (localctx IAssignmentOpContext) {
	localctx = NewAssignmentOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ManuscriptRULE_assignmentOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&2064385) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExprContext is an interface to support dynamic dispatch.
type ITernaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCond returns the cond rule contexts.
	GetCond() ILogicalOrExprContext

	// GetThenBranch returns the thenBranch rule contexts.
	GetThenBranch() IExprContext

	// GetElseExpr returns the elseExpr rule contexts.
	GetElseExpr() ITernaryExprContext

	// SetCond sets the cond rule contexts.
	SetCond(ILogicalOrExprContext)

	// SetThenBranch sets the thenBranch rule contexts.
	SetThenBranch(IExprContext)

	// SetElseExpr sets the elseExpr rule contexts.
	SetElseExpr(ITernaryExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	TernaryExpr() ITernaryExprContext

	// IsTernaryExprContext differentiates from other interfaces.
	IsTernaryExprContext()
}

type TernaryExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	cond       ILogicalOrExprContext
	thenBranch IExprContext
	elseExpr   ITernaryExprContext
}

func NewEmptyTernaryExprContext() *TernaryExprContext {
	var p = new(TernaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
	return p
}

func InitEmptyTernaryExprContext(p *TernaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
}

func (*TernaryExprContext) IsTernaryExprContext() {}

func NewTernaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExprContext {
	var p = new(TernaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ternaryExpr

	return p
}

func (s *TernaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExprContext) GetCond() ILogicalOrExprContext { return s.cond }

func (s *TernaryExprContext) GetThenBranch() IExprContext { return s.thenBranch }

func (s *TernaryExprContext) GetElseExpr() ITernaryExprContext { return s.elseExpr }

func (s *TernaryExprContext) SetCond(v ILogicalOrExprContext) { s.cond = v }

func (s *TernaryExprContext) SetThenBranch(v IExprContext) { s.thenBranch = v }

func (s *TernaryExprContext) SetElseExpr(v ITernaryExprContext) { s.elseExpr = v }

func (s *TernaryExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *TernaryExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TernaryExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *TernaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TernaryExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TernaryExpr() (localctx ITernaryExprContext) {
	localctx = NewTernaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ManuscriptRULE_ternaryExpr)
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(800)
			p.logicalOrExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(801)

			var _x = p.logicalOrExpr(0)

			localctx.(*TernaryExprContext).cond = _x
		}
		{
			p.SetState(802)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(803)

			var _x = p.Expr()

			localctx.(*TernaryExprContext).thenBranch = _x
		}
		{
			p.SetState(804)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(805)

			var _x = p.TernaryExpr()

			localctx.(*TernaryExprContext).elseExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	LogicalAndExpr() ILogicalAndExprContext
	LogicalOrExpr() ILogicalOrExprContext
	PIPE_PIPE() antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalOrExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalOrExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalOrExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *LogicalOrExprContext) PIPE_PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, 0)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	return p.logicalOrExpr(0)
}

func (p *Manuscript) logicalOrExpr(_p int) (localctx ILogicalOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, ManuscriptRULE_logicalOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.logicalAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalOrExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalOrExpr)
			p.SetState(812)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(813)

				var _m = p.Match(ManuscriptPIPE_PIPE)

				localctx.(*LogicalOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(814)

				var _x = p.logicalAndExpr(0)

				localctx.(*LogicalOrExprContext).right = _x
			}

		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseXorExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseXorExprContext)

	// Getter signatures
	BitwiseXorExpr() IBitwiseXorExprContext
	LogicalAndExpr() ILogicalAndExprContext
	AMP_AMP() antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  IBitwiseXorExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IBitwiseXorExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IBitwiseXorExprContext) { s.right = v }

func (s *LogicalAndExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *LogicalAndExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalAndExprContext) AMP_AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, 0)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	return p.logicalAndExpr(0)
}

func (p *Manuscript) logicalAndExpr(_p int) (localctx ILogicalAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, ManuscriptRULE_logicalAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(821)
		p.bitwiseXorExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalAndExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalAndExpr)
			p.SetState(823)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(824)

				var _m = p.Match(ManuscriptAMP_AMP)

				localctx.(*LogicalAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(825)

				var _x = p.bitwiseXorExpr(0)

				localctx.(*LogicalAndExprContext).right = _x
			}

		}
		p.SetState(830)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseXorExprContext is an interface to support dynamic dispatch.
type IBitwiseXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseXorExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseXorExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseAndExprContext)

	// Getter signatures
	BitwiseAndExpr() IBitwiseAndExprContext
	BitwiseXorExpr() IBitwiseXorExprContext
	CARET() antlr.TerminalNode

	// IsBitwiseXorExprContext differentiates from other interfaces.
	IsBitwiseXorExprContext()
}

type BitwiseXorExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseXorExprContext
	op     antlr.Token
	right  IBitwiseAndExprContext
}

func NewEmptyBitwiseXorExprContext() *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
	return p
}

func InitEmptyBitwiseXorExprContext(p *BitwiseXorExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
}

func (*BitwiseXorExprContext) IsBitwiseXorExprContext() {}

func NewBitwiseXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr

	return p
}

func (s *BitwiseXorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExprContext) GetLeft() IBitwiseXorExprContext { return s.left }

func (s *BitwiseXorExprContext) GetRight() IBitwiseAndExprContext { return s.right }

func (s *BitwiseXorExprContext) SetLeft(v IBitwiseXorExprContext) { s.left = v }

func (s *BitwiseXorExprContext) SetRight(v IBitwiseAndExprContext) { s.right = v }

func (s *BitwiseXorExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseXorExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseXorExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET, 0)
}

func (s *BitwiseXorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseXorExpr() (localctx IBitwiseXorExprContext) {
	return p.bitwiseXorExpr(0)
}

func (p *Manuscript) bitwiseXorExpr(_p int) (localctx IBitwiseXorExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseXorExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseXorExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ManuscriptRULE_bitwiseXorExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(832)
		p.bitwiseAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseXorExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseXorExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseXorExpr)
			p.SetState(834)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(835)

				var _m = p.Match(ManuscriptCARET)

				localctx.(*BitwiseXorExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(836)

				var _x = p.bitwiseAndExpr(0)

				localctx.(*BitwiseXorExprContext).right = _x
			}

		}
		p.SetState(841)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseAndExprContext is an interface to support dynamic dispatch.
type IBitwiseAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	EqualityExpr() IEqualityExprContext
	BitwiseAndExpr() IBitwiseAndExprContext
	AMP() antlr.TerminalNode

	// IsBitwiseAndExprContext differentiates from other interfaces.
	IsBitwiseAndExprContext()
}

type BitwiseAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseAndExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyBitwiseAndExprContext() *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
	return p
}

func InitEmptyBitwiseAndExprContext(p *BitwiseAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
}

func (*BitwiseAndExprContext) IsBitwiseAndExprContext() {}

func NewBitwiseAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr

	return p
}

func (s *BitwiseAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExprContext) GetLeft() IBitwiseAndExprContext { return s.left }

func (s *BitwiseAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *BitwiseAndExprContext) SetLeft(v IBitwiseAndExprContext) { s.left = v }

func (s *BitwiseAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *BitwiseAndExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *BitwiseAndExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseAndExprContext) AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP, 0)
}

func (s *BitwiseAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseAndExpr() (localctx IBitwiseAndExprContext) {
	return p.bitwiseAndExpr(0)
}

func (p *Manuscript) bitwiseAndExpr(_p int) (localctx IBitwiseAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, ManuscriptRULE_bitwiseAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(843)
		p.equalityExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseAndExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseAndExpr)
			p.SetState(845)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(846)

				var _m = p.Match(ManuscriptAMP)

				localctx.(*BitwiseAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(847)

				var _x = p.equalityExpr(0)

				localctx.(*BitwiseAndExprContext).right = _x
			}

		}
		p.SetState(852)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	EqualityExpr() IEqualityExprContext
	EQUALS_EQUALS() antlr.TerminalNode
	NEQ() antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *EqualityExprContext) EQUALS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, 0)
}

func (s *EqualityExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, 0)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	return p.equalityExpr(0)
}

func (p *Manuscript) equalityExpr(_p int) (localctx IEqualityExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, ManuscriptRULE_equalityExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.comparisonExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEqualityExprContext(p, _parentctx, _parentState)
			localctx.(*EqualityExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_equalityExpr)
			p.SetState(856)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(857)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*EqualityExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*EqualityExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(858)

				var _x = p.comparisonExpr(0)

				localctx.(*EqualityExprContext).right = _x
			}

		}
		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOpContext is an interface to support dynamic dispatch.
type IComparisonOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	LT_EQUALS() antlr.TerminalNode
	GT() antlr.TerminalNode
	GT_EQUALS() antlr.TerminalNode

	// IsComparisonOpContext differentiates from other interfaces.
	IsComparisonOpContext()
}

type ComparisonOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOpContext() *ComparisonOpContext {
	var p = new(ComparisonOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
	return p
}

func InitEmptyComparisonOpContext(p *ComparisonOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
}

func (*ComparisonOpContext) IsComparisonOpContext() {}

func NewComparisonOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOpContext {
	var p = new(ComparisonOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonOp

	return p
}

func (s *ComparisonOpContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOpContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *ComparisonOpContext) LT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, 0)
}

func (s *ComparisonOpContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *ComparisonOpContext) GT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, 0)
}

func (s *ComparisonOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonOp(s)
	}
}

func (s *ComparisonOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonOp(s)
	}
}

func (s *ComparisonOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonOp() (localctx IComparisonOpContext) {
	localctx = NewComparisonOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ManuscriptRULE_comparisonOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(864)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1055531162664960) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetOp returns the op rule contexts.
	GetOp() IComparisonOpContext

	// GetRight returns the right rule contexts.
	GetRight() IAdditiveExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IComparisonOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IAdditiveExprContext)

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext
	ComparisonExpr() IComparisonExprContext
	ComparisonOp() IComparisonOpContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     IComparisonOpContext
	right  IAdditiveExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *ComparisonExprContext) GetOp() IComparisonOpContext { return s.op }

func (s *ComparisonExprContext) GetRight() IAdditiveExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *ComparisonExprContext) SetOp(v IComparisonOpContext) { s.op = v }

func (s *ComparisonExprContext) SetRight(v IAdditiveExprContext) { s.right = v }

func (s *ComparisonExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ComparisonExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *ComparisonExprContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	return p.comparisonExpr(0)
}

func (p *Manuscript) comparisonExpr(_p int) (localctx IComparisonExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 138
	p.EnterRecursionRule(localctx, 138, ManuscriptRULE_comparisonExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.additiveExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonExprContext(p, _parentctx, _parentState)
			localctx.(*ComparisonExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_comparisonExpr)
			p.SetState(869)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(870)

				var _x = p.ComparisonOp()

				localctx.(*ComparisonExprContext).op = _x
			}
			{
				p.SetState(871)

				var _x = p.additiveExpr(0)

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *AdditiveExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *Manuscript) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 140
	p.EnterRecursionRule(localctx, 140, ManuscriptRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			localctx.(*AdditiveExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_additiveExpr)
			p.SetState(881)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(882)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(883)

				var _x = p.multiplicativeExpr(0)

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	MultiplicativeExpr() IMultiplicativeExprContext
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, 0)
}

func (s *MultiplicativeExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, 0)
}

func (s *MultiplicativeExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD, 0)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *Manuscript) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 142
	p.EnterRecursionRule(localctx, 142, ManuscriptRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.UnaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			localctx.(*MultiplicativeExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_multiplicativeExpr)
			p.SetState(892)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(893)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009213693952) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(894)

				var _x = p.UnaryExpr()

				localctx.(*MultiplicativeExprContext).right = _x
			}

		}
		p.SetState(899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) CopyAll(ctx *UnaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelUnaryOpExprContext struct {
	UnaryExprContext
	op    antlr.Token
	unary IUnaryExprContext
}

func NewLabelUnaryOpExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryOpExprContext {
	var p = new(LabelUnaryOpExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryOpExprContext) GetOp() antlr.Token { return s.op }

func (s *LabelUnaryOpExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LabelUnaryOpExprContext) GetUnary() IUnaryExprContext { return s.unary }

func (s *LabelUnaryOpExprContext) SetUnary(v IUnaryExprContext) { s.unary = v }

func (s *LabelUnaryOpExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryOpExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *LabelUnaryOpExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *LabelUnaryOpExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *LabelUnaryOpExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *LabelUnaryOpExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryOpExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelUnaryPostfixExprContext struct {
	UnaryExprContext
}

func NewLabelUnaryPostfixExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryPostfixExprContext {
	var p = new(LabelUnaryPostfixExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryPostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryPostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *LabelUnaryPostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryPostfixExpr(s)
	}
}

func (s *LabelUnaryPostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryPostfixExpr(s)
	}
}

func (s *LabelUnaryPostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION:
		localctx = NewLabelUnaryOpExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(900)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LabelUnaryOpExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&515) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LabelUnaryOpExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(901)

			var _x = p.UnaryExpr()

			localctx.(*LabelUnaryOpExprContext).unary = _x
		}

	case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelUnaryPostfixExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(902)
			p.postfixExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	PostfixExpr() IPostfixExprContext
	PostfixOp() IPostfixOpContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PostfixExprContext) PostfixOp() IPostfixOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOpContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	return p.postfixExpr(0)
}

func (p *Manuscript) postfixExpr(_p int) (localctx IPostfixExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 146
	p.EnterRecursionRule(localctx, 146, ManuscriptRULE_postfixExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.PrimaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_postfixExpr)
			p.SetState(908)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(909)
				p.PostfixOp()
			}

		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOpContext is an interface to support dynamic dispatch.
type IPostfixOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPostfixOpContext differentiates from other interfaces.
	IsPostfixOpContext()
}

type PostfixOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOpContext() *PostfixOpContext {
	var p = new(PostfixOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
	return p
}

func InitEmptyPostfixOpContext(p *PostfixOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
}

func (*PostfixOpContext) IsPostfixOpContext() {}

func NewPostfixOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOpContext {
	var p = new(PostfixOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixOp

	return p
}

func (s *PostfixOpContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOpContext) CopyAll(ctx *PostfixOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PostfixOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPostfixDotContext struct {
	PostfixOpContext
}

func NewLabelPostfixDotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixDotContext {
	var p = new(LabelPostfixDotContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixDotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixDotContext) DOT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, 0)
}

func (s *LabelPostfixDotContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPostfixDotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixDot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixCallContext struct {
	PostfixOpContext
}

func NewLabelPostfixCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixCallContext {
	var p = new(LabelPostfixCallContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPostfixCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPostfixCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *LabelPostfixCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixIndexContext struct {
	PostfixOpContext
}

func NewLabelPostfixIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixIndexContext {
	var p = new(LabelPostfixIndexContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixIndexContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelPostfixIndexContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPostfixIndexContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelPostfixIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixOp() (localctx IPostfixOpContext) {
	localctx = NewPostfixOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ManuscriptRULE_postfixOp)
	var _la int

	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLPAREN:
		localctx = NewLabelPostfixCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(916)
				p.ExprList()
			}

		}
		{
			p.SetState(919)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOT:
		localctx = NewLabelPostfixDotContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(920)
			p.Match(ManuscriptDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(921)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		localctx = NewLabelPostfixIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(922)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Expr()
		}
		{
			p.SetState(924)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) CopyAll(ctx *PrimaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPrimaryTaggedBlockContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryTaggedBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryTaggedBlockContext {
	var p = new(LabelPrimaryTaggedBlockContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryTaggedBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryTaggedBlockContext) TaggedBlockString() ITaggedBlockStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaggedBlockStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaggedBlockStringContext)
}

func (s *LabelPrimaryTaggedBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryTaggedBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryParenContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryParenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryParenContext {
	var p = new(LabelPrimaryParenContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryParenContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPrimaryParenContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPrimaryParenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPrimaryParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryParen(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMatchContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMatchContext {
	var p = new(LabelPrimaryMatchContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMatchContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *LabelPrimaryMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryFnContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryFnContext {
	var p = new(LabelPrimaryFnContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryFnContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *LabelPrimaryFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimarySetContext struct {
	PrimaryExprContext
}

func NewLabelPrimarySetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimarySetContext {
	var p = new(LabelPrimarySetContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimarySetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimarySetContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *LabelPrimarySetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimarySet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryIDContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryIDContext {
	var p = new(LabelPrimaryIDContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPrimaryIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryID(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryVoidContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryVoidContext {
	var p = new(LabelPrimaryVoidContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelPrimaryVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMapContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMapContext {
	var p = new(LabelPrimaryMapContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMapContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LabelPrimaryMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMap(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryLiteralContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryLiteralContext {
	var p = new(LabelPrimaryLiteralContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LabelPrimaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryArrayContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryArrayContext {
	var p = new(LabelPrimaryArrayContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryArrayContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *LabelPrimaryArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryNullContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryNullContext {
	var p = new(LabelPrimaryNullContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelPrimaryNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryTypedObjectContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryTypedObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryTypedObjectContext {
	var p = new(LabelPrimaryTypedObjectContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryTypedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryTypedObjectContext) TypedObjectLiteral() ITypedObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedObjectLiteralContext)
}

func (s *LabelPrimaryTypedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryTypedObject(s)
	}
}

func (s *LabelPrimaryTypedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryTypedObject(s)
	}
}

func (s *LabelPrimaryTypedObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryTypedObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryObjectContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryObjectContext {
	var p = new(LabelPrimaryObjectContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryObjectContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *LabelPrimaryObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ManuscriptRULE_primaryExpr)
	p.SetState(944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelPrimaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.Literal()
		}

	case 2:
		localctx = NewLabelPrimaryTypedObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.TypedObjectLiteral()
		}

	case 3:
		localctx = NewLabelPrimaryIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(930)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLabelPrimaryParenContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(931)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(932)
			p.Expr()
		}
		{
			p.SetState(933)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewLabelPrimaryArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(935)
			p.ArrayLiteral()
		}

	case 6:
		localctx = NewLabelPrimaryObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(936)
			p.ObjectLiteral()
		}

	case 7:
		localctx = NewLabelPrimaryMapContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(937)
			p.MapLiteral()
		}

	case 8:
		localctx = NewLabelPrimarySetContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(938)
			p.SetLiteral()
		}

	case 9:
		localctx = NewLabelPrimaryFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(939)
			p.FnExpr()
		}

	case 10:
		localctx = NewLabelPrimaryMatchContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(940)
			p.MatchExpr()
		}

	case 11:
		localctx = NewLabelPrimaryVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(941)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewLabelPrimaryNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(942)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewLabelPrimaryTaggedBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(943)
			p.TaggedBlockString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExprContext is an interface to support dynamic dispatch.
type ITryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Expr() IExprContext

	// IsTryExprContext differentiates from other interfaces.
	IsTryExprContext()
}

type TryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExprContext() *TryExprContext {
	var p = new(TryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryExpr
	return p
}

func InitEmptyTryExprContext(p *TryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryExpr
}

func (*TryExprContext) IsTryExprContext() {}

func NewTryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExprContext {
	var p = new(TryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tryExpr

	return p
}

func (s *TryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *TryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTryExpr(s)
	}
}

func (s *TryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTryExpr(s)
	}
}

func (s *TryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TryExpr() (localctx ITryExprContext) {
	localctx = NewTryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ManuscriptRULE_tryExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(946)
		p.Match(ManuscriptTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(947)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(950)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(951)
			p.Parameters()
		}

	}
	{
		p.SetState(954)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(955)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(958)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expr() IExprContext
	LBRACE() antlr.TerminalNode
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	DefaultClause() IDefaultClauseContext

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MatchExprContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ManuscriptRULE_matchExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(960)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(961)
		p.Expr()
	}
	{
		p.SetState(962)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(963)
			p.Stmt_sep()
		}

		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(969)
		p.CaseClause()
	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptSEMICOLON {
				{
					p.SetState(970)
					p.Stmt_sep()
				}

				p.SetState(973)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(975)
				p.CaseClause()
			}

		}
		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptSEMICOLON {
		{
			p.SetState(982)
			p.Stmt_sep()
		}

		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptDEFAULT {
		{
			p.SetState(988)
			p.DefaultClause()
		}

	}
	{
		p.SetState(991)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	SEMICOLON() antlr.TerminalNode
	COLON() antlr.TerminalNode
	CodeBlock() ICodeBlockContext

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ManuscriptRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.Expr()
	}
	p.SetState(997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(994)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(995)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(996)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(999)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFAULT, 0)
}

func (s *DefaultClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DefaultClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *DefaultClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DefaultClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ManuscriptRULE_defaultClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(ManuscriptDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1002)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1003)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1004)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1007)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1010)
			p.StringPart()
		}

		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1016)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1019)
			p.StringPart()
		}

		p.SetState(1024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1025)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTE_START() antlr.TerminalNode
	DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsDoubleQuotedStringContext differentiates from other interfaces.
	IsDoubleQuotedStringContext()
}

type DoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleQuotedStringContext() *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
	return p
}

func InitEmptyDoubleQuotedStringContext(p *DoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
}

func (*DoubleQuotedStringContext) IsDoubleQuotedStringContext() {}

func NewDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_doubleQuotedString

	return p
}

func (s *DoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleQuotedStringContext) DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_QUOTE_START, 0)
}

func (s *DoubleQuotedStringContext) DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_END, 0)
}

func (s *DoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *DoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *DoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DoubleQuotedString() (localctx IDoubleQuotedStringContext) {
	localctx = NewDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ManuscriptRULE_doubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1027)
		p.Match(ManuscriptDOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1028)
			p.StringPart()
		}

		p.SetState(1033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1034)
		p.Match(ManuscriptDOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IMultiDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiDoubleQuotedStringContext differentiates from other interfaces.
	IsMultiDoubleQuotedStringContext()
}

type MultiDoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiDoubleQuotedStringContext() *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
	return p
}

func InitEmptyMultiDoubleQuotedStringContext(p *MultiDoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
}

func (*MultiDoubleQuotedStringContext) IsMultiDoubleQuotedStringContext() {}

func NewMultiDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString

	return p
}

func (s *MultiDoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_QUOTE_START, 0)
}

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_END, 0)
}

func (s *MultiDoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiDoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiDoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiDoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiDoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiDoubleQuotedString() (localctx IMultiDoubleQuotedStringContext) {
	localctx = NewMultiDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ManuscriptRULE_multiDoubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(ManuscriptMULTI_DOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1037)
			p.StringPart()
		}

		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1043)
		p.Match(ManuscriptMULTI_DOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_STR_CONTENT() antlr.TerminalNode
	MULTI_STR_CONTENT() antlr.TerminalNode
	DOUBLE_STR_CONTENT() antlr.TerminalNode
	MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode
	Interpolation() IInterpolationContext

	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *StringPartContext) DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPart(s)
	}
}

func (s *StringPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPart(s)
	}
}

func (s *StringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ManuscriptRULE_stringPart)
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1045)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1046)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1047)
			p.Match(ManuscriptDOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_DOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1048)
			p.Match(ManuscriptMULTI_DOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START, ManuscriptDOUBLE_STR_INTERP_START, ManuscriptMULTI_DOUBLE_STR_INTERP_START:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1049)
			p.Interpolation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	DOUBLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&585) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1053)
		p.Expr()
	}
	{
		p.SetState(1054)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLiteralBoolContext struct {
	LiteralContext
}

func NewLabelLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralBoolContext {
	var p = new(LabelLiteralBoolContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralBoolContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LabelLiteralBoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralStringContext struct {
	LiteralContext
}

func NewLabelLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralStringContext {
	var p = new(LabelLiteralStringContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralStringContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelLiteralStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNumberContext struct {
	LiteralContext
}

func NewLabelLiteralNumberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNumberContext {
	var p = new(LabelLiteralNumberContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNumberContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LabelLiteralNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNullContext struct {
	LiteralContext
}

func NewLabelLiteralNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNullContext {
	var p = new(LabelLiteralNullContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelLiteralNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralVoidContext struct {
	LiteralContext
}

func NewLabelLiteralVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralVoidContext {
	var p = new(LabelLiteralVoidContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelLiteralVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ManuscriptRULE_literal)
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1056)
			p.StringLiteral()
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		localctx = NewLabelLiteralNumberContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1057)
			p.NumberLiteral()
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		localctx = NewLabelLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1058)
			p.BooleanLiteral()
		}

	case ManuscriptNULL:
		localctx = NewLabelLiteralNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1059)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		localctx = NewLabelLiteralVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1060)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext
	MultiQuotedString() IMultiQuotedStringContext
	DoubleQuotedString() IDoubleQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *StringLiteralContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *StringLiteralContext) DoubleQuotedString() IDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleQuotedStringContext)
}

func (s *StringLiteralContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ManuscriptRULE_stringLiteral)
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1063)
			p.SingleQuotedString()
		}

	case ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1064)
			p.MultiQuotedString()
		}

	case ManuscriptDOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1065)
			p.DoubleQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1066)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) CopyAll(ctx *NumberLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelNumberLiteralHexContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralHexContext {
	var p = new(LabelNumberLiteralHexContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralHexContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *LabelNumberLiteralHexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralIntContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralIntContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralIntContext {
	var p = new(LabelNumberLiteralIntContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralIntContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *LabelNumberLiteralIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralInt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralOctContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralOctContext {
	var p = new(LabelNumberLiteralOctContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralOctContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptOCTAL_LITERAL, 0)
}

func (s *LabelNumberLiteralOctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralOct(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralFloatContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralFloatContext {
	var p = new(LabelNumberLiteralFloatContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *LabelNumberLiteralFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralBinContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralBinContext {
	var p = new(LabelNumberLiteralBinContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralBinContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *LabelNumberLiteralBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralBin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ManuscriptRULE_numberLiteral)
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		localctx = NewLabelNumberLiteralIntContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1069)
			p.Match(ManuscriptINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		localctx = NewLabelNumberLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.Match(ManuscriptFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		localctx = NewLabelNumberLiteralHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1071)
			p.Match(ManuscriptHEX_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		localctx = NewLabelNumberLiteralBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1072)
			p.Match(ManuscriptBINARY_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptOCTAL_LITERAL:
		localctx = NewLabelNumberLiteralOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1073)
			p.Match(ManuscriptOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) CopyAll(ctx *BooleanLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelBoolLiteralFalseContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralFalseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralFalseContext {
	var p = new(LabelBoolLiteralFalseContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralFalseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralFalseContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *LabelBoolLiteralFalseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralFalse(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelBoolLiteralTrueContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralTrueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralTrueContext {
	var p = new(LabelBoolLiteralTrueContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralTrueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralTrueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *LabelBoolLiteralTrueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralTrue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ManuscriptRULE_booleanLiteral)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptTRUE:
		localctx = NewLabelBoolLiteralTrueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1076)
			p.Match(ManuscriptTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFALSE:
		localctx = NewLabelBoolLiteralFalseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1077)
			p.Match(ManuscriptFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	ExprList() IExprListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1080)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1081)
			p.ExprList()
		}

	}
	{
		p.SetState(1084)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectFieldList() IObjectFieldListContext

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) ObjectFieldList() IObjectFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldListContext)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ManuscriptRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1086)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || ((int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&31) != 0) {
		{
			p.SetState(1087)
			p.ObjectFieldList()
		}

	}
	{
		p.SetState(1090)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldListContext is an interface to support dynamic dispatch.
type IObjectFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllNEWLINE() []antlr.TerminalNode
	NEWLINE(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectFieldListContext differentiates from other interfaces.
	IsObjectFieldListContext()
}

type ObjectFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldListContext() *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
	return p
}

func InitEmptyObjectFieldListContext(p *ObjectFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
}

func (*ObjectFieldListContext) IsObjectFieldListContext() {}

func NewObjectFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldList

	return p
}

func (s *ObjectFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldListContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectFieldListContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectFieldListContext) AllNEWLINE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptNEWLINE)
}

func (s *ObjectFieldListContext) NEWLINE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptNEWLINE, i)
}

func (s *ObjectFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldList() (localctx IObjectFieldListContext) {
	localctx = NewObjectFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ManuscriptRULE_objectFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE {
		{
			p.SetState(1092)
			p.Match(ManuscriptNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1098)
		p.ObjectField()
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1103)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1099)
					p.Match(ManuscriptNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(1100)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				{
					p.SetState(1101)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1102)
					p.Match(ManuscriptNEWLINE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(1105)
				p.ObjectField()
			}

		}
		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1111)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE {
		{
			p.SetState(1114)
			p.Match(ManuscriptNEWLINE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ObjectFieldName() IObjectFieldNameContext
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) ObjectFieldName() IObjectFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldNameContext)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1120)
		p.ObjectFieldName()
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(1121)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldNameContext is an interface to support dynamic dispatch.
type IObjectFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectFieldNameContext differentiates from other interfaces.
	IsObjectFieldNameContext()
}

type ObjectFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldNameContext() *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
	return p
}

func InitEmptyObjectFieldNameContext(p *ObjectFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
}

func (*ObjectFieldNameContext) IsObjectFieldNameContext() {}

func NewObjectFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldName

	return p
}

func (s *ObjectFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldNameContext) CopyAll(ctx *ObjectFieldNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelObjectFieldNameStrContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameStrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameStrContext {
	var p = new(LabelObjectFieldNameStrContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameStrContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelObjectFieldNameStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameStr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelObjectFieldNameIDContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameIDContext {
	var p = new(LabelObjectFieldNameIDContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelObjectFieldNameIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldName() (localctx IObjectFieldNameContext) {
	localctx = NewObjectFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ManuscriptRULE_objectFieldName)
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelObjectFieldNameIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1125)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelObjectFieldNameStrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1126)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) CopyAll(ctx *MapLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelMapLiteralNonEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralNonEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralNonEmptyContext {
	var p = new(LabelMapLiteralNonEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralNonEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralNonEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) MapFieldList() IMapFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldListContext)
}

func (s *LabelMapLiteralNonEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralNonEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelMapLiteralEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralEmptyContext {
	var p = new(LabelMapLiteralEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *LabelMapLiteralEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ManuscriptRULE_mapLiteral)
	var _la int

	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelMapLiteralEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1129)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1130)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1131)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelMapLiteralNonEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1132)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(1133)
				p.MapFieldList()
			}

		}
		{
			p.SetState(1136)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldListContext is an interface to support dynamic dispatch.
type IMapFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapFieldListContext differentiates from other interfaces.
	IsMapFieldListContext()
}

type MapFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldListContext() *MapFieldListContext {
	var p = new(MapFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
	return p
}

func InitEmptyMapFieldListContext(p *MapFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
}

func (*MapFieldListContext) IsMapFieldListContext() {}

func NewMapFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldListContext {
	var p = new(MapFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapFieldList

	return p
}

func (s *MapFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldListContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldListContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapFieldList(s)
	}
}

func (s *MapFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapFieldList(s)
	}
}

func (s *MapFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapFieldList() (localctx IMapFieldListContext) {
	localctx = NewMapFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ManuscriptRULE_mapFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		p.MapField()
	}
	p.SetState(1144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1140)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1141)
				p.MapField()
			}

		}
		p.SetState(1146)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1147)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1150)
		p.Expr()
	}
	{
		p.SetState(1151)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1152)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ManuscriptRULE_setLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Match(ManuscriptLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1155)
			p.Expr()
		}
		p.SetState(1160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1156)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1157)
					p.Expr()
				}

			}
			p.SetState(1162)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(1163)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1168)
		p.Match(ManuscriptGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaggedBlockStringContext is an interface to support dynamic dispatch.
type ITaggedBlockStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	MultiQuotedString() IMultiQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsTaggedBlockStringContext differentiates from other interfaces.
	IsTaggedBlockStringContext()
}

type TaggedBlockStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaggedBlockStringContext() *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
	return p
}

func InitEmptyTaggedBlockStringContext(p *TaggedBlockStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
}

func (*TaggedBlockStringContext) IsTaggedBlockStringContext() {}

func NewTaggedBlockStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_taggedBlockString

	return p
}

func (s *TaggedBlockStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TaggedBlockStringContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TaggedBlockStringContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *TaggedBlockStringContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *TaggedBlockStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaggedBlockStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaggedBlockStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTaggedBlockString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TaggedBlockString() (localctx ITaggedBlockStringContext) {
	localctx = NewTaggedBlockStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ManuscriptRULE_taggedBlockString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1170)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptMULTI_QUOTE_START:
		{
			p.SetState(1171)
			p.MultiQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		{
			p.SetState(1172)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedObjectLiteralContext is an interface to support dynamic dispatch.
type ITypedObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectFieldList() IObjectFieldListContext

	// IsTypedObjectLiteralContext differentiates from other interfaces.
	IsTypedObjectLiteralContext()
}

type TypedObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedObjectLiteralContext() *TypedObjectLiteralContext {
	var p = new(TypedObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedObjectLiteral
	return p
}

func InitEmptyTypedObjectLiteralContext(p *TypedObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedObjectLiteral
}

func (*TypedObjectLiteralContext) IsTypedObjectLiteralContext() {}

func NewTypedObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedObjectLiteralContext {
	var p = new(TypedObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedObjectLiteral

	return p
}

func (s *TypedObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedObjectLiteralContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypedObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypedObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypedObjectLiteralContext) ObjectFieldList() IObjectFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldListContext)
}

func (s *TypedObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedObjectLiteral(s)
	}
}

func (s *TypedObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedObjectLiteral(s)
	}
}

func (s *TypedObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedObjectLiteral() (localctx ITypedObjectLiteralContext) {
	localctx = NewTypedObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ManuscriptRULE_typedObjectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1176)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || ((int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&31) != 0) {
		{
			p.SetState(1177)
			p.ObjectFieldList()
		}

	}
	{
		p.SetState(1180)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) CopyAll(ctx *TypeAnnotationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelTypeAnnVoidContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnVoidContext {
	var p = new(LabelTypeAnnVoidContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelTypeAnnVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnArrayContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnArrayContext {
	var p = new(LabelTypeAnnArrayContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnArrayContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *LabelTypeAnnArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnTupleContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnTupleContext {
	var p = new(LabelTypeAnnTupleContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnTupleContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *LabelTypeAnnTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnFnContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnFnContext {
	var p = new(LabelTypeAnnFnContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnFnContext) FnType() IFnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnTypeContext)
}

func (s *LabelTypeAnnFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnIDContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnIDContext {
	var p = new(LabelTypeAnnIDContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelTypeAnnIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ManuscriptRULE_typeAnnotation)
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelTypeAnnIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1182)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelTypeAnnArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1183)
			p.ArrayType()
		}

	case 3:
		localctx = NewLabelTypeAnnTupleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1184)
			p.TupleType()
		}

	case 4:
		localctx = NewLabelTypeAnnFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1185)
			p.FnType()
		}

	case 5:
		localctx = NewLabelTypeAnnVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1186)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(1190)
			p.TypeList()
		}

	}
	{
		p.SetState(1193)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ArrayTypeContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayTypeContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ManuscriptRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1196)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1197)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnTypeContext is an interface to support dynamic dispatch.
type IFnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnTypeContext differentiates from other interfaces.
	IsFnTypeContext()
}

type FnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnTypeContext() *FnTypeContext {
	var p = new(FnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
	return p
}

func InitEmptyFnTypeContext(p *FnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
}

func (*FnTypeContext) IsFnTypeContext() {}

func NewFnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnTypeContext {
	var p = new(FnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnType

	return p
}

func (s *FnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FnTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnTypeContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnTypeContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnType(s)
	}
}

func (s *FnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnType(s)
	}
}

func (s *FnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnType() (localctx IFnTypeContext) {
	localctx = NewFnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ManuscriptRULE_fnType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1199)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1200)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1202)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1201)
			p.Parameters()
		}

	}
	{
		p.SetState(1204)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1205)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_sepContext is an interface to support dynamic dispatch.
type IStmt_sepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsStmt_sepContext differentiates from other interfaces.
	IsStmt_sepContext()
}

type Stmt_sepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_sepContext() *Stmt_sepContext {
	var p = new(Stmt_sepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
	return p
}

func InitEmptyStmt_sepContext(p *Stmt_sepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
}

func (*Stmt_sepContext) IsStmt_sepContext() {}

func NewStmt_sepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_sepContext {
	var p = new(Stmt_sepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt_sep

	return p
}

func (s *Stmt_sepContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_sepContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *Stmt_sepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_sepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt_sep(s)
	}
}

func (s *Stmt_sepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt_sep(s)
	}
}

func (s *Stmt_sepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt_sep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt_sep() (localctx IStmt_sepContext) {
	localctx = NewStmt_sepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ManuscriptRULE_stmt_sep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Manuscript) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 63:
		var t *LogicalOrExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalOrExprContext)
		}
		return p.LogicalOrExpr_Sempred(t, predIndex)

	case 64:
		var t *LogicalAndExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalAndExprContext)
		}
		return p.LogicalAndExpr_Sempred(t, predIndex)

	case 65:
		var t *BitwiseXorExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseXorExprContext)
		}
		return p.BitwiseXorExpr_Sempred(t, predIndex)

	case 66:
		var t *BitwiseAndExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseAndExprContext)
		}
		return p.BitwiseAndExpr_Sempred(t, predIndex)

	case 67:
		var t *EqualityExprContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExprContext)
		}
		return p.EqualityExpr_Sempred(t, predIndex)

	case 69:
		var t *ComparisonExprContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonExprContext)
		}
		return p.ComparisonExpr_Sempred(t, predIndex)

	case 70:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 71:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 73:
		var t *PostfixExprContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExprContext)
		}
		return p.PostfixExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Manuscript) LogicalOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) LogicalAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseXorExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) EqualityExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ComparisonExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) PostfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
