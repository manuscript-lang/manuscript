// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'", "'interface'",
		"'import'", "'export'", "'extern'", "'void'", "'check'", "'try'", "'catch'",
		"'in'", "'as'", "'is'", "'extends'", "'from'", "'null'", "'if'", "'else'",
		"'for'", "'while'", "'true'", "'false'", "'match'", "'case'", "'async'",
		"'await'", "'methods'", "'break'", "'continue'", "'default'", "'defer'",
		"'go'", "", "", "'['", "']'", "'('", "')'", "'<'", "'>'", "'<='", "'>='",
		"':'", "';'", "','", "'='", "'=='", "'+'", "'-'", "'++'", "'--'", "'||'",
		"'&&'", "'*'", "'/'", "'%'", "'!'", "'?'", "'.'", "'!='", "'+='", "'-='",
		"'*='", "'/='", "'%='", "'^='", "'|'", "'&'", "'^'", "'<<'", "'>>'",
	}
	staticData.SymbolicNames = []string{
		"", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN", "YIELD",
		"TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID", "CHECK",
		"TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL", "IF", "ELSE",
		"FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC", "AWAIT",
		"METHODS", "BREAK", "CONTINUE", "DEFAULT", "DEFER", "GO", "LBRACE",
		"RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN", "LT", "GT", "LT_EQUALS",
		"GT_EQUALS", "COLON", "SEMICOLON", "COMMA", "EQUALS", "EQUALS_EQUALS",
		"PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS", "PIPE_PIPE", "AMP_AMP",
		"STAR", "SLASH", "MOD", "EXCLAMATION", "QUESTION", "DOT", "NEQ", "PLUS_EQUALS",
		"MINUS_EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "MOD_EQUALS", "CARET_EQUALS",
		"PIPE", "AMP", "CARET", "LSHIFT", "RSHIFT", "HEX_LITERAL", "BINARY_LITERAL",
		"OCTAL_LITERAL", "FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"DOUBLE_QUOTE_START", "MULTI_DOUBLE_QUOTE_START", "SINGLE_STR_INTERP_START",
		"SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START", "MULTI_STR_CONTENT",
		"MULTI_STR_END", "DOUBLE_STR_INTERP_START", "DOUBLE_STR_CONTENT", "DOUBLE_STR_END",
		"MULTI_DOUBLE_STR_INTERP_START", "MULTI_DOUBLE_STR_CONTENT", "MULTI_DOUBLE_STR_END",
		"INTERP_LBRACE", "INTERP_RBRACE", "INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "programItem", "importStmt", "moduleDecl", "importItem",
		"importStr", "externStmt", "exportStmt", "letDecl", "letSingle", "letBlockItem",
		"letBlock", "letDestructuredObj", "letDestructuredArray", "namedID",
		"typedID", "typedIDList", "typeList", "fnDecl", "fnSignature", "parameters",
		"param", "typeDecl", "typeDefBody", "typeAlias", "fieldDecl", "interfaceDecl",
		"interfaceMethod", "methodsDecl", "methodImpl", "typeAnnotation", "tupleType",
		"stmt", "returnStmt", "yieldStmt", "deferStmt", "exprList", "ifStmt",
		"forStmt", "forLoopType", "forTrinity", "whileStmt", "loopBody", "codeBlock",
		"expr", "assignmentExpr", "ternaryExpr", "logicalOrExpr", "logicalAndExpr",
		"bitwiseOrExpr", "bitwiseXorExpr", "bitwiseAndExpr", "equalityExpr",
		"comparisonExpr", "shiftExpr", "additiveExpr", "multiplicativeExpr",
		"unaryExpr", "awaitExpr", "postfixExpr", "primaryExpr", "fnExpr", "matchExpr",
		"caseClause", "defaultClause", "singleQuotedString", "multiQuotedString",
		"doubleQuotedString", "multiDoubleQuotedString", "stringPart", "interpolation",
		"literal", "stringLiteral", "numberLiteral", "booleanLiteral", "arrayLiteral",
		"objectLiteral", "objectFieldName", "objectField", "mapLiteral", "mapField",
		"setLiteral", "breakStmt", "continueStmt", "checkStmt", "taggedBlockString",
		"structInitExpr", "structField",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 102, 920, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 1, 0, 5, 0, 178, 8,
		0, 10, 0, 12, 0, 181, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 3, 1, 193, 8, 1, 1, 1, 3, 1, 196, 8, 1, 1, 2, 1, 2, 1, 2,
		1, 3, 1, 3, 1, 3, 1, 3, 5, 3, 205, 8, 3, 10, 3, 12, 3, 208, 9, 3, 1, 3,
		3, 3, 211, 8, 3, 3, 3, 213, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3,
		3, 221, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 226, 8, 4, 1, 5, 1, 5, 1, 6, 1, 6,
		1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 238, 8, 7, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 3, 8, 245, 8, 8, 1, 9, 1, 9, 1, 9, 3, 9, 250, 8, 9, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 268, 8, 10, 1, 11, 1, 11, 1, 11,
		5, 11, 273, 8, 11, 10, 11, 12, 11, 276, 9, 11, 3, 11, 278, 8, 11, 1, 11,
		1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 3, 15, 298, 8, 15, 1, 16,
		1, 16, 1, 16, 5, 16, 303, 8, 16, 10, 16, 12, 16, 306, 9, 16, 1, 16, 3,
		16, 309, 8, 16, 1, 17, 1, 17, 1, 17, 5, 17, 314, 8, 17, 10, 17, 12, 17,
		317, 9, 17, 1, 17, 3, 17, 320, 8, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19,
		1, 19, 1, 19, 3, 19, 329, 8, 19, 1, 19, 1, 19, 3, 19, 333, 8, 19, 1, 19,
		3, 19, 336, 8, 19, 1, 20, 1, 20, 1, 20, 5, 20, 341, 8, 20, 10, 20, 12,
		20, 344, 9, 20, 1, 20, 3, 20, 347, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3,
		21, 353, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 359, 8, 22, 1, 23, 1,
		23, 3, 23, 363, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 369, 8, 23, 10,
		23, 12, 23, 372, 9, 23, 1, 23, 3, 23, 375, 8, 23, 3, 23, 377, 8, 23, 1,
		23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 385, 8, 24, 1, 25, 1, 25,
		3, 25, 389, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 3, 26, 397,
		8, 26, 1, 26, 1, 26, 4, 26, 401, 8, 26, 11, 26, 12, 26, 402, 1, 26, 1,
		26, 1, 27, 1, 27, 1, 27, 3, 27, 410, 8, 27, 1, 27, 1, 27, 3, 27, 414, 8,
		27, 1, 27, 3, 27, 417, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28,
		5, 28, 425, 8, 28, 10, 28, 12, 28, 428, 9, 28, 1, 28, 1, 28, 1, 29, 1,
		29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 439, 8, 30, 1, 30, 3, 30,
		442, 8, 30, 1, 30, 1, 30, 3, 30, 446, 8, 30, 1, 31, 1, 31, 3, 31, 450,
		8, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 466, 8, 32, 1, 32, 3, 32, 469, 8,
		32, 1, 32, 3, 32, 472, 8, 32, 1, 33, 1, 33, 3, 33, 476, 8, 33, 1, 34, 1,
		34, 3, 34, 480, 8, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 5, 36,
		488, 8, 36, 10, 36, 12, 36, 491, 9, 36, 1, 36, 3, 36, 494, 8, 36, 1, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 501, 8, 37, 1, 38, 1, 38, 1, 38, 1,
		39, 1, 39, 1, 39, 1, 39, 3, 39, 510, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39,
		3, 39, 516, 8, 39, 1, 40, 1, 40, 3, 40, 520, 8, 40, 1, 40, 1, 40, 3, 40,
		524, 8, 40, 1, 40, 1, 40, 3, 40, 528, 8, 40, 1, 40, 1, 40, 1, 41, 1, 41,
		1, 41, 1, 41, 1, 42, 1, 42, 5, 42, 538, 8, 42, 10, 42, 12, 42, 541, 9,
		42, 1, 42, 1, 42, 1, 43, 1, 43, 5, 43, 547, 8, 43, 10, 43, 12, 43, 550,
		9, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 3, 45, 559, 8,
		45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 567, 8, 46, 1, 47,
		1, 47, 1, 47, 5, 47, 572, 8, 47, 10, 47, 12, 47, 575, 9, 47, 1, 48, 1,
		48, 1, 48, 5, 48, 580, 8, 48, 10, 48, 12, 48, 583, 9, 48, 1, 49, 1, 49,
		1, 49, 5, 49, 588, 8, 49, 10, 49, 12, 49, 591, 9, 49, 1, 50, 1, 50, 1,
		50, 5, 50, 596, 8, 50, 10, 50, 12, 50, 599, 9, 50, 1, 51, 1, 51, 1, 51,
		5, 51, 604, 8, 51, 10, 51, 12, 51, 607, 9, 51, 1, 52, 1, 52, 1, 52, 5,
		52, 612, 8, 52, 10, 52, 12, 52, 615, 9, 52, 1, 53, 1, 53, 1, 53, 5, 53,
		620, 8, 53, 10, 53, 12, 53, 623, 9, 53, 1, 54, 1, 54, 1, 54, 5, 54, 628,
		8, 54, 10, 54, 12, 54, 631, 9, 54, 1, 55, 1, 55, 1, 55, 5, 55, 636, 8,
		55, 10, 55, 12, 55, 639, 9, 55, 1, 56, 1, 56, 1, 56, 5, 56, 644, 8, 56,
		10, 56, 12, 56, 647, 9, 56, 1, 57, 1, 57, 1, 57, 3, 57, 652, 8, 57, 1,
		58, 3, 58, 655, 8, 58, 1, 58, 3, 58, 658, 8, 58, 1, 58, 3, 58, 661, 8,
		58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 3, 59, 668, 8, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 677, 8, 59, 10, 59, 12, 59, 680,
		9, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 698, 8, 60, 1, 61,
		1, 61, 1, 61, 3, 61, 703, 8, 61, 1, 61, 1, 61, 3, 61, 707, 8, 61, 1, 61,
		1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 715, 8, 62, 10, 62, 12, 62, 718,
		9, 62, 1, 62, 3, 62, 721, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1,
		63, 3, 63, 729, 8, 63, 1, 63, 3, 63, 732, 8, 63, 1, 64, 1, 64, 1, 64, 1,
		64, 3, 64, 738, 8, 64, 1, 64, 3, 64, 741, 8, 64, 1, 65, 1, 65, 5, 65, 745,
		8, 65, 10, 65, 12, 65, 748, 9, 65, 1, 65, 1, 65, 1, 66, 1, 66, 5, 66, 754,
		8, 66, 10, 66, 12, 66, 757, 9, 66, 1, 66, 1, 66, 1, 67, 1, 67, 5, 67, 763,
		8, 67, 10, 67, 12, 67, 766, 9, 67, 1, 67, 1, 67, 1, 68, 1, 68, 5, 68, 772,
		8, 68, 10, 68, 12, 68, 775, 9, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 1,
		69, 1, 69, 3, 69, 784, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71,
		1, 71, 1, 71, 1, 71, 3, 71, 795, 8, 71, 1, 72, 1, 72, 1, 72, 1, 72, 3,
		72, 801, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 3, 73, 808, 8, 73, 1,
		74, 1, 74, 1, 75, 1, 75, 3, 75, 814, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76,
		1, 76, 1, 76, 5, 76, 822, 8, 76, 10, 76, 12, 76, 825, 9, 76, 1, 76, 3,
		76, 828, 8, 76, 3, 76, 830, 8, 76, 1, 76, 1, 76, 1, 77, 1, 77, 3, 77, 836,
		8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 841, 8, 78, 1, 79, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 5, 79, 850, 8, 79, 10, 79, 12, 79, 853, 9, 79,
		1, 79, 3, 79, 856, 8, 79, 3, 79, 858, 8, 79, 1, 79, 3, 79, 861, 8, 79,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 871, 8,
		81, 10, 81, 12, 81, 874, 9, 81, 1, 81, 3, 81, 877, 8, 81, 3, 81, 879, 8,
		81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84,
		1, 84, 3, 84, 892, 8, 84, 1, 85, 1, 85, 1, 85, 3, 85, 897, 8, 85, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 904, 8, 86, 10, 86, 12, 86, 907, 9,
		86, 1, 86, 3, 86, 910, 8, 86, 3, 86, 912, 8, 86, 1, 86, 1, 86, 1, 87, 1,
		87, 1, 87, 1, 87, 1, 87, 0, 0, 88, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
		154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 0, 9, 2, 0, 52,
		52, 67, 72, 2, 0, 53, 53, 66, 66, 1, 0, 45, 48, 1, 0, 76, 77, 1, 0, 54,
		55, 1, 0, 60, 62, 3, 0, 15, 15, 54, 55, 63, 63, 4, 0, 88, 88, 91, 91, 94,
		94, 97, 97, 1, 0, 27, 28, 989, 0, 179, 1, 0, 0, 0, 2, 192, 1, 0, 0, 0,
		4, 197, 1, 0, 0, 0, 6, 220, 1, 0, 0, 0, 8, 222, 1, 0, 0, 0, 10, 227, 1,
		0, 0, 0, 12, 229, 1, 0, 0, 0, 14, 232, 1, 0, 0, 0, 16, 239, 1, 0, 0, 0,
		18, 246, 1, 0, 0, 0, 20, 267, 1, 0, 0, 0, 22, 269, 1, 0, 0, 0, 24, 281,
		1, 0, 0, 0, 26, 287, 1, 0, 0, 0, 28, 293, 1, 0, 0, 0, 30, 295, 1, 0, 0,
		0, 32, 299, 1, 0, 0, 0, 34, 310, 1, 0, 0, 0, 36, 321, 1, 0, 0, 0, 38, 324,
		1, 0, 0, 0, 40, 337, 1, 0, 0, 0, 42, 348, 1, 0, 0, 0, 44, 354, 1, 0, 0,
		0, 46, 362, 1, 0, 0, 0, 48, 380, 1, 0, 0, 0, 50, 386, 1, 0, 0, 0, 52, 392,
		1, 0, 0, 0, 54, 406, 1, 0, 0, 0, 56, 418, 1, 0, 0, 0, 58, 431, 1, 0, 0,
		0, 60, 438, 1, 0, 0, 0, 62, 447, 1, 0, 0, 0, 64, 471, 1, 0, 0, 0, 66, 473,
		1, 0, 0, 0, 68, 477, 1, 0, 0, 0, 70, 481, 1, 0, 0, 0, 72, 484, 1, 0, 0,
		0, 74, 495, 1, 0, 0, 0, 76, 502, 1, 0, 0, 0, 78, 515, 1, 0, 0, 0, 80, 519,
		1, 0, 0, 0, 82, 531, 1, 0, 0, 0, 84, 535, 1, 0, 0, 0, 86, 544, 1, 0, 0,
		0, 88, 553, 1, 0, 0, 0, 90, 555, 1, 0, 0, 0, 92, 560, 1, 0, 0, 0, 94, 568,
		1, 0, 0, 0, 96, 576, 1, 0, 0, 0, 98, 584, 1, 0, 0, 0, 100, 592, 1, 0, 0,
		0, 102, 600, 1, 0, 0, 0, 104, 608, 1, 0, 0, 0, 106, 616, 1, 0, 0, 0, 108,
		624, 1, 0, 0, 0, 110, 632, 1, 0, 0, 0, 112, 640, 1, 0, 0, 0, 114, 651,
		1, 0, 0, 0, 116, 654, 1, 0, 0, 0, 118, 664, 1, 0, 0, 0, 120, 697, 1, 0,
		0, 0, 122, 699, 1, 0, 0, 0, 124, 710, 1, 0, 0, 0, 126, 724, 1, 0, 0, 0,
		128, 733, 1, 0, 0, 0, 130, 742, 1, 0, 0, 0, 132, 751, 1, 0, 0, 0, 134,
		760, 1, 0, 0, 0, 136, 769, 1, 0, 0, 0, 138, 783, 1, 0, 0, 0, 140, 785,
		1, 0, 0, 0, 142, 794, 1, 0, 0, 0, 144, 800, 1, 0, 0, 0, 146, 807, 1, 0,
		0, 0, 148, 809, 1, 0, 0, 0, 150, 811, 1, 0, 0, 0, 152, 817, 1, 0, 0, 0,
		154, 835, 1, 0, 0, 0, 156, 837, 1, 0, 0, 0, 158, 860, 1, 0, 0, 0, 160,
		862, 1, 0, 0, 0, 162, 866, 1, 0, 0, 0, 164, 882, 1, 0, 0, 0, 166, 884,
		1, 0, 0, 0, 168, 886, 1, 0, 0, 0, 170, 893, 1, 0, 0, 0, 172, 898, 1, 0,
		0, 0, 174, 915, 1, 0, 0, 0, 176, 178, 3, 2, 1, 0, 177, 176, 1, 0, 0, 0,
		178, 181, 1, 0, 0, 0, 179, 177, 1, 0, 0, 0, 179, 180, 1, 0, 0, 0, 180,
		182, 1, 0, 0, 0, 181, 179, 1, 0, 0, 0, 182, 183, 5, 0, 0, 1, 183, 1, 1,
		0, 0, 0, 184, 193, 3, 4, 2, 0, 185, 193, 3, 14, 7, 0, 186, 193, 3, 12,
		6, 0, 187, 193, 3, 16, 8, 0, 188, 193, 3, 44, 22, 0, 189, 193, 3, 52, 26,
		0, 190, 193, 3, 36, 18, 0, 191, 193, 3, 56, 28, 0, 192, 184, 1, 0, 0, 0,
		192, 185, 1, 0, 0, 0, 192, 186, 1, 0, 0, 0, 192, 187, 1, 0, 0, 0, 192,
		188, 1, 0, 0, 0, 192, 189, 1, 0, 0, 0, 192, 190, 1, 0, 0, 0, 192, 191,
		1, 0, 0, 0, 193, 195, 1, 0, 0, 0, 194, 196, 5, 50, 0, 0, 195, 194, 1, 0,
		0, 0, 195, 196, 1, 0, 0, 0, 196, 3, 1, 0, 0, 0, 197, 198, 5, 10, 0, 0,
		198, 199, 3, 6, 3, 0, 199, 5, 1, 0, 0, 0, 200, 212, 5, 39, 0, 0, 201, 206,
		3, 8, 4, 0, 202, 203, 5, 51, 0, 0, 203, 205, 3, 8, 4, 0, 204, 202, 1, 0,
		0, 0, 205, 208, 1, 0, 0, 0, 206, 204, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0,
		207, 210, 1, 0, 0, 0, 208, 206, 1, 0, 0, 0, 209, 211, 5, 51, 0, 0, 210,
		209, 1, 0, 0, 0, 210, 211, 1, 0, 0, 0, 211, 213, 1, 0, 0, 0, 212, 201,
		1, 0, 0, 0, 212, 213, 1, 0, 0, 0, 213, 214, 1, 0, 0, 0, 214, 215, 5, 40,
		0, 0, 215, 216, 5, 21, 0, 0, 216, 221, 3, 10, 5, 0, 217, 218, 5, 83, 0,
		0, 218, 219, 5, 21, 0, 0, 219, 221, 3, 10, 5, 0, 220, 200, 1, 0, 0, 0,
		220, 217, 1, 0, 0, 0, 221, 7, 1, 0, 0, 0, 222, 225, 5, 83, 0, 0, 223, 224,
		5, 18, 0, 0, 224, 226, 5, 83, 0, 0, 225, 223, 1, 0, 0, 0, 225, 226, 1,
		0, 0, 0, 226, 9, 1, 0, 0, 0, 227, 228, 3, 130, 65, 0, 228, 11, 1, 0, 0,
		0, 229, 230, 5, 12, 0, 0, 230, 231, 3, 6, 3, 0, 231, 13, 1, 0, 0, 0, 232,
		237, 5, 11, 0, 0, 233, 238, 3, 36, 18, 0, 234, 238, 3, 16, 8, 0, 235, 238,
		3, 44, 22, 0, 236, 238, 3, 52, 26, 0, 237, 233, 1, 0, 0, 0, 237, 234, 1,
		0, 0, 0, 237, 235, 1, 0, 0, 0, 237, 236, 1, 0, 0, 0, 238, 15, 1, 0, 0,
		0, 239, 244, 5, 4, 0, 0, 240, 245, 3, 18, 9, 0, 241, 245, 3, 22, 11, 0,
		242, 245, 3, 24, 12, 0, 243, 245, 3, 26, 13, 0, 244, 240, 1, 0, 0, 0, 244,
		241, 1, 0, 0, 0, 244, 242, 1, 0, 0, 0, 244, 243, 1, 0, 0, 0, 245, 17, 1,
		0, 0, 0, 246, 249, 3, 30, 15, 0, 247, 248, 5, 52, 0, 0, 248, 250, 3, 88,
		44, 0, 249, 247, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 19, 1, 0, 0, 0,
		251, 252, 3, 30, 15, 0, 252, 253, 5, 52, 0, 0, 253, 254, 3, 88, 44, 0,
		254, 268, 1, 0, 0, 0, 255, 256, 5, 39, 0, 0, 256, 257, 3, 32, 16, 0, 257,
		258, 5, 40, 0, 0, 258, 259, 5, 52, 0, 0, 259, 260, 3, 88, 44, 0, 260, 268,
		1, 0, 0, 0, 261, 262, 5, 41, 0, 0, 262, 263, 3, 32, 16, 0, 263, 264, 5,
		42, 0, 0, 264, 265, 5, 52, 0, 0, 265, 266, 3, 88, 44, 0, 266, 268, 1, 0,
		0, 0, 267, 251, 1, 0, 0, 0, 267, 255, 1, 0, 0, 0, 267, 261, 1, 0, 0, 0,
		268, 21, 1, 0, 0, 0, 269, 277, 5, 43, 0, 0, 270, 274, 3, 20, 10, 0, 271,
		273, 3, 20, 10, 0, 272, 271, 1, 0, 0, 0, 273, 276, 1, 0, 0, 0, 274, 272,
		1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275, 278, 1, 0, 0, 0, 276, 274, 1, 0,
		0, 0, 277, 270, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0,
		279, 280, 5, 44, 0, 0, 280, 23, 1, 0, 0, 0, 281, 282, 5, 39, 0, 0, 282,
		283, 3, 32, 16, 0, 283, 284, 5, 40, 0, 0, 284, 285, 5, 52, 0, 0, 285, 286,
		3, 88, 44, 0, 286, 25, 1, 0, 0, 0, 287, 288, 5, 41, 0, 0, 288, 289, 3,
		32, 16, 0, 289, 290, 5, 42, 0, 0, 290, 291, 5, 52, 0, 0, 291, 292, 3, 88,
		44, 0, 292, 27, 1, 0, 0, 0, 293, 294, 5, 83, 0, 0, 294, 29, 1, 0, 0, 0,
		295, 297, 3, 28, 14, 0, 296, 298, 3, 60, 30, 0, 297, 296, 1, 0, 0, 0, 297,
		298, 1, 0, 0, 0, 298, 31, 1, 0, 0, 0, 299, 304, 3, 30, 15, 0, 300, 301,
		5, 51, 0, 0, 301, 303, 3, 30, 15, 0, 302, 300, 1, 0, 0, 0, 303, 306, 1,
		0, 0, 0, 304, 302, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 308, 1, 0, 0,
		0, 306, 304, 1, 0, 0, 0, 307, 309, 5, 51, 0, 0, 308, 307, 1, 0, 0, 0, 308,
		309, 1, 0, 0, 0, 309, 33, 1, 0, 0, 0, 310, 315, 3, 60, 30, 0, 311, 312,
		5, 51, 0, 0, 312, 314, 3, 60, 30, 0, 313, 311, 1, 0, 0, 0, 314, 317, 1,
		0, 0, 0, 315, 313, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316, 319, 1, 0, 0,
		0, 317, 315, 1, 0, 0, 0, 318, 320, 5, 51, 0, 0, 319, 318, 1, 0, 0, 0, 319,
		320, 1, 0, 0, 0, 320, 35, 1, 0, 0, 0, 321, 322, 3, 38, 19, 0, 322, 323,
		3, 86, 43, 0, 323, 37, 1, 0, 0, 0, 324, 325, 5, 5, 0, 0, 325, 326, 3, 28,
		14, 0, 326, 328, 5, 43, 0, 0, 327, 329, 3, 40, 20, 0, 328, 327, 1, 0, 0,
		0, 328, 329, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330, 332, 5, 44, 0, 0, 331,
		333, 3, 60, 30, 0, 332, 331, 1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333, 335,
		1, 0, 0, 0, 334, 336, 5, 63, 0, 0, 335, 334, 1, 0, 0, 0, 335, 336, 1, 0,
		0, 0, 336, 39, 1, 0, 0, 0, 337, 342, 3, 42, 21, 0, 338, 339, 5, 51, 0,
		0, 339, 341, 3, 42, 21, 0, 340, 338, 1, 0, 0, 0, 341, 344, 1, 0, 0, 0,
		342, 340, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 346, 1, 0, 0, 0, 344,
		342, 1, 0, 0, 0, 345, 347, 5, 51, 0, 0, 346, 345, 1, 0, 0, 0, 346, 347,
		1, 0, 0, 0, 347, 41, 1, 0, 0, 0, 348, 349, 3, 28, 14, 0, 349, 352, 3, 60,
		30, 0, 350, 351, 5, 52, 0, 0, 351, 353, 3, 88, 44, 0, 352, 350, 1, 0, 0,
		0, 352, 353, 1, 0, 0, 0, 353, 43, 1, 0, 0, 0, 354, 355, 5, 8, 0, 0, 355,
		358, 3, 28, 14, 0, 356, 359, 3, 46, 23, 0, 357, 359, 3, 48, 24, 0, 358,
		356, 1, 0, 0, 0, 358, 357, 1, 0, 0, 0, 359, 45, 1, 0, 0, 0, 360, 361, 5,
		20, 0, 0, 361, 363, 3, 34, 17, 0, 362, 360, 1, 0, 0, 0, 362, 363, 1, 0,
		0, 0, 363, 364, 1, 0, 0, 0, 364, 376, 5, 39, 0, 0, 365, 370, 3, 50, 25,
		0, 366, 367, 5, 51, 0, 0, 367, 369, 3, 50, 25, 0, 368, 366, 1, 0, 0, 0,
		369, 372, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371,
		374, 1, 0, 0, 0, 372, 370, 1, 0, 0, 0, 373, 375, 5, 51, 0, 0, 374, 373,
		1, 0, 0, 0, 374, 375, 1, 0, 0, 0, 375, 377, 1, 0, 0, 0, 376, 365, 1, 0,
		0, 0, 376, 377, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379, 5, 40, 0, 0,
		379, 47, 1, 0, 0, 0, 380, 381, 5, 52, 0, 0, 381, 384, 3, 60, 30, 0, 382,
		383, 5, 20, 0, 0, 383, 385, 3, 34, 17, 0, 384, 382, 1, 0, 0, 0, 384, 385,
		1, 0, 0, 0, 385, 49, 1, 0, 0, 0, 386, 388, 3, 28, 14, 0, 387, 389, 5, 64,
		0, 0, 388, 387, 1, 0, 0, 0, 388, 389, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0,
		390, 391, 3, 60, 30, 0, 391, 51, 1, 0, 0, 0, 392, 393, 5, 9, 0, 0, 393,
		396, 3, 28, 14, 0, 394, 395, 5, 20, 0, 0, 395, 397, 3, 34, 17, 0, 396,
		394, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 400,
		5, 39, 0, 0, 399, 401, 3, 54, 27, 0, 400, 399, 1, 0, 0, 0, 401, 402, 1,
		0, 0, 0, 402, 400, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 404, 1, 0, 0,
		0, 404, 405, 5, 40, 0, 0, 405, 53, 1, 0, 0, 0, 406, 407, 3, 28, 14, 0,
		407, 409, 5, 43, 0, 0, 408, 410, 3, 40, 20, 0, 409, 408, 1, 0, 0, 0, 409,
		410, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 413, 5, 44, 0, 0, 412, 414,
		3, 60, 30, 0, 413, 412, 1, 0, 0, 0, 413, 414, 1, 0, 0, 0, 414, 416, 1,
		0, 0, 0, 415, 417, 5, 63, 0, 0, 416, 415, 1, 0, 0, 0, 416, 417, 1, 0, 0,
		0, 417, 55, 1, 0, 0, 0, 418, 419, 5, 33, 0, 0, 419, 420, 5, 83, 0, 0, 420,
		421, 5, 18, 0, 0, 421, 422, 5, 83, 0, 0, 422, 426, 5, 39, 0, 0, 423, 425,
		3, 58, 29, 0, 424, 423, 1, 0, 0, 0, 425, 428, 1, 0, 0, 0, 426, 424, 1,
		0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 1, 0, 0, 0, 428, 426, 1, 0, 0,
		0, 429, 430, 5, 40, 0, 0, 430, 57, 1, 0, 0, 0, 431, 432, 3, 54, 27, 0,
		432, 433, 3, 86, 43, 0, 433, 59, 1, 0, 0, 0, 434, 439, 5, 83, 0, 0, 435,
		439, 3, 62, 31, 0, 436, 439, 3, 38, 19, 0, 437, 439, 5, 13, 0, 0, 438,
		434, 1, 0, 0, 0, 438, 435, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 438, 437,
		1, 0, 0, 0, 439, 441, 1, 0, 0, 0, 440, 442, 5, 64, 0, 0, 441, 440, 1, 0,
		0, 0, 441, 442, 1, 0, 0, 0, 442, 445, 1, 0, 0, 0, 443, 444, 5, 41, 0, 0,
		444, 446, 5, 42, 0, 0, 445, 443, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446,
		61, 1, 0, 0, 0, 447, 449, 5, 43, 0, 0, 448, 450, 3, 34, 17, 0, 449, 448,
		1, 0, 0, 0, 449, 450, 1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 5, 44,
		0, 0, 452, 63, 1, 0, 0, 0, 453, 466, 3, 16, 8, 0, 454, 466, 3, 88, 44,
		0, 455, 466, 3, 66, 33, 0, 456, 466, 3, 68, 34, 0, 457, 466, 3, 74, 37,
		0, 458, 466, 3, 76, 38, 0, 459, 466, 3, 82, 41, 0, 460, 466, 3, 86, 43,
		0, 461, 466, 3, 164, 82, 0, 462, 466, 3, 166, 83, 0, 463, 466, 3, 168,
		84, 0, 464, 466, 3, 70, 35, 0, 465, 453, 1, 0, 0, 0, 465, 454, 1, 0, 0,
		0, 465, 455, 1, 0, 0, 0, 465, 456, 1, 0, 0, 0, 465, 457, 1, 0, 0, 0, 465,
		458, 1, 0, 0, 0, 465, 459, 1, 0, 0, 0, 465, 460, 1, 0, 0, 0, 465, 461,
		1, 0, 0, 0, 465, 462, 1, 0, 0, 0, 465, 463, 1, 0, 0, 0, 465, 464, 1, 0,
		0, 0, 466, 468, 1, 0, 0, 0, 467, 469, 5, 50, 0, 0, 468, 467, 1, 0, 0, 0,
		468, 469, 1, 0, 0, 0, 469, 472, 1, 0, 0, 0, 470, 472, 5, 50, 0, 0, 471,
		465, 1, 0, 0, 0, 471, 470, 1, 0, 0, 0, 472, 65, 1, 0, 0, 0, 473, 475, 5,
		6, 0, 0, 474, 476, 3, 72, 36, 0, 475, 474, 1, 0, 0, 0, 475, 476, 1, 0,
		0, 0, 476, 67, 1, 0, 0, 0, 477, 479, 5, 7, 0, 0, 478, 480, 3, 72, 36, 0,
		479, 478, 1, 0, 0, 0, 479, 480, 1, 0, 0, 0, 480, 69, 1, 0, 0, 0, 481, 482,
		5, 37, 0, 0, 482, 483, 3, 88, 44, 0, 483, 71, 1, 0, 0, 0, 484, 489, 3,
		88, 44, 0, 485, 486, 5, 51, 0, 0, 486, 488, 3, 88, 44, 0, 487, 485, 1,
		0, 0, 0, 488, 491, 1, 0, 0, 0, 489, 487, 1, 0, 0, 0, 489, 490, 1, 0, 0,
		0, 490, 493, 1, 0, 0, 0, 491, 489, 1, 0, 0, 0, 492, 494, 5, 51, 0, 0, 493,
		492, 1, 0, 0, 0, 493, 494, 1, 0, 0, 0, 494, 73, 1, 0, 0, 0, 495, 496, 5,
		23, 0, 0, 496, 497, 3, 88, 44, 0, 497, 500, 3, 86, 43, 0, 498, 499, 5,
		24, 0, 0, 499, 501, 3, 86, 43, 0, 500, 498, 1, 0, 0, 0, 500, 501, 1, 0,
		0, 0, 501, 75, 1, 0, 0, 0, 502, 503, 5, 25, 0, 0, 503, 504, 3, 78, 39,
		0, 504, 77, 1, 0, 0, 0, 505, 516, 3, 80, 40, 0, 506, 509, 5, 83, 0, 0,
		507, 508, 5, 51, 0, 0, 508, 510, 5, 83, 0, 0, 509, 507, 1, 0, 0, 0, 509,
		510, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 512, 5, 17, 0, 0, 512, 513,
		3, 88, 44, 0, 513, 514, 3, 84, 42, 0, 514, 516, 1, 0, 0, 0, 515, 505, 1,
		0, 0, 0, 515, 506, 1, 0, 0, 0, 516, 79, 1, 0, 0, 0, 517, 520, 3, 18, 9,
		0, 518, 520, 3, 72, 36, 0, 519, 517, 1, 0, 0, 0, 519, 518, 1, 0, 0, 0,
		519, 520, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 523, 5, 50, 0, 0, 522,
		524, 3, 88, 44, 0, 523, 522, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 525,
		1, 0, 0, 0, 525, 527, 5, 50, 0, 0, 526, 528, 3, 72, 36, 0, 527, 526, 1,
		0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530, 3, 84, 42,
		0, 530, 81, 1, 0, 0, 0, 531, 532, 5, 26, 0, 0, 532, 533, 3, 88, 44, 0,
		533, 534, 3, 84, 42, 0, 534, 83, 1, 0, 0, 0, 535, 539, 5, 39, 0, 0, 536,
		538, 3, 64, 32, 0, 537, 536, 1, 0, 0, 0, 538, 541, 1, 0, 0, 0, 539, 537,
		1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 542, 1, 0, 0, 0, 541, 539, 1, 0,
		0, 0, 542, 543, 5, 40, 0, 0, 543, 85, 1, 0, 0, 0, 544, 548, 5, 39, 0, 0,
		545, 547, 3, 64, 32, 0, 546, 545, 1, 0, 0, 0, 547, 550, 1, 0, 0, 0, 548,
		546, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550, 548,
		1, 0, 0, 0, 551, 552, 5, 40, 0, 0, 552, 87, 1, 0, 0, 0, 553, 554, 3, 90,
		45, 0, 554, 89, 1, 0, 0, 0, 555, 558, 3, 92, 46, 0, 556, 557, 7, 0, 0,
		0, 557, 559, 3, 90, 45, 0, 558, 556, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0,
		559, 91, 1, 0, 0, 0, 560, 566, 3, 94, 47, 0, 561, 562, 5, 64, 0, 0, 562,
		563, 3, 88, 44, 0, 563, 564, 5, 49, 0, 0, 564, 565, 3, 92, 46, 0, 565,
		567, 1, 0, 0, 0, 566, 561, 1, 0, 0, 0, 566, 567, 1, 0, 0, 0, 567, 93, 1,
		0, 0, 0, 568, 573, 3, 96, 48, 0, 569, 570, 5, 58, 0, 0, 570, 572, 3, 96,
		48, 0, 571, 569, 1, 0, 0, 0, 572, 575, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0,
		573, 574, 1, 0, 0, 0, 574, 95, 1, 0, 0, 0, 575, 573, 1, 0, 0, 0, 576, 581,
		3, 98, 49, 0, 577, 578, 5, 59, 0, 0, 578, 580, 3, 98, 49, 0, 579, 577,
		1, 0, 0, 0, 580, 583, 1, 0, 0, 0, 581, 579, 1, 0, 0, 0, 581, 582, 1, 0,
		0, 0, 582, 97, 1, 0, 0, 0, 583, 581, 1, 0, 0, 0, 584, 589, 3, 100, 50,
		0, 585, 586, 5, 73, 0, 0, 586, 588, 3, 100, 50, 0, 587, 585, 1, 0, 0, 0,
		588, 591, 1, 0, 0, 0, 589, 587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590,
		99, 1, 0, 0, 0, 591, 589, 1, 0, 0, 0, 592, 597, 3, 102, 51, 0, 593, 594,
		5, 75, 0, 0, 594, 596, 3, 102, 51, 0, 595, 593, 1, 0, 0, 0, 596, 599, 1,
		0, 0, 0, 597, 595, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 101, 1, 0, 0,
		0, 599, 597, 1, 0, 0, 0, 600, 605, 3, 104, 52, 0, 601, 602, 5, 74, 0, 0,
		602, 604, 3, 104, 52, 0, 603, 601, 1, 0, 0, 0, 604, 607, 1, 0, 0, 0, 605,
		603, 1, 0, 0, 0, 605, 606, 1, 0, 0, 0, 606, 103, 1, 0, 0, 0, 607, 605,
		1, 0, 0, 0, 608, 613, 3, 106, 53, 0, 609, 610, 7, 1, 0, 0, 610, 612, 3,
		106, 53, 0, 611, 609, 1, 0, 0, 0, 612, 615, 1, 0, 0, 0, 613, 611, 1, 0,
		0, 0, 613, 614, 1, 0, 0, 0, 614, 105, 1, 0, 0, 0, 615, 613, 1, 0, 0, 0,
		616, 621, 3, 108, 54, 0, 617, 618, 7, 2, 0, 0, 618, 620, 3, 108, 54, 0,
		619, 617, 1, 0, 0, 0, 620, 623, 1, 0, 0, 0, 621, 619, 1, 0, 0, 0, 621,
		622, 1, 0, 0, 0, 622, 107, 1, 0, 0, 0, 623, 621, 1, 0, 0, 0, 624, 629,
		3, 110, 55, 0, 625, 626, 7, 3, 0, 0, 626, 628, 3, 110, 55, 0, 627, 625,
		1, 0, 0, 0, 628, 631, 1, 0, 0, 0, 629, 627, 1, 0, 0, 0, 629, 630, 1, 0,
		0, 0, 630, 109, 1, 0, 0, 0, 631, 629, 1, 0, 0, 0, 632, 637, 3, 112, 56,
		0, 633, 634, 7, 4, 0, 0, 634, 636, 3, 112, 56, 0, 635, 633, 1, 0, 0, 0,
		636, 639, 1, 0, 0, 0, 637, 635, 1, 0, 0, 0, 637, 638, 1, 0, 0, 0, 638,
		111, 1, 0, 0, 0, 639, 637, 1, 0, 0, 0, 640, 645, 3, 114, 57, 0, 641, 642,
		7, 5, 0, 0, 642, 644, 3, 114, 57, 0, 643, 641, 1, 0, 0, 0, 644, 647, 1,
		0, 0, 0, 645, 643, 1, 0, 0, 0, 645, 646, 1, 0, 0, 0, 646, 113, 1, 0, 0,
		0, 647, 645, 1, 0, 0, 0, 648, 649, 7, 6, 0, 0, 649, 652, 3, 114, 57, 0,
		650, 652, 3, 116, 58, 0, 651, 648, 1, 0, 0, 0, 651, 650, 1, 0, 0, 0, 652,
		115, 1, 0, 0, 0, 653, 655, 5, 15, 0, 0, 654, 653, 1, 0, 0, 0, 654, 655,
		1, 0, 0, 0, 655, 657, 1, 0, 0, 0, 656, 658, 5, 32, 0, 0, 657, 656, 1, 0,
		0, 0, 657, 658, 1, 0, 0, 0, 658, 660, 1, 0, 0, 0, 659, 661, 5, 31, 0, 0,
		660, 659, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 662, 1, 0, 0, 0, 662,
		663, 3, 118, 59, 0, 663, 117, 1, 0, 0, 0, 664, 678, 3, 120, 60, 0, 665,
		667, 5, 43, 0, 0, 666, 668, 3, 72, 36, 0, 667, 666, 1, 0, 0, 0, 667, 668,
		1, 0, 0, 0, 668, 669, 1, 0, 0, 0, 669, 677, 5, 44, 0, 0, 670, 671, 5, 65,
		0, 0, 671, 677, 5, 83, 0, 0, 672, 673, 5, 41, 0, 0, 673, 674, 3, 88, 44,
		0, 674, 675, 5, 42, 0, 0, 675, 677, 1, 0, 0, 0, 676, 665, 1, 0, 0, 0, 676,
		670, 1, 0, 0, 0, 676, 672, 1, 0, 0, 0, 677, 680, 1, 0, 0, 0, 678, 676,
		1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 119, 1, 0, 0, 0, 680, 678, 1, 0,
		0, 0, 681, 698, 3, 142, 71, 0, 682, 698, 5, 83, 0, 0, 683, 684, 5, 43,
		0, 0, 684, 685, 3, 88, 44, 0, 685, 686, 5, 44, 0, 0, 686, 698, 1, 0, 0,
		0, 687, 698, 3, 150, 75, 0, 688, 698, 3, 152, 76, 0, 689, 698, 3, 158,
		79, 0, 690, 698, 3, 162, 81, 0, 691, 698, 3, 122, 61, 0, 692, 698, 3, 124,
		62, 0, 693, 698, 5, 13, 0, 0, 694, 698, 5, 22, 0, 0, 695, 698, 3, 170,
		85, 0, 696, 698, 3, 172, 86, 0, 697, 681, 1, 0, 0, 0, 697, 682, 1, 0, 0,
		0, 697, 683, 1, 0, 0, 0, 697, 687, 1, 0, 0, 0, 697, 688, 1, 0, 0, 0, 697,
		689, 1, 0, 0, 0, 697, 690, 1, 0, 0, 0, 697, 691, 1, 0, 0, 0, 697, 692,
		1, 0, 0, 0, 697, 693, 1, 0, 0, 0, 697, 694, 1, 0, 0, 0, 697, 695, 1, 0,
		0, 0, 697, 696, 1, 0, 0, 0, 698, 121, 1, 0, 0, 0, 699, 700, 5, 5, 0, 0,
		700, 702, 5, 43, 0, 0, 701, 703, 3, 40, 20, 0, 702, 701, 1, 0, 0, 0, 702,
		703, 1, 0, 0, 0, 703, 704, 1, 0, 0, 0, 704, 706, 5, 44, 0, 0, 705, 707,
		3, 60, 30, 0, 706, 705, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708, 1,
		0, 0, 0, 708, 709, 3, 86, 43, 0, 709, 123, 1, 0, 0, 0, 710, 711, 5, 29,
		0, 0, 711, 712, 3, 88, 44, 0, 712, 716, 5, 39, 0, 0, 713, 715, 3, 126,
		63, 0, 714, 713, 1, 0, 0, 0, 715, 718, 1, 0, 0, 0, 716, 714, 1, 0, 0, 0,
		716, 717, 1, 0, 0, 0, 717, 720, 1, 0, 0, 0, 718, 716, 1, 0, 0, 0, 719,
		721, 3, 128, 64, 0, 720, 719, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 722,
		1, 0, 0, 0, 722, 723, 5, 40, 0, 0, 723, 125, 1, 0, 0, 0, 724, 728, 3, 88,
		44, 0, 725, 726, 5, 49, 0, 0, 726, 729, 3, 88, 44, 0, 727, 729, 3, 86,
		43, 0, 728, 725, 1, 0, 0, 0, 728, 727, 1, 0, 0, 0, 729, 731, 1, 0, 0, 0,
		730, 732, 5, 50, 0, 0, 731, 730, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732,
		127, 1, 0, 0, 0, 733, 737, 5, 36, 0, 0, 734, 735, 5, 49, 0, 0, 735, 738,
		3, 88, 44, 0, 736, 738, 3, 86, 43, 0, 737, 734, 1, 0, 0, 0, 737, 736, 1,
		0, 0, 0, 738, 740, 1, 0, 0, 0, 739, 741, 5, 50, 0, 0, 740, 739, 1, 0, 0,
		0, 740, 741, 1, 0, 0, 0, 741, 129, 1, 0, 0, 0, 742, 746, 5, 84, 0, 0, 743,
		745, 3, 138, 69, 0, 744, 743, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746, 744,
		1, 0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 749, 1, 0, 0, 0, 748, 746, 1, 0,
		0, 0, 749, 750, 5, 90, 0, 0, 750, 131, 1, 0, 0, 0, 751, 755, 5, 85, 0,
		0, 752, 754, 3, 138, 69, 0, 753, 752, 1, 0, 0, 0, 754, 757, 1, 0, 0, 0,
		755, 753, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 758, 1, 0, 0, 0, 757,
		755, 1, 0, 0, 0, 758, 759, 5, 93, 0, 0, 759, 133, 1, 0, 0, 0, 760, 764,
		5, 86, 0, 0, 761, 763, 3, 138, 69, 0, 762, 761, 1, 0, 0, 0, 763, 766, 1,
		0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 767, 1, 0, 0,
		0, 766, 764, 1, 0, 0, 0, 767, 768, 5, 96, 0, 0, 768, 135, 1, 0, 0, 0, 769,
		773, 5, 87, 0, 0, 770, 772, 3, 138, 69, 0, 771, 770, 1, 0, 0, 0, 772, 775,
		1, 0, 0, 0, 773, 771, 1, 0, 0, 0, 773, 774, 1, 0, 0, 0, 774, 776, 1, 0,
		0, 0, 775, 773, 1, 0, 0, 0, 776, 777, 5, 99, 0, 0, 777, 137, 1, 0, 0, 0,
		778, 784, 5, 89, 0, 0, 779, 784, 5, 92, 0, 0, 780, 784, 5, 95, 0, 0, 781,
		784, 5, 98, 0, 0, 782, 784, 3, 140, 70, 0, 783, 778, 1, 0, 0, 0, 783, 779,
		1, 0, 0, 0, 783, 780, 1, 0, 0, 0, 783, 781, 1, 0, 0, 0, 783, 782, 1, 0,
		0, 0, 784, 139, 1, 0, 0, 0, 785, 786, 7, 7, 0, 0, 786, 787, 3, 88, 44,
		0, 787, 788, 5, 101, 0, 0, 788, 141, 1, 0, 0, 0, 789, 795, 3, 144, 72,
		0, 790, 795, 3, 146, 73, 0, 791, 795, 3, 148, 74, 0, 792, 795, 5, 22, 0,
		0, 793, 795, 5, 13, 0, 0, 794, 789, 1, 0, 0, 0, 794, 790, 1, 0, 0, 0, 794,
		791, 1, 0, 0, 0, 794, 792, 1, 0, 0, 0, 794, 793, 1, 0, 0, 0, 795, 143,
		1, 0, 0, 0, 796, 801, 3, 130, 65, 0, 797, 801, 3, 132, 66, 0, 798, 801,
		3, 134, 67, 0, 799, 801, 3, 136, 68, 0, 800, 796, 1, 0, 0, 0, 800, 797,
		1, 0, 0, 0, 800, 798, 1, 0, 0, 0, 800, 799, 1, 0, 0, 0, 801, 145, 1, 0,
		0, 0, 802, 808, 5, 82, 0, 0, 803, 808, 5, 81, 0, 0, 804, 808, 5, 78, 0,
		0, 805, 808, 5, 79, 0, 0, 806, 808, 5, 80, 0, 0, 807, 802, 1, 0, 0, 0,
		807, 803, 1, 0, 0, 0, 807, 804, 1, 0, 0, 0, 807, 805, 1, 0, 0, 0, 807,
		806, 1, 0, 0, 0, 808, 147, 1, 0, 0, 0, 809, 810, 7, 8, 0, 0, 810, 149,
		1, 0, 0, 0, 811, 813, 5, 41, 0, 0, 812, 814, 3, 72, 36, 0, 813, 812, 1,
		0, 0, 0, 813, 814, 1, 0, 0, 0, 814, 815, 1, 0, 0, 0, 815, 816, 5, 42, 0,
		0, 816, 151, 1, 0, 0, 0, 817, 829, 5, 39, 0, 0, 818, 823, 3, 156, 78, 0,
		819, 820, 5, 51, 0, 0, 820, 822, 3, 156, 78, 0, 821, 819, 1, 0, 0, 0, 822,
		825, 1, 0, 0, 0, 823, 821, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 827,
		1, 0, 0, 0, 825, 823, 1, 0, 0, 0, 826, 828, 5, 51, 0, 0, 827, 826, 1, 0,
		0, 0, 827, 828, 1, 0, 0, 0, 828, 830, 1, 0, 0, 0, 829, 818, 1, 0, 0, 0,
		829, 830, 1, 0, 0, 0, 830, 831, 1, 0, 0, 0, 831, 832, 5, 40, 0, 0, 832,
		153, 1, 0, 0, 0, 833, 836, 5, 83, 0, 0, 834, 836, 3, 144, 72, 0, 835, 833,
		1, 0, 0, 0, 835, 834, 1, 0, 0, 0, 836, 155, 1, 0, 0, 0, 837, 840, 3, 154,
		77, 0, 838, 839, 5, 49, 0, 0, 839, 841, 3, 88, 44, 0, 840, 838, 1, 0, 0,
		0, 840, 841, 1, 0, 0, 0, 841, 157, 1, 0, 0, 0, 842, 843, 5, 41, 0, 0, 843,
		844, 5, 49, 0, 0, 844, 861, 5, 42, 0, 0, 845, 857, 5, 41, 0, 0, 846, 851,
		3, 160, 80, 0, 847, 848, 5, 51, 0, 0, 848, 850, 3, 160, 80, 0, 849, 847,
		1, 0, 0, 0, 850, 853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 852, 1, 0,
		0, 0, 852, 855, 1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 854, 856, 5, 51, 0, 0,
		855, 854, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 858, 1, 0, 0, 0, 857,
		846, 1, 0, 0, 0, 857, 858, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 861,
		5, 42, 0, 0, 860, 842, 1, 0, 0, 0, 860, 845, 1, 0, 0, 0, 861, 159, 1, 0,
		0, 0, 862, 863, 3, 88, 44, 0, 863, 864, 5, 49, 0, 0, 864, 865, 3, 88, 44,
		0, 865, 161, 1, 0, 0, 0, 866, 878, 5, 45, 0, 0, 867, 872, 3, 88, 44, 0,
		868, 869, 5, 51, 0, 0, 869, 871, 3, 88, 44, 0, 870, 868, 1, 0, 0, 0, 871,
		874, 1, 0, 0, 0, 872, 870, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 876,
		1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 875, 877, 5, 51, 0, 0, 876, 875, 1, 0,
		0, 0, 876, 877, 1, 0, 0, 0, 877, 879, 1, 0, 0, 0, 878, 867, 1, 0, 0, 0,
		878, 879, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 881, 5, 46, 0, 0, 881,
		163, 1, 0, 0, 0, 882, 883, 5, 34, 0, 0, 883, 165, 1, 0, 0, 0, 884, 885,
		5, 35, 0, 0, 885, 167, 1, 0, 0, 0, 886, 887, 5, 14, 0, 0, 887, 888, 3,
		88, 44, 0, 888, 889, 5, 51, 0, 0, 889, 891, 3, 144, 72, 0, 890, 892, 5,
		50, 0, 0, 891, 890, 1, 0, 0, 0, 891, 892, 1, 0, 0, 0, 892, 169, 1, 0, 0,
		0, 893, 896, 5, 83, 0, 0, 894, 897, 3, 132, 66, 0, 895, 897, 3, 136, 68,
		0, 896, 894, 1, 0, 0, 0, 896, 895, 1, 0, 0, 0, 897, 171, 1, 0, 0, 0, 898,
		899, 5, 83, 0, 0, 899, 911, 5, 43, 0, 0, 900, 905, 3, 174, 87, 0, 901,
		902, 5, 51, 0, 0, 902, 904, 3, 174, 87, 0, 903, 901, 1, 0, 0, 0, 904, 907,
		1, 0, 0, 0, 905, 903, 1, 0, 0, 0, 905, 906, 1, 0, 0, 0, 906, 909, 1, 0,
		0, 0, 907, 905, 1, 0, 0, 0, 908, 910, 5, 51, 0, 0, 909, 908, 1, 0, 0, 0,
		909, 910, 1, 0, 0, 0, 910, 912, 1, 0, 0, 0, 911, 900, 1, 0, 0, 0, 911,
		912, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 914, 5, 44, 0, 0, 914, 173,
		1, 0, 0, 0, 915, 916, 5, 83, 0, 0, 916, 917, 5, 49, 0, 0, 917, 918, 3,
		88, 44, 0, 918, 175, 1, 0, 0, 0, 111, 179, 192, 195, 206, 210, 212, 220,
		225, 237, 244, 249, 267, 274, 277, 297, 304, 308, 315, 319, 328, 332, 335,
		342, 346, 352, 358, 362, 370, 374, 376, 384, 388, 396, 402, 409, 413, 416,
		426, 438, 441, 445, 449, 465, 468, 471, 475, 479, 489, 493, 500, 509, 515,
		519, 523, 527, 539, 548, 558, 566, 573, 581, 589, 597, 605, 613, 621, 629,
		637, 645, 651, 654, 657, 660, 667, 676, 678, 697, 702, 706, 716, 720, 728,
		731, 737, 740, 746, 755, 764, 773, 783, 794, 800, 807, 813, 823, 827, 829,
		835, 840, 851, 855, 857, 860, 872, 876, 878, 891, 896, 905, 909, 911,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                           = antlr.TokenEOF
	ManuscriptWS                            = 1
	ManuscriptCOMMENT                       = 2
	ManuscriptMULTI_LINE_COMMENT            = 3
	ManuscriptLET                           = 4
	ManuscriptFN                            = 5
	ManuscriptRETURN                        = 6
	ManuscriptYIELD                         = 7
	ManuscriptTYPE                          = 8
	ManuscriptINTERFACE                     = 9
	ManuscriptIMPORT                        = 10
	ManuscriptEXPORT                        = 11
	ManuscriptEXTERN                        = 12
	ManuscriptVOID                          = 13
	ManuscriptCHECK                         = 14
	ManuscriptTRY                           = 15
	ManuscriptCATCH                         = 16
	ManuscriptIN                            = 17
	ManuscriptAS                            = 18
	ManuscriptIS                            = 19
	ManuscriptEXTENDS                       = 20
	ManuscriptFROM                          = 21
	ManuscriptNULL                          = 22
	ManuscriptIF                            = 23
	ManuscriptELSE                          = 24
	ManuscriptFOR                           = 25
	ManuscriptWHILE                         = 26
	ManuscriptTRUE                          = 27
	ManuscriptFALSE                         = 28
	ManuscriptMATCH                         = 29
	ManuscriptCASE                          = 30
	ManuscriptASYNC                         = 31
	ManuscriptAWAIT                         = 32
	ManuscriptMETHODS                       = 33
	ManuscriptBREAK                         = 34
	ManuscriptCONTINUE                      = 35
	ManuscriptDEFAULT                       = 36
	ManuscriptDEFER                         = 37
	ManuscriptGO                            = 38
	ManuscriptLBRACE                        = 39
	ManuscriptRBRACE                        = 40
	ManuscriptLSQBR                         = 41
	ManuscriptRSQBR                         = 42
	ManuscriptLPAREN                        = 43
	ManuscriptRPAREN                        = 44
	ManuscriptLT                            = 45
	ManuscriptGT                            = 46
	ManuscriptLT_EQUALS                     = 47
	ManuscriptGT_EQUALS                     = 48
	ManuscriptCOLON                         = 49
	ManuscriptSEMICOLON                     = 50
	ManuscriptCOMMA                         = 51
	ManuscriptEQUALS                        = 52
	ManuscriptEQUALS_EQUALS                 = 53
	ManuscriptPLUS                          = 54
	ManuscriptMINUS                         = 55
	ManuscriptPLUS_PLUS                     = 56
	ManuscriptMINUS_MINUS                   = 57
	ManuscriptPIPE_PIPE                     = 58
	ManuscriptAMP_AMP                       = 59
	ManuscriptSTAR                          = 60
	ManuscriptSLASH                         = 61
	ManuscriptMOD                           = 62
	ManuscriptEXCLAMATION                   = 63
	ManuscriptQUESTION                      = 64
	ManuscriptDOT                           = 65
	ManuscriptNEQ                           = 66
	ManuscriptPLUS_EQUALS                   = 67
	ManuscriptMINUS_EQUALS                  = 68
	ManuscriptSTAR_EQUALS                   = 69
	ManuscriptSLASH_EQUALS                  = 70
	ManuscriptMOD_EQUALS                    = 71
	ManuscriptCARET_EQUALS                  = 72
	ManuscriptPIPE                          = 73
	ManuscriptAMP                           = 74
	ManuscriptCARET                         = 75
	ManuscriptLSHIFT                        = 76
	ManuscriptRSHIFT                        = 77
	ManuscriptHEX_LITERAL                   = 78
	ManuscriptBINARY_LITERAL                = 79
	ManuscriptOCTAL_LITERAL                 = 80
	ManuscriptFLOAT                         = 81
	ManuscriptINTEGER                       = 82
	ManuscriptID                            = 83
	ManuscriptSINGLE_QUOTE_START            = 84
	ManuscriptMULTI_QUOTE_START             = 85
	ManuscriptDOUBLE_QUOTE_START            = 86
	ManuscriptMULTI_DOUBLE_QUOTE_START      = 87
	ManuscriptSINGLE_STR_INTERP_START       = 88
	ManuscriptSINGLE_STR_CONTENT            = 89
	ManuscriptSINGLE_STR_END                = 90
	ManuscriptMULTI_STR_INTERP_START        = 91
	ManuscriptMULTI_STR_CONTENT             = 92
	ManuscriptMULTI_STR_END                 = 93
	ManuscriptDOUBLE_STR_INTERP_START       = 94
	ManuscriptDOUBLE_STR_CONTENT            = 95
	ManuscriptDOUBLE_STR_END                = 96
	ManuscriptMULTI_DOUBLE_STR_INTERP_START = 97
	ManuscriptMULTI_DOUBLE_STR_CONTENT      = 98
	ManuscriptMULTI_DOUBLE_STR_END          = 99
	ManuscriptINTERP_LBRACE                 = 100
	ManuscriptINTERP_RBRACE                 = 101
	ManuscriptINTERP_WS                     = 102
)

// Manuscript rules.
const (
	ManuscriptRULE_program                 = 0
	ManuscriptRULE_programItem             = 1
	ManuscriptRULE_importStmt              = 2
	ManuscriptRULE_moduleDecl              = 3
	ManuscriptRULE_importItem              = 4
	ManuscriptRULE_importStr               = 5
	ManuscriptRULE_externStmt              = 6
	ManuscriptRULE_exportStmt              = 7
	ManuscriptRULE_letDecl                 = 8
	ManuscriptRULE_letSingle               = 9
	ManuscriptRULE_letBlockItem            = 10
	ManuscriptRULE_letBlock                = 11
	ManuscriptRULE_letDestructuredObj      = 12
	ManuscriptRULE_letDestructuredArray    = 13
	ManuscriptRULE_namedID                 = 14
	ManuscriptRULE_typedID                 = 15
	ManuscriptRULE_typedIDList             = 16
	ManuscriptRULE_typeList                = 17
	ManuscriptRULE_fnDecl                  = 18
	ManuscriptRULE_fnSignature             = 19
	ManuscriptRULE_parameters              = 20
	ManuscriptRULE_param                   = 21
	ManuscriptRULE_typeDecl                = 22
	ManuscriptRULE_typeDefBody             = 23
	ManuscriptRULE_typeAlias               = 24
	ManuscriptRULE_fieldDecl               = 25
	ManuscriptRULE_interfaceDecl           = 26
	ManuscriptRULE_interfaceMethod         = 27
	ManuscriptRULE_methodsDecl             = 28
	ManuscriptRULE_methodImpl              = 29
	ManuscriptRULE_typeAnnotation          = 30
	ManuscriptRULE_tupleType               = 31
	ManuscriptRULE_stmt                    = 32
	ManuscriptRULE_returnStmt              = 33
	ManuscriptRULE_yieldStmt               = 34
	ManuscriptRULE_deferStmt               = 35
	ManuscriptRULE_exprList                = 36
	ManuscriptRULE_ifStmt                  = 37
	ManuscriptRULE_forStmt                 = 38
	ManuscriptRULE_forLoopType             = 39
	ManuscriptRULE_forTrinity              = 40
	ManuscriptRULE_whileStmt               = 41
	ManuscriptRULE_loopBody                = 42
	ManuscriptRULE_codeBlock               = 43
	ManuscriptRULE_expr                    = 44
	ManuscriptRULE_assignmentExpr          = 45
	ManuscriptRULE_ternaryExpr             = 46
	ManuscriptRULE_logicalOrExpr           = 47
	ManuscriptRULE_logicalAndExpr          = 48
	ManuscriptRULE_bitwiseOrExpr           = 49
	ManuscriptRULE_bitwiseXorExpr          = 50
	ManuscriptRULE_bitwiseAndExpr          = 51
	ManuscriptRULE_equalityExpr            = 52
	ManuscriptRULE_comparisonExpr          = 53
	ManuscriptRULE_shiftExpr               = 54
	ManuscriptRULE_additiveExpr            = 55
	ManuscriptRULE_multiplicativeExpr      = 56
	ManuscriptRULE_unaryExpr               = 57
	ManuscriptRULE_awaitExpr               = 58
	ManuscriptRULE_postfixExpr             = 59
	ManuscriptRULE_primaryExpr             = 60
	ManuscriptRULE_fnExpr                  = 61
	ManuscriptRULE_matchExpr               = 62
	ManuscriptRULE_caseClause              = 63
	ManuscriptRULE_defaultClause           = 64
	ManuscriptRULE_singleQuotedString      = 65
	ManuscriptRULE_multiQuotedString       = 66
	ManuscriptRULE_doubleQuotedString      = 67
	ManuscriptRULE_multiDoubleQuotedString = 68
	ManuscriptRULE_stringPart              = 69
	ManuscriptRULE_interpolation           = 70
	ManuscriptRULE_literal                 = 71
	ManuscriptRULE_stringLiteral           = 72
	ManuscriptRULE_numberLiteral           = 73
	ManuscriptRULE_booleanLiteral          = 74
	ManuscriptRULE_arrayLiteral            = 75
	ManuscriptRULE_objectLiteral           = 76
	ManuscriptRULE_objectFieldName         = 77
	ManuscriptRULE_objectField             = 78
	ManuscriptRULE_mapLiteral              = 79
	ManuscriptRULE_mapField                = 80
	ManuscriptRULE_setLiteral              = 81
	ManuscriptRULE_breakStmt               = 82
	ManuscriptRULE_continueStmt            = 83
	ManuscriptRULE_checkStmt               = 84
	ManuscriptRULE_taggedBlockString       = 85
	ManuscriptRULE_structInitExpr          = 86
	ManuscriptRULE_structField             = 87
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_programItem returns the _programItem rule contexts.
	Get_programItem() IProgramItemContext

	// Set_programItem sets the _programItem rule contexts.
	Set_programItem(IProgramItemContext)

	// GetItems returns the items rule context list.
	GetItems() []IProgramItemContext

	// SetItems sets the items rule context list.
	SetItems([]IProgramItemContext)

	// Getter signatures
	EOF() antlr.TerminalNode
	AllProgramItem() []IProgramItemContext
	ProgramItem(i int) IProgramItemContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_programItem IProgramItemContext
	items        []IProgramItemContext
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Get_programItem() IProgramItemContext { return s._programItem }

func (s *ProgramContext) Set_programItem(v IProgramItemContext) { s._programItem = v }

func (s *ProgramContext) GetItems() []IProgramItemContext { return s.items }

func (s *ProgramContext) SetItems(v []IProgramItemContext) { s.items = v }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllProgramItem() []IProgramItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgramItemContext); ok {
			len++
		}
	}

	tst := make([]IProgramItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgramItemContext); ok {
			tst[i] = t.(IProgramItemContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) ProgramItem(i int) IProgramItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramItemContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8589942576) != 0 {
		{
			p.SetState(176)

			var _x = p.ProgramItem()

			localctx.(*ProgramContext)._programItem = _x
		}
		localctx.(*ProgramContext).items = append(localctx.(*ProgramContext).items, localctx.(*ProgramContext)._programItem)

		p.SetState(181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(182)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramItemContext is an interface to support dynamic dispatch.
type IProgramItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetImportStatement returns the importStatement rule contexts.
	GetImportStatement() IImportStmtContext

	// GetExportStatement returns the exportStatement rule contexts.
	GetExportStatement() IExportStmtContext

	// GetExternStatement returns the externStatement rule contexts.
	GetExternStatement() IExternStmtContext

	// GetLetDeclaration returns the letDeclaration rule contexts.
	GetLetDeclaration() ILetDeclContext

	// GetTypeDeclaration returns the typeDeclaration rule contexts.
	GetTypeDeclaration() ITypeDeclContext

	// GetInterfaceDeclaration returns the interfaceDeclaration rule contexts.
	GetInterfaceDeclaration() IInterfaceDeclContext

	// GetFunctionDeclaration returns the functionDeclaration rule contexts.
	GetFunctionDeclaration() IFnDeclContext

	// GetMethodsDeclaration returns the methodsDeclaration rule contexts.
	GetMethodsDeclaration() IMethodsDeclContext

	// SetImportStatement sets the importStatement rule contexts.
	SetImportStatement(IImportStmtContext)

	// SetExportStatement sets the exportStatement rule contexts.
	SetExportStatement(IExportStmtContext)

	// SetExternStatement sets the externStatement rule contexts.
	SetExternStatement(IExternStmtContext)

	// SetLetDeclaration sets the letDeclaration rule contexts.
	SetLetDeclaration(ILetDeclContext)

	// SetTypeDeclaration sets the typeDeclaration rule contexts.
	SetTypeDeclaration(ITypeDeclContext)

	// SetInterfaceDeclaration sets the interfaceDeclaration rule contexts.
	SetInterfaceDeclaration(IInterfaceDeclContext)

	// SetFunctionDeclaration sets the functionDeclaration rule contexts.
	SetFunctionDeclaration(IFnDeclContext)

	// SetMethodsDeclaration sets the methodsDeclaration rule contexts.
	SetMethodsDeclaration(IMethodsDeclContext)

	// Getter signatures
	ImportStmt() IImportStmtContext
	ExportStmt() IExportStmtContext
	ExternStmt() IExternStmtContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext
	FnDecl() IFnDeclContext
	MethodsDecl() IMethodsDeclContext
	SEMICOLON() antlr.TerminalNode

	// IsProgramItemContext differentiates from other interfaces.
	IsProgramItemContext()
}

type ProgramItemContext struct {
	antlr.BaseParserRuleContext
	parser               antlr.Parser
	importStatement      IImportStmtContext
	exportStatement      IExportStmtContext
	externStatement      IExternStmtContext
	letDeclaration       ILetDeclContext
	typeDeclaration      ITypeDeclContext
	interfaceDeclaration IInterfaceDeclContext
	functionDeclaration  IFnDeclContext
	methodsDeclaration   IMethodsDeclContext
}

func NewEmptyProgramItemContext() *ProgramItemContext {
	var p = new(ProgramItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_programItem
	return p
}

func InitEmptyProgramItemContext(p *ProgramItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_programItem
}

func (*ProgramItemContext) IsProgramItemContext() {}

func NewProgramItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramItemContext {
	var p = new(ProgramItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_programItem

	return p
}

func (s *ProgramItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramItemContext) GetImportStatement() IImportStmtContext { return s.importStatement }

func (s *ProgramItemContext) GetExportStatement() IExportStmtContext { return s.exportStatement }

func (s *ProgramItemContext) GetExternStatement() IExternStmtContext { return s.externStatement }

func (s *ProgramItemContext) GetLetDeclaration() ILetDeclContext { return s.letDeclaration }

func (s *ProgramItemContext) GetTypeDeclaration() ITypeDeclContext { return s.typeDeclaration }

func (s *ProgramItemContext) GetInterfaceDeclaration() IInterfaceDeclContext {
	return s.interfaceDeclaration
}

func (s *ProgramItemContext) GetFunctionDeclaration() IFnDeclContext { return s.functionDeclaration }

func (s *ProgramItemContext) GetMethodsDeclaration() IMethodsDeclContext { return s.methodsDeclaration }

func (s *ProgramItemContext) SetImportStatement(v IImportStmtContext) { s.importStatement = v }

func (s *ProgramItemContext) SetExportStatement(v IExportStmtContext) { s.exportStatement = v }

func (s *ProgramItemContext) SetExternStatement(v IExternStmtContext) { s.externStatement = v }

func (s *ProgramItemContext) SetLetDeclaration(v ILetDeclContext) { s.letDeclaration = v }

func (s *ProgramItemContext) SetTypeDeclaration(v ITypeDeclContext) { s.typeDeclaration = v }

func (s *ProgramItemContext) SetInterfaceDeclaration(v IInterfaceDeclContext) {
	s.interfaceDeclaration = v
}

func (s *ProgramItemContext) SetFunctionDeclaration(v IFnDeclContext) { s.functionDeclaration = v }

func (s *ProgramItemContext) SetMethodsDeclaration(v IMethodsDeclContext) { s.methodsDeclaration = v }

func (s *ProgramItemContext) ImportStmt() IImportStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStmtContext)
}

func (s *ProgramItemContext) ExportStmt() IExportStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStmtContext)
}

func (s *ProgramItemContext) ExternStmt() IExternStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternStmtContext)
}

func (s *ProgramItemContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ProgramItemContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ProgramItemContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ProgramItemContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ProgramItemContext) MethodsDecl() IMethodsDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodsDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodsDeclContext)
}

func (s *ProgramItemContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ProgramItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgramItem(s)
	}
}

func (s *ProgramItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgramItem(s)
	}
}

func (s *ProgramItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgramItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ProgramItem() (localctx IProgramItemContext) {
	localctx = NewProgramItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_programItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptIMPORT:
		{
			p.SetState(184)

			var _x = p.ImportStmt()

			localctx.(*ProgramItemContext).importStatement = _x
		}

	case ManuscriptEXPORT:
		{
			p.SetState(185)

			var _x = p.ExportStmt()

			localctx.(*ProgramItemContext).exportStatement = _x
		}

	case ManuscriptEXTERN:
		{
			p.SetState(186)

			var _x = p.ExternStmt()

			localctx.(*ProgramItemContext).externStatement = _x
		}

	case ManuscriptLET:
		{
			p.SetState(187)

			var _x = p.LetDecl()

			localctx.(*ProgramItemContext).letDeclaration = _x
		}

	case ManuscriptTYPE:
		{
			p.SetState(188)

			var _x = p.TypeDecl()

			localctx.(*ProgramItemContext).typeDeclaration = _x
		}

	case ManuscriptINTERFACE:
		{
			p.SetState(189)

			var _x = p.InterfaceDecl()

			localctx.(*ProgramItemContext).interfaceDeclaration = _x
		}

	case ManuscriptFN:
		{
			p.SetState(190)

			var _x = p.FnDecl()

			localctx.(*ProgramItemContext).functionDeclaration = _x
		}

	case ManuscriptMETHODS:
		{
			p.SetState(191)

			var _x = p.MethodsDecl()

			localctx.(*ProgramItemContext).methodsDeclaration = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(194)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStmtContext is an interface to support dynamic dispatch.
type IImportStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ModuleDecl() IModuleDeclContext

	// IsImportStmtContext differentiates from other interfaces.
	IsImportStmtContext()
}

type ImportStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStmtContext() *ImportStmtContext {
	var p = new(ImportStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStmt
	return p
}

func InitEmptyImportStmtContext(p *ImportStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStmt
}

func (*ImportStmtContext) IsImportStmtContext() {}

func NewImportStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStmtContext {
	var p = new(ImportStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importStmt

	return p
}

func (s *ImportStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportStmtContext) ModuleDecl() IModuleDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclContext)
}

func (s *ImportStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportStmt(s)
	}
}

func (s *ImportStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportStmt(s)
	}
}

func (s *ImportStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportStmt() (localctx IImportStmtContext) {
	localctx = NewImportStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(197)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(198)
		p.ModuleDecl()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleDeclContext is an interface to support dynamic dispatch.
type IModuleDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsModuleDeclContext differentiates from other interfaces.
	IsModuleDeclContext()
}

type ModuleDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleDeclContext() *ModuleDeclContext {
	var p = new(ModuleDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleDecl
	return p
}

func InitEmptyModuleDeclContext(p *ModuleDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleDecl
}

func (*ModuleDeclContext) IsModuleDeclContext() {}

func NewModuleDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleDeclContext {
	var p = new(ModuleDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_moduleDecl

	return p
}

func (s *ModuleDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleDeclContext) CopyAll(ctx *ModuleDeclContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ModuleDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DestructuredImportContext struct {
	ModuleDeclContext
	_importItem IImportItemContext
	items       []IImportItemContext
	path        IImportStrContext
}

func NewDestructuredImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DestructuredImportContext {
	var p = new(DestructuredImportContext)

	InitEmptyModuleDeclContext(&p.ModuleDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*ModuleDeclContext))

	return p
}

func (s *DestructuredImportContext) Get_importItem() IImportItemContext { return s._importItem }

func (s *DestructuredImportContext) GetPath() IImportStrContext { return s.path }

func (s *DestructuredImportContext) Set_importItem(v IImportItemContext) { s._importItem = v }

func (s *DestructuredImportContext) SetPath(v IImportStrContext) { s.path = v }

func (s *DestructuredImportContext) GetItems() []IImportItemContext { return s.items }

func (s *DestructuredImportContext) SetItems(v []IImportItemContext) { s.items = v }

func (s *DestructuredImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestructuredImportContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *DestructuredImportContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *DestructuredImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *DestructuredImportContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *DestructuredImportContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *DestructuredImportContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *DestructuredImportContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *DestructuredImportContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *DestructuredImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDestructuredImport(s)

	default:
		return t.VisitChildren(s)
	}
}

type TargetImportContext struct {
	ModuleDeclContext
	target antlr.Token
	path   IImportStrContext
}

func NewTargetImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TargetImportContext {
	var p = new(TargetImportContext)

	InitEmptyModuleDeclContext(&p.ModuleDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*ModuleDeclContext))

	return p
}

func (s *TargetImportContext) GetTarget() antlr.Token { return s.target }

func (s *TargetImportContext) SetTarget(v antlr.Token) { s.target = v }

func (s *TargetImportContext) GetPath() IImportStrContext { return s.path }

func (s *TargetImportContext) SetPath(v IImportStrContext) { s.path = v }

func (s *TargetImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *TargetImportContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TargetImportContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *TargetImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTargetImport(s)
	}
}

func (s *TargetImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTargetImport(s)
	}
}

func (s *TargetImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTargetImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ModuleDecl() (localctx IModuleDeclContext) {
	localctx = NewModuleDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_moduleDecl)
	var _la int

	var _alt int

	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		localctx = NewDestructuredImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(200)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptID {
			{
				p.SetState(201)

				var _x = p.ImportItem()

				localctx.(*DestructuredImportContext)._importItem = _x
			}
			localctx.(*DestructuredImportContext).items = append(localctx.(*DestructuredImportContext).items, localctx.(*DestructuredImportContext)._importItem)
			p.SetState(206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(202)
						p.Match(ManuscriptCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(203)

						var _x = p.ImportItem()

						localctx.(*DestructuredImportContext)._importItem = _x
					}
					localctx.(*DestructuredImportContext).items = append(localctx.(*DestructuredImportContext).items, localctx.(*DestructuredImportContext)._importItem)

				}
				p.SetState(208)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(210)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ManuscriptCOMMA {
				{
					p.SetState(209)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(214)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(215)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(216)

			var _x = p.ImportStr()

			localctx.(*DestructuredImportContext).path = _x
		}

	case ManuscriptID:
		localctx = NewTargetImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(217)

			var _m = p.Match(ManuscriptID)

			localctx.(*TargetImportContext).target = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(218)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(219)

			var _x = p.ImportStr()

			localctx.(*TargetImportContext).path = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
	alias  antlr.Token
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) GetName() antlr.Token { return s.name }

func (s *ImportItemContext) GetAlias() antlr.Token { return s.alias }

func (s *ImportItemContext) SetName(v antlr.Token) { s.name = v }

func (s *ImportItemContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)

		var _m = p.Match(ManuscriptID)

		localctx.(*ImportItemContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(223)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(224)

			var _m = p.Match(ManuscriptID)

			localctx.(*ImportItemContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStrContext is an interface to support dynamic dispatch.
type IImportStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPathSingle returns the pathSingle rule contexts.
	GetPathSingle() ISingleQuotedStringContext

	// SetPathSingle sets the pathSingle rule contexts.
	SetPathSingle(ISingleQuotedStringContext)

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext

	// IsImportStrContext differentiates from other interfaces.
	IsImportStrContext()
}

type ImportStrContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	pathSingle ISingleQuotedStringContext
}

func NewEmptyImportStrContext() *ImportStrContext {
	var p = new(ImportStrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
	return p
}

func InitEmptyImportStrContext(p *ImportStrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
}

func (*ImportStrContext) IsImportStrContext() {}

func NewImportStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStrContext {
	var p = new(ImportStrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importStr

	return p
}

func (s *ImportStrContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStrContext) GetPathSingle() ISingleQuotedStringContext { return s.pathSingle }

func (s *ImportStrContext) SetPathSingle(v ISingleQuotedStringContext) { s.pathSingle = v }

func (s *ImportStrContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *ImportStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportStr(s)
	}
}

func (s *ImportStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportStr(s)
	}
}

func (s *ImportStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportStr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportStr() (localctx IImportStrContext) {
	localctx = NewImportStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_importStr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(227)

		var _x = p.SingleQuotedString()

		localctx.(*ImportStrContext).pathSingle = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternStmtContext is an interface to support dynamic dispatch.
type IExternStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ModuleDecl() IModuleDeclContext

	// IsExternStmtContext differentiates from other interfaces.
	IsExternStmtContext()
}

type ExternStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternStmtContext() *ExternStmtContext {
	var p = new(ExternStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externStmt
	return p
}

func InitEmptyExternStmtContext(p *ExternStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externStmt
}

func (*ExternStmtContext) IsExternStmtContext() {}

func NewExternStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternStmtContext {
	var p = new(ExternStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externStmt

	return p
}

func (s *ExternStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternStmtContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternStmtContext) ModuleDecl() IModuleDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleDeclContext)
}

func (s *ExternStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternStmt(s)
	}
}

func (s *ExternStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternStmt(s)
	}
}

func (s *ExternStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternStmt() (localctx IExternStmtContext) {
	localctx = NewExternStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_externStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(230)
		p.ModuleDecl()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStmtContext is an interface to support dynamic dispatch.
type IExportStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExportedFunction returns the exportedFunction rule contexts.
	GetExportedFunction() IFnDeclContext

	// GetExportedLet returns the exportedLet rule contexts.
	GetExportedLet() ILetDeclContext

	// GetExportedType returns the exportedType rule contexts.
	GetExportedType() ITypeDeclContext

	// GetExportedInterface returns the exportedInterface rule contexts.
	GetExportedInterface() IInterfaceDeclContext

	// SetExportedFunction sets the exportedFunction rule contexts.
	SetExportedFunction(IFnDeclContext)

	// SetExportedLet sets the exportedLet rule contexts.
	SetExportedLet(ILetDeclContext)

	// SetExportedType sets the exportedType rule contexts.
	SetExportedType(ITypeDeclContext)

	// SetExportedInterface sets the exportedInterface rule contexts.
	SetExportedInterface(IInterfaceDeclContext)

	// Getter signatures
	EXPORT() antlr.TerminalNode
	FnDecl() IFnDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext

	// IsExportStmtContext differentiates from other interfaces.
	IsExportStmtContext()
}

type ExportStmtContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	exportedFunction  IFnDeclContext
	exportedLet       ILetDeclContext
	exportedType      ITypeDeclContext
	exportedInterface IInterfaceDeclContext
}

func NewEmptyExportStmtContext() *ExportStmtContext {
	var p = new(ExportStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportStmt
	return p
}

func InitEmptyExportStmtContext(p *ExportStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportStmt
}

func (*ExportStmtContext) IsExportStmtContext() {}

func NewExportStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStmtContext {
	var p = new(ExportStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportStmt

	return p
}

func (s *ExportStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStmtContext) GetExportedFunction() IFnDeclContext { return s.exportedFunction }

func (s *ExportStmtContext) GetExportedLet() ILetDeclContext { return s.exportedLet }

func (s *ExportStmtContext) GetExportedType() ITypeDeclContext { return s.exportedType }

func (s *ExportStmtContext) GetExportedInterface() IInterfaceDeclContext { return s.exportedInterface }

func (s *ExportStmtContext) SetExportedFunction(v IFnDeclContext) { s.exportedFunction = v }

func (s *ExportStmtContext) SetExportedLet(v ILetDeclContext) { s.exportedLet = v }

func (s *ExportStmtContext) SetExportedType(v ITypeDeclContext) { s.exportedType = v }

func (s *ExportStmtContext) SetExportedInterface(v IInterfaceDeclContext) { s.exportedInterface = v }

func (s *ExportStmtContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportStmtContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportStmtContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportStmtContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportStmtContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ExportStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportStmt(s)
	}
}

func (s *ExportStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportStmt(s)
	}
}

func (s *ExportStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportStmt() (localctx IExportStmtContext) {
	localctx = NewExportStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_exportStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		{
			p.SetState(233)

			var _x = p.FnDecl()

			localctx.(*ExportStmtContext).exportedFunction = _x
		}

	case ManuscriptLET:
		{
			p.SetState(234)

			var _x = p.LetDecl()

			localctx.(*ExportStmtContext).exportedLet = _x
		}

	case ManuscriptTYPE:
		{
			p.SetState(235)

			var _x = p.TypeDecl()

			localctx.(*ExportStmtContext).exportedType = _x
		}

	case ManuscriptINTERFACE:
		{
			p.SetState(236)

			var _x = p.InterfaceDecl()

			localctx.(*ExportStmtContext).exportedInterface = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSingleLet returns the singleLet rule contexts.
	GetSingleLet() ILetSingleContext

	// GetBlockLet returns the blockLet rule contexts.
	GetBlockLet() ILetBlockContext

	// GetDestructuredObjectLet returns the destructuredObjectLet rule contexts.
	GetDestructuredObjectLet() ILetDestructuredObjContext

	// GetDestructuredArrayLet returns the destructuredArrayLet rule contexts.
	GetDestructuredArrayLet() ILetDestructuredArrayContext

	// SetSingleLet sets the singleLet rule contexts.
	SetSingleLet(ILetSingleContext)

	// SetBlockLet sets the blockLet rule contexts.
	SetBlockLet(ILetBlockContext)

	// SetDestructuredObjectLet sets the destructuredObjectLet rule contexts.
	SetDestructuredObjectLet(ILetDestructuredObjContext)

	// SetDestructuredArrayLet sets the destructuredArrayLet rule contexts.
	SetDestructuredArrayLet(ILetDestructuredArrayContext)

	// Getter signatures
	LET() antlr.TerminalNode
	LetSingle() ILetSingleContext
	LetBlock() ILetBlockContext
	LetDestructuredObj() ILetDestructuredObjContext
	LetDestructuredArray() ILetDestructuredArrayContext

	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser                antlr.Parser
	singleLet             ILetSingleContext
	blockLet              ILetBlockContext
	destructuredObjectLet ILetDestructuredObjContext
	destructuredArrayLet  ILetDestructuredArrayContext
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) GetSingleLet() ILetSingleContext { return s.singleLet }

func (s *LetDeclContext) GetBlockLet() ILetBlockContext { return s.blockLet }

func (s *LetDeclContext) GetDestructuredObjectLet() ILetDestructuredObjContext {
	return s.destructuredObjectLet
}

func (s *LetDeclContext) GetDestructuredArrayLet() ILetDestructuredArrayContext {
	return s.destructuredArrayLet
}

func (s *LetDeclContext) SetSingleLet(v ILetSingleContext) { s.singleLet = v }

func (s *LetDeclContext) SetBlockLet(v ILetBlockContext) { s.blockLet = v }

func (s *LetDeclContext) SetDestructuredObjectLet(v ILetDestructuredObjContext) {
	s.destructuredObjectLet = v
}

func (s *LetDeclContext) SetDestructuredArrayLet(v ILetDestructuredArrayContext) {
	s.destructuredArrayLet = v
}

func (s *LetDeclContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LetDeclContext) LetBlock() ILetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockContext)
}

func (s *LetDeclContext) LetDestructuredObj() ILetDestructuredObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredObjContext)
}

func (s *LetDeclContext) LetDestructuredArray() ILetDestructuredArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredArrayContext)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDecl(s)
	}
}

func (s *LetDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDecl(s)
	}
}

func (s *LetDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_letDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Match(ManuscriptLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		{
			p.SetState(240)

			var _x = p.LetSingle()

			localctx.(*LetDeclContext).singleLet = _x
		}

	case ManuscriptLPAREN:
		{
			p.SetState(241)

			var _x = p.LetBlock()

			localctx.(*LetDeclContext).blockLet = _x
		}

	case ManuscriptLBRACE:
		{
			p.SetState(242)

			var _x = p.LetDestructuredObj()

			localctx.(*LetDeclContext).destructuredObjectLet = _x
		}

	case ManuscriptLSQBR:
		{
			p.SetState(243)

			var _x = p.LetDestructuredArray()

			localctx.(*LetDeclContext).destructuredArrayLet = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetSingleContext is an interface to support dynamic dispatch.
type ILetSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	TypedID() ITypedIDContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetSingleContext differentiates from other interfaces.
	IsLetSingleContext()
}

type LetSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExprContext
}

func NewEmptyLetSingleContext() *LetSingleContext {
	var p = new(LetSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
	return p
}

func InitEmptyLetSingleContext(p *LetSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
}

func (*LetSingleContext) IsLetSingleContext() {}

func NewLetSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetSingleContext {
	var p = new(LetSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letSingle

	return p
}

func (s *LetSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LetSingleContext) GetValue() IExprContext { return s.value }

func (s *LetSingleContext) SetValue(v IExprContext) { s.value = v }

func (s *LetSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetSingle(s)
	}
}

func (s *LetSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetSingle(s)
	}
}

func (s *LetSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetSingle() (localctx ILetSingleContext) {
	localctx = NewLetSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_letSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.TypedID()
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(247)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(248)

			var _x = p.Expr()

			localctx.(*LetSingleContext).value = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemContext is an interface to support dynamic dispatch.
type ILetBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetBlockItemContext differentiates from other interfaces.
	IsLetBlockItemContext()
}

type LetBlockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemContext() *LetBlockItemContext {
	var p = new(LetBlockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
	return p
}

func InitEmptyLetBlockItemContext(p *LetBlockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
}

func (*LetBlockItemContext) IsLetBlockItemContext() {}

func NewLetBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemContext {
	var p = new(LetBlockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItem

	return p
}

func (s *LetBlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemContext) CopyAll(ctx *LetBlockItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetBlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LetBlockItemDestructuredArrayContext struct {
	LetBlockItemContext
	lhsDestructuredIdsArr ITypedIDListContext
	rhsExprArr            IExprContext
}

func NewLetBlockItemDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemDestructuredArrayContext {
	var p = new(LetBlockItemDestructuredArrayContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemDestructuredArrayContext) GetLhsDestructuredIdsArr() ITypedIDListContext {
	return s.lhsDestructuredIdsArr
}

func (s *LetBlockItemDestructuredArrayContext) GetRhsExprArr() IExprContext { return s.rhsExprArr }

func (s *LetBlockItemDestructuredArrayContext) SetLhsDestructuredIdsArr(v ITypedIDListContext) {
	s.lhsDestructuredIdsArr = v
}

func (s *LetBlockItemDestructuredArrayContext) SetRhsExprArr(v IExprContext) { s.rhsExprArr = v }

func (s *LetBlockItemDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetBlockItemDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetBlockItemDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetBlockItemDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemDestructuredArray(s)
	}
}

func (s *LetBlockItemDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemDestructuredArray(s)
	}
}

func (s *LetBlockItemDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetBlockItemDestructuredObjContext struct {
	LetBlockItemContext
	lhsDestructuredIdsObj ITypedIDListContext
	rhsExprObj            IExprContext
}

func NewLetBlockItemDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemDestructuredObjContext {
	var p = new(LetBlockItemDestructuredObjContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemDestructuredObjContext) GetLhsDestructuredIdsObj() ITypedIDListContext {
	return s.lhsDestructuredIdsObj
}

func (s *LetBlockItemDestructuredObjContext) GetRhsExprObj() IExprContext { return s.rhsExprObj }

func (s *LetBlockItemDestructuredObjContext) SetLhsDestructuredIdsObj(v ITypedIDListContext) {
	s.lhsDestructuredIdsObj = v
}

func (s *LetBlockItemDestructuredObjContext) SetRhsExprObj(v IExprContext) { s.rhsExprObj = v }

func (s *LetBlockItemDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetBlockItemDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetBlockItemDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetBlockItemDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemDestructuredObj(s)
	}
}

func (s *LetBlockItemDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemDestructuredObj(s)
	}
}

func (s *LetBlockItemDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetBlockItemSingleContext struct {
	LetBlockItemContext
	lhsTypedId ITypedIDContext
	rhsExpr    IExprContext
}

func NewLetBlockItemSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemSingleContext {
	var p = new(LetBlockItemSingleContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemSingleContext) GetLhsTypedId() ITypedIDContext { return s.lhsTypedId }

func (s *LetBlockItemSingleContext) GetRhsExpr() IExprContext { return s.rhsExpr }

func (s *LetBlockItemSingleContext) SetLhsTypedId(v ITypedIDContext) { s.lhsTypedId = v }

func (s *LetBlockItemSingleContext) SetRhsExpr(v IExprContext) { s.rhsExpr = v }

func (s *LetBlockItemSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetBlockItemSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSingle(s)
	}
}

func (s *LetBlockItemSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSingle(s)
	}
}

func (s *LetBlockItemSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItem() (localctx ILetBlockItemContext) {
	localctx = NewLetBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_letBlockItem)
	p.SetState(267)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLetBlockItemSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(251)

			var _x = p.TypedID()

			localctx.(*LetBlockItemSingleContext).lhsTypedId = _x
		}
		{
			p.SetState(252)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(253)

			var _x = p.Expr()

			localctx.(*LetBlockItemSingleContext).rhsExpr = _x
		}

	case ManuscriptLBRACE:
		localctx = NewLetBlockItemDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(255)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(256)

			var _x = p.TypedIDList()

			localctx.(*LetBlockItemDestructuredObjContext).lhsDestructuredIdsObj = _x
		}
		{
			p.SetState(257)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(258)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(259)

			var _x = p.Expr()

			localctx.(*LetBlockItemDestructuredObjContext).rhsExprObj = _x
		}

	case ManuscriptLSQBR:
		localctx = NewLetBlockItemDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(261)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(262)

			var _x = p.TypedIDList()

			localctx.(*LetBlockItemDestructuredArrayContext).lhsDestructuredIdsArr = _x
		}
		{
			p.SetState(263)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(264)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(265)

			var _x = p.Expr()

			localctx.(*LetBlockItemDestructuredArrayContext).rhsExprArr = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockContext is an interface to support dynamic dispatch.
type ILetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_letBlockItem returns the _letBlockItem rule contexts.
	Get_letBlockItem() ILetBlockItemContext

	// Set_letBlockItem sets the _letBlockItem rule contexts.
	Set_letBlockItem(ILetBlockItemContext)

	// GetItems returns the items rule context list.
	GetItems() []ILetBlockItemContext

	// SetItems sets the items rule context list.
	SetItems([]ILetBlockItemContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllLetBlockItem() []ILetBlockItemContext
	LetBlockItem(i int) ILetBlockItemContext

	// IsLetBlockContext differentiates from other interfaces.
	IsLetBlockContext()
}

type LetBlockContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	_letBlockItem ILetBlockItemContext
	items         []ILetBlockItemContext
}

func NewEmptyLetBlockContext() *LetBlockContext {
	var p = new(LetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
	return p
}

func InitEmptyLetBlockContext(p *LetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
}

func (*LetBlockContext) IsLetBlockContext() {}

func NewLetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockContext {
	var p = new(LetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlock

	return p
}

func (s *LetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockContext) Get_letBlockItem() ILetBlockItemContext { return s._letBlockItem }

func (s *LetBlockContext) Set_letBlockItem(v ILetBlockItemContext) { s._letBlockItem = v }

func (s *LetBlockContext) GetItems() []ILetBlockItemContext { return s.items }

func (s *LetBlockContext) SetItems(v []ILetBlockItemContext) { s.items = v }

func (s *LetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LetBlockContext) AllLetBlockItem() []ILetBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemContext); ok {
			tst[i] = t.(ILetBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockContext) LetBlockItem(i int) ILetBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemContext)
}

func (s *LetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlock(s)
	}
}

func (s *LetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlock(s)
	}
}

func (s *LetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlock() (localctx ILetBlockContext) {
	localctx = NewLetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_letBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(269)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-39)) & ^0x3f) == 0 && ((int64(1)<<(_la-39))&17592186044421) != 0 {
		{
			p.SetState(270)

			var _x = p.LetBlockItem()

			localctx.(*LetBlockContext)._letBlockItem = _x
		}
		localctx.(*LetBlockContext).items = append(localctx.(*LetBlockContext).items, localctx.(*LetBlockContext)._letBlockItem)
		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64((_la-39)) & ^0x3f) == 0 && ((int64(1)<<(_la-39))&17592186044421) != 0 {
			{
				p.SetState(271)

				var _x = p.LetBlockItem()

				localctx.(*LetBlockContext)._letBlockItem = _x
			}
			localctx.(*LetBlockContext).items = append(localctx.(*LetBlockContext).items, localctx.(*LetBlockContext)._letBlockItem)

			p.SetState(276)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(279)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredObjContext is an interface to support dynamic dispatch.
type ILetDestructuredObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDestructuredIds returns the destructuredIds rule contexts.
	GetDestructuredIds() ITypedIDListContext

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetDestructuredIds sets the destructuredIds rule contexts.
	SetDestructuredIds(ITypedIDListContext)

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	Expr() IExprContext

	// IsLetDestructuredObjContext differentiates from other interfaces.
	IsLetDestructuredObjContext()
}

type LetDestructuredObjContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	destructuredIds ITypedIDListContext
	value           IExprContext
}

func NewEmptyLetDestructuredObjContext() *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
	return p
}

func InitEmptyLetDestructuredObjContext(p *LetDestructuredObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
}

func (*LetDestructuredObjContext) IsLetDestructuredObjContext() {}

func NewLetDestructuredObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredObj

	return p
}

func (s *LetDestructuredObjContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredObjContext) GetDestructuredIds() ITypedIDListContext {
	return s.destructuredIds
}

func (s *LetDestructuredObjContext) GetValue() IExprContext { return s.value }

func (s *LetDestructuredObjContext) SetDestructuredIds(v ITypedIDListContext) { s.destructuredIds = v }

func (s *LetDestructuredObjContext) SetValue(v IExprContext) { s.value = v }

func (s *LetDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredObj() (localctx ILetDestructuredObjContext) {
	localctx = NewLetDestructuredObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_letDestructuredObj)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(282)

		var _x = p.TypedIDList()

		localctx.(*LetDestructuredObjContext).destructuredIds = _x
	}
	{
		p.SetState(283)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(284)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(285)

		var _x = p.Expr()

		localctx.(*LetDestructuredObjContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredArrayContext is an interface to support dynamic dispatch.
type ILetDestructuredArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDestructuredIds returns the destructuredIds rule contexts.
	GetDestructuredIds() ITypedIDListContext

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetDestructuredIds sets the destructuredIds rule contexts.
	SetDestructuredIds(ITypedIDListContext)

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	Expr() IExprContext

	// IsLetDestructuredArrayContext differentiates from other interfaces.
	IsLetDestructuredArrayContext()
}

type LetDestructuredArrayContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	destructuredIds ITypedIDListContext
	value           IExprContext
}

func NewEmptyLetDestructuredArrayContext() *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
	return p
}

func InitEmptyLetDestructuredArrayContext(p *LetDestructuredArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
}

func (*LetDestructuredArrayContext) IsLetDestructuredArrayContext() {}

func NewLetDestructuredArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredArray

	return p
}

func (s *LetDestructuredArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredArrayContext) GetDestructuredIds() ITypedIDListContext {
	return s.destructuredIds
}

func (s *LetDestructuredArrayContext) GetValue() IExprContext { return s.value }

func (s *LetDestructuredArrayContext) SetDestructuredIds(v ITypedIDListContext) {
	s.destructuredIds = v
}

func (s *LetDestructuredArrayContext) SetValue(v IExprContext) { s.value = v }

func (s *LetDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredArray() (localctx ILetDestructuredArrayContext) {
	localctx = NewLetDestructuredArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_letDestructuredArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(288)

		var _x = p.TypedIDList()

		localctx.(*LetDestructuredArrayContext).destructuredIds = _x
	}
	{
		p.SetState(289)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(290)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(291)

		var _x = p.Expr()

		localctx.(*LetDestructuredArrayContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedIDContext is an interface to support dynamic dispatch.
type INamedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ID() antlr.TerminalNode

	// IsNamedIDContext differentiates from other interfaces.
	IsNamedIDContext()
}

type NamedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyNamedIDContext() *NamedIDContext {
	var p = new(NamedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_namedID
	return p
}

func InitEmptyNamedIDContext(p *NamedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_namedID
}

func (*NamedIDContext) IsNamedIDContext() {}

func NewNamedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedIDContext {
	var p = new(NamedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_namedID

	return p
}

func (s *NamedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedIDContext) GetName() antlr.Token { return s.name }

func (s *NamedIDContext) SetName(v antlr.Token) { s.name = v }

func (s *NamedIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *NamedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNamedID(s)
	}
}

func (s *NamedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNamedID(s)
	}
}

func (s *NamedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNamedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NamedID() (localctx INamedIDContext) {
	localctx = NewNamedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_namedID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)

		var _m = p.Match(ManuscriptID)

		localctx.(*NamedIDContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDContext is an interface to support dynamic dispatch.
type ITypedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeAnnotationContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeAnnotationContext)

	// Getter signatures
	NamedID() INamedIDContext
	TypeAnnotation() ITypeAnnotationContext

	// IsTypedIDContext differentiates from other interfaces.
	IsTypedIDContext()
}

type TypedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  ITypeAnnotationContext
}

func NewEmptyTypedIDContext() *TypedIDContext {
	var p = new(TypedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
	return p
}

func InitEmptyTypedIDContext(p *TypedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
}

func (*TypedIDContext) IsTypedIDContext() {}

func NewTypedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDContext {
	var p = new(TypedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedID

	return p
}

func (s *TypedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDContext) GetType_() ITypeAnnotationContext { return s.type_ }

func (s *TypedIDContext) SetType_(v ITypeAnnotationContext) { s.type_ = v }

func (s *TypedIDContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *TypedIDContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedID(s)
	}
}

func (s *TypedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedID(s)
	}
}

func (s *TypedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedID() (localctx ITypedIDContext) {
	localctx = NewTypedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_typedID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(295)
		p.NamedID()
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(296)

			var _x = p.TypeAnnotation()

			localctx.(*TypedIDContext).type_ = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDListContext is an interface to support dynamic dispatch.
type ITypedIDListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_typedID returns the _typedID rule contexts.
	Get_typedID() ITypedIDContext

	// Set_typedID sets the _typedID rule contexts.
	Set_typedID(ITypedIDContext)

	// GetNames returns the names rule context list.
	GetNames() []ITypedIDContext

	// SetNames sets the names rule context list.
	SetNames([]ITypedIDContext)

	// Getter signatures
	AllTypedID() []ITypedIDContext
	TypedID(i int) ITypedIDContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedIDListContext differentiates from other interfaces.
	IsTypedIDListContext()
}

type TypedIDListContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	_typedID ITypedIDContext
	names    []ITypedIDContext
}

func NewEmptyTypedIDListContext() *TypedIDListContext {
	var p = new(TypedIDListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
	return p
}

func InitEmptyTypedIDListContext(p *TypedIDListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
}

func (*TypedIDListContext) IsTypedIDListContext() {}

func NewTypedIDListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDListContext {
	var p = new(TypedIDListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedIDList

	return p
}

func (s *TypedIDListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDListContext) Get_typedID() ITypedIDContext { return s._typedID }

func (s *TypedIDListContext) Set_typedID(v ITypedIDContext) { s._typedID = v }

func (s *TypedIDListContext) GetNames() []ITypedIDContext { return s.names }

func (s *TypedIDListContext) SetNames(v []ITypedIDContext) { s.names = v }

func (s *TypedIDListContext) AllTypedID() []ITypedIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIDContext); ok {
			len++
		}
	}

	tst := make([]ITypedIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIDContext); ok {
			tst[i] = t.(ITypedIDContext)
			i++
		}
	}

	return tst
}

func (s *TypedIDListContext) TypedID(i int) ITypedIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *TypedIDListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypedIDListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypedIDListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedIDList(s)
	}
}

func (s *TypedIDListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedIDList(s)
	}
}

func (s *TypedIDListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedIDList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedIDList() (localctx ITypedIDListContext) {
	localctx = NewTypedIDListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_typedIDList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)

		var _x = p.TypedID()

		localctx.(*TypedIDListContext)._typedID = _x
	}
	localctx.(*TypedIDListContext).names = append(localctx.(*TypedIDListContext).names, localctx.(*TypedIDListContext)._typedID)
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(300)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(301)

				var _x = p.TypedID()

				localctx.(*TypedIDListContext)._typedID = _x
			}
			localctx.(*TypedIDListContext).names = append(localctx.(*TypedIDListContext).names, localctx.(*TypedIDListContext)._typedID)

		}
		p.SetState(306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(307)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_typeAnnotation returns the _typeAnnotation rule contexts.
	Get_typeAnnotation() ITypeAnnotationContext

	// Set_typeAnnotation sets the _typeAnnotation rule contexts.
	Set_typeAnnotation(ITypeAnnotationContext)

	// GetTypes returns the types rule context list.
	GetTypes() []ITypeAnnotationContext

	// SetTypes sets the types rule context list.
	SetTypes([]ITypeAnnotationContext)

	// Getter signatures
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_typeAnnotation ITypeAnnotationContext
	types           []ITypeAnnotationContext
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) Get_typeAnnotation() ITypeAnnotationContext { return s._typeAnnotation }

func (s *TypeListContext) Set_typeAnnotation(v ITypeAnnotationContext) { s._typeAnnotation = v }

func (s *TypeListContext) GetTypes() []ITypeAnnotationContext { return s.types }

func (s *TypeListContext) SetTypes(v []ITypeAnnotationContext) { s.types = v }

func (s *TypeListContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(310)

		var _x = p.TypeAnnotation()

		localctx.(*TypeListContext)._typeAnnotation = _x
	}
	localctx.(*TypeListContext).types = append(localctx.(*TypeListContext).types, localctx.(*TypeListContext)._typeAnnotation)
	p.SetState(315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(311)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(312)

				var _x = p.TypeAnnotation()

				localctx.(*TypeListContext)._typeAnnotation = _x
			}
			localctx.(*TypeListContext).types = append(localctx.(*TypeListContext).types, localctx.(*TypeListContext)._typeAnnotation)

		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(318)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSignature returns the signature rule contexts.
	GetSignature() IFnSignatureContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetSignature sets the signature rule contexts.
	SetSignature(IFnSignatureContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	FnSignature() IFnSignatureContext
	CodeBlock() ICodeBlockContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	signature IFnSignatureContext
	block     ICodeBlockContext
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) GetSignature() IFnSignatureContext { return s.signature }

func (s *FnDeclContext) GetBlock() ICodeBlockContext { return s.block }

func (s *FnDeclContext) SetSignature(v IFnSignatureContext) { s.signature = v }

func (s *FnDeclContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *FnDeclContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_fnDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)

		var _x = p.FnSignature()

		localctx.(*FnDeclContext).signature = _x
	}
	{
		p.SetState(322)

		var _x = p.CodeBlock()

		localctx.(*FnDeclContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnSignatureContext is an interface to support dynamic dispatch.
type IFnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnsError returns the returnsError token.
	GetReturnsError() antlr.Token

	// SetReturnsError sets the returnsError token.
	SetReturnsError(antlr.Token)

	// GetFunctionName returns the functionName rule contexts.
	GetFunctionName() INamedIDContext

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// SetFunctionName sets the functionName rule contexts.
	SetFunctionName(INamedIDContext)

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	NamedID() INamedIDContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsFnSignatureContext differentiates from other interfaces.
	IsFnSignatureContext()
}

type FnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionName INamedIDContext
	params       IParametersContext
	returnType   ITypeAnnotationContext
	returnsError antlr.Token
}

func NewEmptyFnSignatureContext() *FnSignatureContext {
	var p = new(FnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
	return p
}

func InitEmptyFnSignatureContext(p *FnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
}

func (*FnSignatureContext) IsFnSignatureContext() {}

func NewFnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnSignatureContext {
	var p = new(FnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnSignature

	return p
}

func (s *FnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FnSignatureContext) GetReturnsError() antlr.Token { return s.returnsError }

func (s *FnSignatureContext) SetReturnsError(v antlr.Token) { s.returnsError = v }

func (s *FnSignatureContext) GetFunctionName() INamedIDContext { return s.functionName }

func (s *FnSignatureContext) GetParams() IParametersContext { return s.params }

func (s *FnSignatureContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *FnSignatureContext) SetFunctionName(v INamedIDContext) { s.functionName = v }

func (s *FnSignatureContext) SetParams(v IParametersContext) { s.params = v }

func (s *FnSignatureContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *FnSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnSignatureContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *FnSignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnSignatureContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnSignature(s)
	}
}

func (s *FnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnSignature(s)
	}
}

func (s *FnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnSignature() (localctx IFnSignatureContext) {
	localctx = NewFnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_fnSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(325)

		var _x = p.NamedID()

		localctx.(*FnSignatureContext).functionName = _x
	}
	{
		p.SetState(326)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(328)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(327)

			var _x = p.Parameters()

			localctx.(*FnSignatureContext).params = _x
		}

	}
	{
		p.SetState(330)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(331)

			var _x = p.TypeAnnotation()

			localctx.(*FnSignatureContext).returnType = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(335)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(334)

			var _m = p.Match(ManuscriptEXCLAMATION)

			localctx.(*FnSignatureContext).returnsError = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(337)
		p.Param()
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(338)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(339)
				p.Param()
			}

		}
		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(345)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParamName returns the paramName rule contexts.
	GetParamName() INamedIDContext

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeAnnotationContext

	// GetDefaultValue returns the defaultValue rule contexts.
	GetDefaultValue() IExprContext

	// SetParamName sets the paramName rule contexts.
	SetParamName(INamedIDContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeAnnotationContext)

	// SetDefaultValue sets the defaultValue rule contexts.
	SetDefaultValue(IExprContext)

	// Getter signatures
	NamedID() INamedIDContext
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	paramName    INamedIDContext
	type_        ITypeAnnotationContext
	defaultValue IExprContext
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) GetParamName() INamedIDContext { return s.paramName }

func (s *ParamContext) GetType_() ITypeAnnotationContext { return s.type_ }

func (s *ParamContext) GetDefaultValue() IExprContext { return s.defaultValue }

func (s *ParamContext) SetParamName(v INamedIDContext) { s.paramName = v }

func (s *ParamContext) SetType_(v ITypeAnnotationContext) { s.type_ = v }

func (s *ParamContext) SetDefaultValue(v IExprContext) { s.defaultValue = v }

func (s *ParamContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(348)

		var _x = p.NamedID()

		localctx.(*ParamContext).paramName = _x
	}
	{
		p.SetState(349)

		var _x = p.TypeAnnotation()

		localctx.(*ParamContext).type_ = _x
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(350)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(351)

			var _x = p.Expr()

			localctx.(*ParamContext).defaultValue = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTypeName returns the typeName rule contexts.
	GetTypeName() INamedIDContext

	// SetTypeName sets the typeName rule contexts.
	SetTypeName(INamedIDContext)

	// Getter signatures
	TYPE() antlr.TerminalNode
	NamedID() INamedIDContext
	TypeDefBody() ITypeDefBodyContext
	TypeAlias() ITypeAliasContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	typeName INamedIDContext
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) GetTypeName() INamedIDContext { return s.typeName }

func (s *TypeDeclContext) SetTypeName(v INamedIDContext) { s.typeName = v }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *TypeDeclContext) TypeDefBody() ITypeDefBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefBodyContext)
}

func (s *TypeDeclContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_typeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)

		var _x = p.NamedID()

		localctx.(*TypeDeclContext).typeName = _x
	}
	p.SetState(358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEXTENDS, ManuscriptLBRACE:
		{
			p.SetState(356)
			p.TypeDefBody()
		}

	case ManuscriptEQUALS:
		{
			p.SetState(357)
			p.TypeAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefBodyContext is an interface to support dynamic dispatch.
type ITypeDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetExtendedTypes returns the extendedTypes rule contexts.
	GetExtendedTypes() ITypeListContext

	// Get_fieldDecl returns the _fieldDecl rule contexts.
	Get_fieldDecl() IFieldDeclContext

	// SetExtendedTypes sets the extendedTypes rule contexts.
	SetExtendedTypes(ITypeListContext)

	// Set_fieldDecl sets the _fieldDecl rule contexts.
	Set_fieldDecl(IFieldDeclContext)

	// GetFields returns the fields rule context list.
	GetFields() []IFieldDeclContext

	// SetFields sets the fields rule context list.
	SetFields([]IFieldDeclContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDefBodyContext differentiates from other interfaces.
	IsTypeDefBodyContext()
}

type TypeDefBodyContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	extendedTypes ITypeListContext
	_fieldDecl    IFieldDeclContext
	fields        []IFieldDeclContext
}

func NewEmptyTypeDefBodyContext() *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
	return p
}

func InitEmptyTypeDefBodyContext(p *TypeDefBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
}

func (*TypeDefBodyContext) IsTypeDefBodyContext() {}

func NewTypeDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDefBody

	return p
}

func (s *TypeDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefBodyContext) GetExtendedTypes() ITypeListContext { return s.extendedTypes }

func (s *TypeDefBodyContext) Get_fieldDecl() IFieldDeclContext { return s._fieldDecl }

func (s *TypeDefBodyContext) SetExtendedTypes(v ITypeListContext) { s.extendedTypes = v }

func (s *TypeDefBodyContext) Set_fieldDecl(v IFieldDeclContext) { s._fieldDecl = v }

func (s *TypeDefBodyContext) GetFields() []IFieldDeclContext { return s.fields }

func (s *TypeDefBodyContext) SetFields(v []IFieldDeclContext) { s.fields = v }

func (s *TypeDefBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDefBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDefBodyContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDefBodyContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeDefBodyContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDefBodyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDefBodyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDefBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDefBody() (localctx ITypeDefBodyContext) {
	localctx = NewTypeDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_typeDefBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(360)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(361)

			var _x = p.TypeList()

			localctx.(*TypeDefBodyContext).extendedTypes = _x
		}

	}
	{
		p.SetState(364)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(365)

			var _x = p.FieldDecl()

			localctx.(*TypeDefBodyContext)._fieldDecl = _x
		}
		localctx.(*TypeDefBodyContext).fields = append(localctx.(*TypeDefBodyContext).fields, localctx.(*TypeDefBodyContext)._fieldDecl)
		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(366)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(367)

					var _x = p.FieldDecl()

					localctx.(*TypeDefBodyContext)._fieldDecl = _x
				}
				localctx.(*TypeDefBodyContext).fields = append(localctx.(*TypeDefBodyContext).fields, localctx.(*TypeDefBodyContext)._fieldDecl)

			}
			p.SetState(372)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(373)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(378)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAliasTarget returns the aliasTarget rule contexts.
	GetAliasTarget() ITypeAnnotationContext

	// GetConstraintTypes returns the constraintTypes rule contexts.
	GetConstraintTypes() ITypeListContext

	// SetAliasTarget sets the aliasTarget rule contexts.
	SetAliasTarget(ITypeAnnotationContext)

	// SetConstraintTypes sets the constraintTypes rule contexts.
	SetConstraintTypes(ITypeListContext)

	// Getter signatures
	EQUALS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	aliasTarget     ITypeAnnotationContext
	constraintTypes ITypeListContext
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) GetAliasTarget() ITypeAnnotationContext { return s.aliasTarget }

func (s *TypeAliasContext) GetConstraintTypes() ITypeListContext { return s.constraintTypes }

func (s *TypeAliasContext) SetAliasTarget(v ITypeAnnotationContext) { s.aliasTarget = v }

func (s *TypeAliasContext) SetConstraintTypes(v ITypeListContext) { s.constraintTypes = v }

func (s *TypeAliasContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *TypeAliasContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAliasContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeAliasContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(380)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(381)

		var _x = p.TypeAnnotation()

		localctx.(*TypeAliasContext).aliasTarget = _x
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(382)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)

			var _x = p.TypeList()

			localctx.(*TypeAliasContext).constraintTypes = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIsOptionalField returns the isOptionalField token.
	GetIsOptionalField() antlr.Token

	// SetIsOptionalField sets the isOptionalField token.
	SetIsOptionalField(antlr.Token)

	// GetFieldName returns the fieldName rule contexts.
	GetFieldName() INamedIDContext

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeAnnotationContext

	// SetFieldName sets the fieldName rule contexts.
	SetFieldName(INamedIDContext)

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeAnnotationContext)

	// Getter signatures
	NamedID() INamedIDContext
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	fieldName       INamedIDContext
	isOptionalField antlr.Token
	type_           ITypeAnnotationContext
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) GetIsOptionalField() antlr.Token { return s.isOptionalField }

func (s *FieldDeclContext) SetIsOptionalField(v antlr.Token) { s.isOptionalField = v }

func (s *FieldDeclContext) GetFieldName() INamedIDContext { return s.fieldName }

func (s *FieldDeclContext) GetType_() ITypeAnnotationContext { return s.type_ }

func (s *FieldDeclContext) SetFieldName(v INamedIDContext) { s.fieldName = v }

func (s *FieldDeclContext) SetType_(v ITypeAnnotationContext) { s.type_ = v }

func (s *FieldDeclContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)

		var _x = p.NamedID()

		localctx.(*FieldDeclContext).fieldName = _x
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(387)

			var _m = p.Match(ManuscriptQUESTION)

			localctx.(*FieldDeclContext).isOptionalField = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(390)

		var _x = p.TypeAnnotation()

		localctx.(*FieldDeclContext).type_ = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInterfaceName returns the interfaceName rule contexts.
	GetInterfaceName() INamedIDContext

	// GetExtendedInterfaces returns the extendedInterfaces rule contexts.
	GetExtendedInterfaces() ITypeListContext

	// Get_interfaceMethod returns the _interfaceMethod rule contexts.
	Get_interfaceMethod() IInterfaceMethodContext

	// SetInterfaceName sets the interfaceName rule contexts.
	SetInterfaceName(INamedIDContext)

	// SetExtendedInterfaces sets the extendedInterfaces rule contexts.
	SetExtendedInterfaces(ITypeListContext)

	// Set_interfaceMethod sets the _interfaceMethod rule contexts.
	Set_interfaceMethod(IInterfaceMethodContext)

	// GetMethods returns the methods rule context list.
	GetMethods() []IInterfaceMethodContext

	// SetMethods sets the methods rule context list.
	SetMethods([]IInterfaceMethodContext)

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	NamedID() INamedIDContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	interfaceName      INamedIDContext
	extendedInterfaces ITypeListContext
	_interfaceMethod   IInterfaceMethodContext
	methods            []IInterfaceMethodContext
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) GetInterfaceName() INamedIDContext { return s.interfaceName }

func (s *InterfaceDeclContext) GetExtendedInterfaces() ITypeListContext { return s.extendedInterfaces }

func (s *InterfaceDeclContext) Get_interfaceMethod() IInterfaceMethodContext {
	return s._interfaceMethod
}

func (s *InterfaceDeclContext) SetInterfaceName(v INamedIDContext) { s.interfaceName = v }

func (s *InterfaceDeclContext) SetExtendedInterfaces(v ITypeListContext) { s.extendedInterfaces = v }

func (s *InterfaceDeclContext) Set_interfaceMethod(v IInterfaceMethodContext) { s._interfaceMethod = v }

func (s *InterfaceDeclContext) GetMethods() []IInterfaceMethodContext { return s.methods }

func (s *InterfaceDeclContext) SetMethods(v []IInterfaceMethodContext) { s.methods = v }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *InterfaceDeclContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *InterfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *InterfaceDeclContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_interfaceDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(392)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(393)

		var _x = p.NamedID()

		localctx.(*InterfaceDeclContext).interfaceName = _x
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(394)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(395)

			var _x = p.TypeList()

			localctx.(*InterfaceDeclContext).extendedInterfaces = _x
		}

	}
	{
		p.SetState(398)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptID {
		{
			p.SetState(399)

			var _x = p.InterfaceMethod()

			localctx.(*InterfaceDeclContext)._interfaceMethod = _x
		}
		localctx.(*InterfaceDeclContext).methods = append(localctx.(*InterfaceDeclContext).methods, localctx.(*InterfaceDeclContext)._interfaceMethod)

		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(404)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnsError returns the returnsError token.
	GetReturnsError() antlr.Token

	// SetReturnsError sets the returnsError token.
	SetReturnsError(antlr.Token)

	// GetMethodName returns the methodName rule contexts.
	GetMethodName() INamedIDContext

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// SetMethodName sets the methodName rule contexts.
	SetMethodName(INamedIDContext)

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	NamedID() INamedIDContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	methodName   INamedIDContext
	params       IParametersContext
	returnType   ITypeAnnotationContext
	returnsError antlr.Token
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) GetReturnsError() antlr.Token { return s.returnsError }

func (s *InterfaceMethodContext) SetReturnsError(v antlr.Token) { s.returnsError = v }

func (s *InterfaceMethodContext) GetMethodName() INamedIDContext { return s.methodName }

func (s *InterfaceMethodContext) GetParams() IParametersContext { return s.params }

func (s *InterfaceMethodContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *InterfaceMethodContext) SetMethodName(v INamedIDContext) { s.methodName = v }

func (s *InterfaceMethodContext) SetParams(v IParametersContext) { s.params = v }

func (s *InterfaceMethodContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *InterfaceMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *InterfaceMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *InterfaceMethodContext) NamedID() INamedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedIDContext)
}

func (s *InterfaceMethodContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *InterfaceMethodContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *InterfaceMethodContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(406)

		var _x = p.NamedID()

		localctx.(*InterfaceMethodContext).methodName = _x
	}
	{
		p.SetState(407)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(408)

			var _x = p.Parameters()

			localctx.(*InterfaceMethodContext).params = _x
		}

	}
	{
		p.SetState(411)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(412)

			var _x = p.TypeAnnotation()

			localctx.(*InterfaceMethodContext).returnType = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(415)

			var _m = p.Match(ManuscriptEXCLAMATION)

			localctx.(*InterfaceMethodContext).returnsError = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodsDeclContext is an interface to support dynamic dispatch.
type IMethodsDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTarget returns the target token.
	GetTarget() antlr.Token

	// GetReceiver returns the receiver token.
	GetReceiver() antlr.Token

	// SetTarget sets the target token.
	SetTarget(antlr.Token)

	// SetReceiver sets the receiver token.
	SetReceiver(antlr.Token)

	// Getter signatures
	METHODS() antlr.TerminalNode
	AS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext

	// IsMethodsDeclContext differentiates from other interfaces.
	IsMethodsDeclContext()
}

type MethodsDeclContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	target   antlr.Token
	receiver antlr.Token
}

func NewEmptyMethodsDeclContext() *MethodsDeclContext {
	var p = new(MethodsDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
	return p
}

func InitEmptyMethodsDeclContext(p *MethodsDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
}

func (*MethodsDeclContext) IsMethodsDeclContext() {}

func NewMethodsDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodsDeclContext {
	var p = new(MethodsDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodsDecl

	return p
}

func (s *MethodsDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodsDeclContext) GetTarget() antlr.Token { return s.target }

func (s *MethodsDeclContext) GetReceiver() antlr.Token { return s.receiver }

func (s *MethodsDeclContext) SetTarget(v antlr.Token) { s.target = v }

func (s *MethodsDeclContext) SetReceiver(v antlr.Token) { s.receiver = v }

func (s *MethodsDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodsDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *MethodsDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodsDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodsDeclContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *MethodsDeclContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *MethodsDeclContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodsDeclContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodsDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodsDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodsDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodsDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodsDecl() (localctx IMethodsDeclContext) {
	localctx = NewMethodsDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_methodsDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(418)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(419)

		var _m = p.Match(ManuscriptID)

		localctx.(*MethodsDeclContext).target = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(420)
		p.Match(ManuscriptAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(421)

		var _m = p.Match(ManuscriptID)

		localctx.(*MethodsDeclContext).receiver = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptID {
		{
			p.SetState(423)
			p.MethodImpl()
		}

		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(429)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMethod returns the method rule contexts.
	GetMethod() IInterfaceMethodContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetMethod sets the method rule contexts.
	SetMethod(IInterfaceMethodContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	InterfaceMethod() IInterfaceMethodContext
	CodeBlock() ICodeBlockContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	method IInterfaceMethodContext
	block  ICodeBlockContext
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) GetMethod() IInterfaceMethodContext { return s.method }

func (s *MethodImplContext) GetBlock() ICodeBlockContext { return s.block }

func (s *MethodImplContext) SetMethod(v IInterfaceMethodContext) { s.method = v }

func (s *MethodImplContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *MethodImplContext) InterfaceMethod() IInterfaceMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_methodImpl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(431)

		var _x = p.InterfaceMethod()

		localctx.(*MethodImplContext).method = _x
	}
	{
		p.SetState(432)

		var _x = p.CodeBlock()

		localctx.(*MethodImplContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIdAsType returns the idAsType token.
	GetIdAsType() antlr.Token

	// GetIsNullable returns the isNullable token.
	GetIsNullable() antlr.Token

	// GetArrayMarker returns the arrayMarker token.
	GetArrayMarker() antlr.Token

	// SetIdAsType sets the idAsType token.
	SetIdAsType(antlr.Token)

	// SetIsNullable sets the isNullable token.
	SetIsNullable(antlr.Token)

	// SetArrayMarker sets the arrayMarker token.
	SetArrayMarker(antlr.Token)

	// GetTupleAsType returns the tupleAsType rule contexts.
	GetTupleAsType() ITupleTypeContext

	// GetFuncAsType returns the funcAsType rule contexts.
	GetFuncAsType() IFnSignatureContext

	// SetTupleAsType sets the tupleAsType rule contexts.
	SetTupleAsType(ITupleTypeContext)

	// SetFuncAsType sets the funcAsType rule contexts.
	SetFuncAsType(IFnSignatureContext)

	// Getter signatures
	VOID() antlr.TerminalNode
	ID() antlr.TerminalNode
	TupleType() ITupleTypeContext
	FnSignature() IFnSignatureContext
	RSQBR() antlr.TerminalNode
	QUESTION() antlr.TerminalNode
	LSQBR() antlr.TerminalNode

	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	idAsType    antlr.Token
	tupleAsType ITupleTypeContext
	funcAsType  IFnSignatureContext
	isNullable  antlr.Token
	arrayMarker antlr.Token
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) GetIdAsType() antlr.Token { return s.idAsType }

func (s *TypeAnnotationContext) GetIsNullable() antlr.Token { return s.isNullable }

func (s *TypeAnnotationContext) GetArrayMarker() antlr.Token { return s.arrayMarker }

func (s *TypeAnnotationContext) SetIdAsType(v antlr.Token) { s.idAsType = v }

func (s *TypeAnnotationContext) SetIsNullable(v antlr.Token) { s.isNullable = v }

func (s *TypeAnnotationContext) SetArrayMarker(v antlr.Token) { s.arrayMarker = v }

func (s *TypeAnnotationContext) GetTupleAsType() ITupleTypeContext { return s.tupleAsType }

func (s *TypeAnnotationContext) GetFuncAsType() IFnSignatureContext { return s.funcAsType }

func (s *TypeAnnotationContext) SetTupleAsType(v ITupleTypeContext) { s.tupleAsType = v }

func (s *TypeAnnotationContext) SetFuncAsType(v IFnSignatureContext) { s.funcAsType = v }

func (s *TypeAnnotationContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *TypeAnnotationContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeAnnotationContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *TypeAnnotationContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *TypeAnnotationContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *TypeAnnotationContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TypeAnnotationContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_typeAnnotation)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		{
			p.SetState(434)

			var _m = p.Match(ManuscriptID)

			localctx.(*TypeAnnotationContext).idAsType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLPAREN:
		{
			p.SetState(435)

			var _x = p.TupleType()

			localctx.(*TypeAnnotationContext).tupleAsType = _x
		}

	case ManuscriptFN:
		{
			p.SetState(436)

			var _x = p.FnSignature()

			localctx.(*TypeAnnotationContext).funcAsType = _x
		}

	case ManuscriptVOID:
		{
			p.SetState(437)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(440)

			var _m = p.Match(ManuscriptQUESTION)

			localctx.(*TypeAnnotationContext).isNullable = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(443)

			var _m = p.Match(ManuscriptLSQBR)

			localctx.(*TypeAnnotationContext).arrayMarker = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(444)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetElements returns the elements rule contexts.
	GetElements() ITypeListContext

	// SetElements sets the elements rule contexts.
	SetElements(ITypeListContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	elements ITypeListContext
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) GetElements() ITypeListContext { return s.elements }

func (s *TupleTypeContext) SetElements(v ITypeListContext) { s.elements = v }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093030432) != 0) || _la == ManuscriptID {
		{
			p.SetState(448)

			var _x = p.TypeList()

			localctx.(*TupleTypeContext).elements = _x
		}

	}
	{
		p.SetState(451)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSLetDecl returns the sLetDecl rule contexts.
	GetSLetDecl() ILetDeclContext

	// GetSExpr returns the sExpr rule contexts.
	GetSExpr() IExprContext

	// GetSReturn returns the sReturn rule contexts.
	GetSReturn() IReturnStmtContext

	// GetSYield returns the sYield rule contexts.
	GetSYield() IYieldStmtContext

	// GetSIf returns the sIf rule contexts.
	GetSIf() IIfStmtContext

	// GetSFor returns the sFor rule contexts.
	GetSFor() IForStmtContext

	// GetSWhile returns the sWhile rule contexts.
	GetSWhile() IWhileStmtContext

	// GetSCodeBlock returns the sCodeBlock rule contexts.
	GetSCodeBlock() ICodeBlockContext

	// GetSBreak returns the sBreak rule contexts.
	GetSBreak() IBreakStmtContext

	// GetSContinue returns the sContinue rule contexts.
	GetSContinue() IContinueStmtContext

	// GetSCheck returns the sCheck rule contexts.
	GetSCheck() ICheckStmtContext

	// GetSDefer returns the sDefer rule contexts.
	GetSDefer() IDeferStmtContext

	// SetSLetDecl sets the sLetDecl rule contexts.
	SetSLetDecl(ILetDeclContext)

	// SetSExpr sets the sExpr rule contexts.
	SetSExpr(IExprContext)

	// SetSReturn sets the sReturn rule contexts.
	SetSReturn(IReturnStmtContext)

	// SetSYield sets the sYield rule contexts.
	SetSYield(IYieldStmtContext)

	// SetSIf sets the sIf rule contexts.
	SetSIf(IIfStmtContext)

	// SetSFor sets the sFor rule contexts.
	SetSFor(IForStmtContext)

	// SetSWhile sets the sWhile rule contexts.
	SetSWhile(IWhileStmtContext)

	// SetSCodeBlock sets the sCodeBlock rule contexts.
	SetSCodeBlock(ICodeBlockContext)

	// SetSBreak sets the sBreak rule contexts.
	SetSBreak(IBreakStmtContext)

	// SetSContinue sets the sContinue rule contexts.
	SetSContinue(IContinueStmtContext)

	// SetSCheck sets the sCheck rule contexts.
	SetSCheck(ICheckStmtContext)

	// SetSDefer sets the sDefer rule contexts.
	SetSDefer(IDeferStmtContext)

	// Getter signatures
	LetDecl() ILetDeclContext
	Expr() IExprContext
	ReturnStmt() IReturnStmtContext
	YieldStmt() IYieldStmtContext
	IfStmt() IIfStmtContext
	ForStmt() IForStmtContext
	WhileStmt() IWhileStmtContext
	CodeBlock() ICodeBlockContext
	BreakStmt() IBreakStmtContext
	ContinueStmt() IContinueStmtContext
	CheckStmt() ICheckStmtContext
	DeferStmt() IDeferStmtContext
	SEMICOLON() antlr.TerminalNode

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	sLetDecl   ILetDeclContext
	sExpr      IExprContext
	sReturn    IReturnStmtContext
	sYield     IYieldStmtContext
	sIf        IIfStmtContext
	sFor       IForStmtContext
	sWhile     IWhileStmtContext
	sCodeBlock ICodeBlockContext
	sBreak     IBreakStmtContext
	sContinue  IContinueStmtContext
	sCheck     ICheckStmtContext
	sDefer     IDeferStmtContext
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) GetSLetDecl() ILetDeclContext { return s.sLetDecl }

func (s *StmtContext) GetSExpr() IExprContext { return s.sExpr }

func (s *StmtContext) GetSReturn() IReturnStmtContext { return s.sReturn }

func (s *StmtContext) GetSYield() IYieldStmtContext { return s.sYield }

func (s *StmtContext) GetSIf() IIfStmtContext { return s.sIf }

func (s *StmtContext) GetSFor() IForStmtContext { return s.sFor }

func (s *StmtContext) GetSWhile() IWhileStmtContext { return s.sWhile }

func (s *StmtContext) GetSCodeBlock() ICodeBlockContext { return s.sCodeBlock }

func (s *StmtContext) GetSBreak() IBreakStmtContext { return s.sBreak }

func (s *StmtContext) GetSContinue() IContinueStmtContext { return s.sContinue }

func (s *StmtContext) GetSCheck() ICheckStmtContext { return s.sCheck }

func (s *StmtContext) GetSDefer() IDeferStmtContext { return s.sDefer }

func (s *StmtContext) SetSLetDecl(v ILetDeclContext) { s.sLetDecl = v }

func (s *StmtContext) SetSExpr(v IExprContext) { s.sExpr = v }

func (s *StmtContext) SetSReturn(v IReturnStmtContext) { s.sReturn = v }

func (s *StmtContext) SetSYield(v IYieldStmtContext) { s.sYield = v }

func (s *StmtContext) SetSIf(v IIfStmtContext) { s.sIf = v }

func (s *StmtContext) SetSFor(v IForStmtContext) { s.sFor = v }

func (s *StmtContext) SetSWhile(v IWhileStmtContext) { s.sWhile = v }

func (s *StmtContext) SetSCodeBlock(v ICodeBlockContext) { s.sCodeBlock = v }

func (s *StmtContext) SetSBreak(v IBreakStmtContext) { s.sBreak = v }

func (s *StmtContext) SetSContinue(v IContinueStmtContext) { s.sContinue = v }

func (s *StmtContext) SetSCheck(v ICheckStmtContext) { s.sCheck = v }

func (s *StmtContext) SetSDefer(v IDeferStmtContext) { s.sDefer = v }

func (s *StmtContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *StmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *StmtContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *StmtContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StmtContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *StmtContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *StmtContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *StmtContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *StmtContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *StmtContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *StmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_stmt)
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLET, ManuscriptFN, ManuscriptRETURN, ManuscriptYIELD, ManuscriptVOID, ManuscriptCHECK, ManuscriptTRY, ManuscriptNULL, ManuscriptIF, ManuscriptFOR, ManuscriptWHILE, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptASYNC, ManuscriptAWAIT, ManuscriptBREAK, ManuscriptCONTINUE, ManuscriptDEFER, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(453)

				var _x = p.LetDecl()

				localctx.(*StmtContext).sLetDecl = _x
			}

		case 2:
			{
				p.SetState(454)

				var _x = p.Expr()

				localctx.(*StmtContext).sExpr = _x
			}

		case 3:
			{
				p.SetState(455)

				var _x = p.ReturnStmt()

				localctx.(*StmtContext).sReturn = _x
			}

		case 4:
			{
				p.SetState(456)

				var _x = p.YieldStmt()

				localctx.(*StmtContext).sYield = _x
			}

		case 5:
			{
				p.SetState(457)

				var _x = p.IfStmt()

				localctx.(*StmtContext).sIf = _x
			}

		case 6:
			{
				p.SetState(458)

				var _x = p.ForStmt()

				localctx.(*StmtContext).sFor = _x
			}

		case 7:
			{
				p.SetState(459)

				var _x = p.WhileStmt()

				localctx.(*StmtContext).sWhile = _x
			}

		case 8:
			{
				p.SetState(460)

				var _x = p.CodeBlock()

				localctx.(*StmtContext).sCodeBlock = _x
			}

		case 9:
			{
				p.SetState(461)

				var _x = p.BreakStmt()

				localctx.(*StmtContext).sBreak = _x
			}

		case 10:
			{
				p.SetState(462)

				var _x = p.ContinueStmt()

				localctx.(*StmtContext).sContinue = _x
			}

		case 11:
			{
				p.SetState(463)

				var _x = p.CheckStmt()

				localctx.(*StmtContext).sCheck = _x
			}

		case 12:
			{
				p.SetState(464)

				var _x = p.DeferStmt()

				localctx.(*StmtContext).sDefer = _x
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(468)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(467)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case ManuscriptSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(470)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetReturnedValues returns the returnedValues rule contexts.
	GetReturnedValues() IExprListContext

	// SetReturnedValues sets the returnedValues rule contexts.
	SetReturnedValues(IExprListContext)

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExprList() IExprListContext

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	returnedValues IExprListContext
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) GetReturnedValues() IExprListContext { return s.returnedValues }

func (s *ReturnStmtContext) SetReturnedValues(v IExprListContext) { s.returnedValues = v }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_returnStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(473)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(474)

			var _x = p.ExprList()

			localctx.(*ReturnStmtContext).returnedValues = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetYieldedValues returns the yieldedValues rule contexts.
	GetYieldedValues() IExprListContext

	// SetYieldedValues sets the yieldedValues rule contexts.
	SetYieldedValues(IExprListContext)

	// Getter signatures
	YIELD() antlr.TerminalNode
	ExprList() IExprListContext

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	yieldedValues IExprListContext
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) GetYieldedValues() IExprListContext { return s.yieldedValues }

func (s *YieldStmtContext) SetYieldedValues(v IExprListContext) { s.yieldedValues = v }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_yieldStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(477)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(478)

			var _x = p.ExprList()

			localctx.(*YieldStmtContext).yieldedValues = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expr() IExprContext

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFER, 0)
}

func (s *DeferStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(ManuscriptDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(482)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.Expr()
	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(485)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(486)
				p.Expr()
			}

		}
		p.SetState(491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(492)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetThenBlock returns the thenBlock rule contexts.
	GetThenBlock() ICodeBlockContext

	// GetElseBlock returns the elseBlock rule contexts.
	GetElseBlock() ICodeBlockContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetThenBlock sets the thenBlock rule contexts.
	SetThenBlock(ICodeBlockContext)

	// SetElseBlock sets the elseBlock rule contexts.
	SetElseBlock(ICodeBlockContext)

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
	thenBlock ICodeBlockContext
	elseBlock ICodeBlockContext
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) GetCondition() IExprContext { return s.condition }

func (s *IfStmtContext) GetThenBlock() ICodeBlockContext { return s.thenBlock }

func (s *IfStmtContext) GetElseBlock() ICodeBlockContext { return s.elseBlock }

func (s *IfStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *IfStmtContext) SetThenBlock(v ICodeBlockContext) { s.thenBlock = v }

func (s *IfStmtContext) SetElseBlock(v ICodeBlockContext) { s.elseBlock = v }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(496)

		var _x = p.Expr()

		localctx.(*IfStmtContext).condition = _x
	}
	{
		p.SetState(497)

		var _x = p.CodeBlock()

		localctx.(*IfStmtContext).thenBlock = _x
	}
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(498)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(499)

			var _x = p.CodeBlock()

			localctx.(*IfStmtContext).elseBlock = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ rule contexts.
	GetType_() IForLoopTypeContext

	// SetType_ sets the type_ rule contexts.
	SetType_(IForLoopTypeContext)

	// Getter signatures
	FOR() antlr.TerminalNode
	ForLoopType() IForLoopTypeContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  IForLoopTypeContext
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) GetType_() IForLoopTypeContext { return s.type_ }

func (s *ForStmtContext) SetType_(v IForLoopTypeContext) { s.type_ = v }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) ForLoopType() IForLoopTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForLoopTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForLoopTypeContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(502)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(503)

		var _x = p.ForLoopType()

		localctx.(*ForStmtContext).type_ = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForLoopTypeContext is an interface to support dynamic dispatch.
type IForLoopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForLoopTypeContext differentiates from other interfaces.
	IsForLoopTypeContext()
}

type ForLoopTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopTypeContext() *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
	return p
}

func InitEmptyForLoopTypeContext(p *ForLoopTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
}

func (*ForLoopTypeContext) IsForLoopTypeContext() {}

func NewForLoopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forLoopType

	return p
}

func (s *ForLoopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopTypeContext) CopyAll(ctx *ForLoopTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForLoopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ForInLoopContext struct {
	ForLoopTypeContext
	key      antlr.Token
	val      antlr.Token
	iterable IExprContext
}

func NewForInLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInLoopContext {
	var p = new(ForInLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *ForInLoopContext) GetKey() antlr.Token { return s.key }

func (s *ForInLoopContext) GetVal() antlr.Token { return s.val }

func (s *ForInLoopContext) SetKey(v antlr.Token) { s.key = v }

func (s *ForInLoopContext) SetVal(v antlr.Token) { s.val = v }

func (s *ForInLoopContext) GetIterable() IExprContext { return s.iterable }

func (s *ForInLoopContext) SetIterable(v IExprContext) { s.iterable = v }

func (s *ForInLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInLoopContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *ForInLoopContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForInLoopContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForInLoopContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ForInLoopContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ForInLoopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *ForInLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForInLoop(s)
	}
}

func (s *ForInLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForInLoop(s)
	}
}

func (s *ForInLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForInLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForLoopContext struct {
	ForLoopTypeContext
}

func NewForLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForLoopContext {
	var p = new(ForLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *ForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopContext) ForTrinity() IForTrinityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForTrinityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForTrinityContext)
}

func (s *ForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForLoop(s)
	}
}

func (s *ForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForLoop(s)
	}
}

func (s *ForLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForLoopType() (localctx IForLoopTypeContext) {
	localctx = NewForLoopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_forLoopType)
	var _la int

	p.SetState(515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		localctx = NewForLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(505)
			p.ForTrinity()
		}

	case 2:
		localctx = NewForInLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(506)

			var _m = p.Match(ManuscriptID)

			localctx.(*ForInLoopContext).key = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(507)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(508)

				var _m = p.Match(ManuscriptID)

				localctx.(*ForInLoopContext).val = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(511)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)

			var _x = p.Expr()

			localctx.(*ForInLoopContext).iterable = _x
		}
		{
			p.SetState(513)
			p.LoopBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForTrinityContext is an interface to support dynamic dispatch.
type IForTrinityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInitializerDecl returns the initializerDecl rule contexts.
	GetInitializerDecl() ILetSingleContext

	// GetInitializerExprs returns the initializerExprs rule contexts.
	GetInitializerExprs() IExprListContext

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetPostUpdate returns the postUpdate rule contexts.
	GetPostUpdate() IExprListContext

	// GetBody returns the body rule contexts.
	GetBody() ILoopBodyContext

	// SetInitializerDecl sets the initializerDecl rule contexts.
	SetInitializerDecl(ILetSingleContext)

	// SetInitializerExprs sets the initializerExprs rule contexts.
	SetInitializerExprs(IExprListContext)

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetPostUpdate sets the postUpdate rule contexts.
	SetPostUpdate(IExprListContext)

	// SetBody sets the body rule contexts.
	SetBody(ILoopBodyContext)

	// Getter signatures
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	LoopBody() ILoopBodyContext
	LetSingle() ILetSingleContext
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext
	Expr() IExprContext

	// IsForTrinityContext differentiates from other interfaces.
	IsForTrinityContext()
}

type ForTrinityContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	initializerDecl  ILetSingleContext
	initializerExprs IExprListContext
	condition        IExprContext
	postUpdate       IExprListContext
	body             ILoopBodyContext
}

func NewEmptyForTrinityContext() *ForTrinityContext {
	var p = new(ForTrinityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
	return p
}

func InitEmptyForTrinityContext(p *ForTrinityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
}

func (*ForTrinityContext) IsForTrinityContext() {}

func NewForTrinityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForTrinityContext {
	var p = new(ForTrinityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forTrinity

	return p
}

func (s *ForTrinityContext) GetParser() antlr.Parser { return s.parser }

func (s *ForTrinityContext) GetInitializerDecl() ILetSingleContext { return s.initializerDecl }

func (s *ForTrinityContext) GetInitializerExprs() IExprListContext { return s.initializerExprs }

func (s *ForTrinityContext) GetCondition() IExprContext { return s.condition }

func (s *ForTrinityContext) GetPostUpdate() IExprListContext { return s.postUpdate }

func (s *ForTrinityContext) GetBody() ILoopBodyContext { return s.body }

func (s *ForTrinityContext) SetInitializerDecl(v ILetSingleContext) { s.initializerDecl = v }

func (s *ForTrinityContext) SetInitializerExprs(v IExprListContext) { s.initializerExprs = v }

func (s *ForTrinityContext) SetCondition(v IExprContext) { s.condition = v }

func (s *ForTrinityContext) SetPostUpdate(v IExprListContext) { s.postUpdate = v }

func (s *ForTrinityContext) SetBody(v ILoopBodyContext) { s.body = v }

func (s *ForTrinityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForTrinityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForTrinityContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForTrinityContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *ForTrinityContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *ForTrinityContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ForTrinityContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForTrinityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForTrinityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForTrinityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForTrinity(s)
	}
}

func (s *ForTrinityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForTrinity(s)
	}
}

func (s *ForTrinityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForTrinity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForTrinity() (localctx IForTrinityContext) {
	localctx = NewForTrinityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_forTrinity)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(519)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(517)

			var _x = p.LetSingle()

			localctx.(*ForTrinityContext).initializerDecl = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(518)

			var _x = p.ExprList()

			localctx.(*ForTrinityContext).initializerExprs = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(521)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(522)

			var _x = p.Expr()

			localctx.(*ForTrinityContext).condition = _x
		}

	}
	{
		p.SetState(525)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(526)

			var _x = p.ExprList()

			localctx.(*ForTrinityContext).postUpdate = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(529)

		var _x = p.LoopBody()

		localctx.(*ForTrinityContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// Getter signatures
	WHILE() antlr.TerminalNode
	LoopBody() ILoopBodyContext
	Expr() IExprContext

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) GetCondition() IExprContext { return s.condition }

func (s *WhileStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(532)

		var _x = p.Expr()

		localctx.(*WhileStmtContext).condition = _x
	}
	{
		p.SetState(533)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBodyContext is an interface to support dynamic dispatch.
type ILoopBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stmt returns the _stmt rule contexts.
	Get_stmt() IStmtContext

	// Set_stmt sets the _stmt rule contexts.
	Set_stmt(IStmtContext)

	// GetBodyStmts returns the bodyStmts rule context list.
	GetBodyStmts() []IStmtContext

	// SetBodyStmts sets the bodyStmts rule context list.
	SetBodyStmts([]IStmtContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsLoopBodyContext differentiates from other interfaces.
	IsLoopBodyContext()
}

type LoopBodyContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_stmt     IStmtContext
	bodyStmts []IStmtContext
}

func NewEmptyLoopBodyContext() *LoopBodyContext {
	var p = new(LoopBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
	return p
}

func InitEmptyLoopBodyContext(p *LoopBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
}

func (*LoopBodyContext) IsLoopBodyContext() {}

func NewLoopBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBodyContext {
	var p = new(LoopBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopBody

	return p
}

func (s *LoopBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBodyContext) Get_stmt() IStmtContext { return s._stmt }

func (s *LoopBodyContext) Set_stmt(v IStmtContext) { s._stmt = v }

func (s *LoopBodyContext) GetBodyStmts() []IStmtContext { return s.bodyStmts }

func (s *LoopBodyContext) SetBodyStmts(v []IStmtContext) { s.bodyStmts = v }

func (s *LoopBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LoopBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LoopBodyContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *LoopBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopBody(s)
	}
}

func (s *LoopBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopBody(s)
	}
}

func (s *LoopBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopBody() (localctx ILoopBodyContext) {
	localctx = NewLoopBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_loopBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9168156015701466896) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(536)

			var _x = p.Stmt()

			localctx.(*LoopBodyContext)._stmt = _x
		}
		localctx.(*LoopBodyContext).bodyStmts = append(localctx.(*LoopBodyContext).bodyStmts, localctx.(*LoopBodyContext)._stmt)

		p.SetState(541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(542)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stmt returns the _stmt rule contexts.
	Get_stmt() IStmtContext

	// Set_stmt sets the _stmt rule contexts.
	Set_stmt(IStmtContext)

	// GetStmts returns the stmts rule context list.
	GetStmts() []IStmtContext

	// SetStmts sets the stmts rule context list.
	SetStmts([]IStmtContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_stmt  IStmtContext
	stmts  []IStmtContext
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) Get_stmt() IStmtContext { return s._stmt }

func (s *CodeBlockContext) Set_stmt(v IStmtContext) { s._stmt = v }

func (s *CodeBlockContext) GetStmts() []IStmtContext { return s.stmts }

func (s *CodeBlockContext) SetStmts(v []IStmtContext) { s.stmts = v }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_codeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9168156015701466896) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(545)

			var _x = p.Stmt()

			localctx.(*CodeBlockContext)._stmt = _x
		}
		localctx.(*CodeBlockContext).stmts = append(localctx.(*CodeBlockContext).stmts, localctx.(*CodeBlockContext)._stmt)

		p.SetState(550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(551)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ITernaryExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ITernaryExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	TernaryExpr() ITernaryExprContext
	AssignmentExpr() IAssignmentExprContext
	EQUALS() antlr.TerminalNode
	PLUS_EQUALS() antlr.TerminalNode
	MINUS_EQUALS() antlr.TerminalNode
	STAR_EQUALS() antlr.TerminalNode
	SLASH_EQUALS() antlr.TerminalNode
	MOD_EQUALS() antlr.TerminalNode
	CARET_EQUALS() antlr.TerminalNode

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ITernaryExprContext
	op     antlr.Token
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentExprContext) GetLeft() ITernaryExprContext { return s.left }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ITernaryExprContext) { s.left = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *AssignmentExprContext) PLUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS_EQUALS, 0)
}

func (s *AssignmentExprContext) MINUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS_EQUALS, 0)
}

func (s *AssignmentExprContext) STAR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR_EQUALS, 0)
}

func (s *AssignmentExprContext) SLASH_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH_EQUALS, 0)
}

func (s *AssignmentExprContext) MOD_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD_EQUALS, 0)
}

func (s *AssignmentExprContext) CARET_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET_EQUALS, 0)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_assignmentExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)

		var _x = p.TernaryExpr()

		localctx.(*AssignmentExprContext).left = _x
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-52)) & ^0x3f) == 0 && ((int64(1)<<(_la-52))&2064385) != 0 {
		{
			p.SetState(556)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*AssignmentExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-52)) & ^0x3f) == 0 && ((int64(1)<<(_la-52))&2064385) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*AssignmentExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(557)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExprContext is an interface to support dynamic dispatch.
type ITernaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() ILogicalOrExprContext

	// GetTrueExpr returns the trueExpr rule contexts.
	GetTrueExpr() IExprContext

	// GetFalseExpr returns the falseExpr rule contexts.
	GetFalseExpr() ITernaryExprContext

	// SetCondition sets the condition rule contexts.
	SetCondition(ILogicalOrExprContext)

	// SetTrueExpr sets the trueExpr rule contexts.
	SetTrueExpr(IExprContext)

	// SetFalseExpr sets the falseExpr rule contexts.
	SetFalseExpr(ITernaryExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	TernaryExpr() ITernaryExprContext

	// IsTernaryExprContext differentiates from other interfaces.
	IsTernaryExprContext()
}

type TernaryExprContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition ILogicalOrExprContext
	trueExpr  IExprContext
	falseExpr ITernaryExprContext
}

func NewEmptyTernaryExprContext() *TernaryExprContext {
	var p = new(TernaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
	return p
}

func InitEmptyTernaryExprContext(p *TernaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
}

func (*TernaryExprContext) IsTernaryExprContext() {}

func NewTernaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExprContext {
	var p = new(TernaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ternaryExpr

	return p
}

func (s *TernaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExprContext) GetCondition() ILogicalOrExprContext { return s.condition }

func (s *TernaryExprContext) GetTrueExpr() IExprContext { return s.trueExpr }

func (s *TernaryExprContext) GetFalseExpr() ITernaryExprContext { return s.falseExpr }

func (s *TernaryExprContext) SetCondition(v ILogicalOrExprContext) { s.condition = v }

func (s *TernaryExprContext) SetTrueExpr(v IExprContext) { s.trueExpr = v }

func (s *TernaryExprContext) SetFalseExpr(v ITernaryExprContext) { s.falseExpr = v }

func (s *TernaryExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *TernaryExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TernaryExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *TernaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TernaryExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TernaryExpr() (localctx ITernaryExprContext) {
	localctx = NewTernaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_ternaryExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(560)

		var _x = p.LogicalOrExpr()

		localctx.(*TernaryExprContext).condition = _x
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(561)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)

			var _x = p.Expr()

			localctx.(*TernaryExprContext).trueExpr = _x
		}
		{
			p.SetState(563)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(564)

			var _x = p.TernaryExpr()

			localctx.(*TernaryExprContext).falseExpr = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	AllLogicalAndExpr() []ILogicalAndExprContext
	LogicalAndExpr(i int) ILogicalAndExprContext
	AllPIPE_PIPE() []antlr.TerminalNode
	PIPE_PIPE(i int) antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) AllLogicalAndExpr() []ILogicalAndExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			len++
		}
	}

	tst := make([]ILogicalAndExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalAndExprContext); ok {
			tst[i] = t.(ILogicalAndExprContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprContext) LogicalAndExpr(i int) ILogicalAndExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) AllPIPE_PIPE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPIPE_PIPE)
}

func (s *LogicalOrExprContext) PIPE_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, i)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_logicalOrExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(568)

		var _x = p.LogicalAndExpr()

		localctx.(*LogicalOrExprContext).left = _x
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptPIPE_PIPE {
		{
			p.SetState(569)

			var _m = p.Match(ManuscriptPIPE_PIPE)

			localctx.(*LogicalOrExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(570)

			var _x = p.LogicalAndExpr()

			localctx.(*LogicalOrExprContext).right = _x
		}

		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseOrExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseOrExprContext)

	// Getter signatures
	AllBitwiseOrExpr() []IBitwiseOrExprContext
	BitwiseOrExpr(i int) IBitwiseOrExprContext
	AllAMP_AMP() []antlr.TerminalNode
	AMP_AMP(i int) antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseOrExprContext
	op     antlr.Token
	right  IBitwiseOrExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() IBitwiseOrExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IBitwiseOrExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v IBitwiseOrExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IBitwiseOrExprContext) { s.right = v }

func (s *LogicalAndExprContext) AllBitwiseOrExpr() []IBitwiseOrExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			len++
		}
	}

	tst := make([]IBitwiseOrExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitwiseOrExprContext); ok {
			tst[i] = t.(IBitwiseOrExprContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprContext) BitwiseOrExpr(i int) IBitwiseOrExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExprContext)
}

func (s *LogicalAndExprContext) AllAMP_AMP() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptAMP_AMP)
}

func (s *LogicalAndExprContext) AMP_AMP(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, i)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_logicalAndExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)

		var _x = p.BitwiseOrExpr()

		localctx.(*LogicalAndExprContext).left = _x
	}
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptAMP_AMP {
		{
			p.SetState(577)

			var _m = p.Match(ManuscriptAMP_AMP)

			localctx.(*LogicalAndExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)

			var _x = p.BitwiseOrExpr()

			localctx.(*LogicalAndExprContext).right = _x
		}

		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseOrExprContext is an interface to support dynamic dispatch.
type IBitwiseOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseXorExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseXorExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseXorExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseXorExprContext)

	// Getter signatures
	AllBitwiseXorExpr() []IBitwiseXorExprContext
	BitwiseXorExpr(i int) IBitwiseXorExprContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode

	// IsBitwiseOrExprContext differentiates from other interfaces.
	IsBitwiseOrExprContext()
}

type BitwiseOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseXorExprContext
	op     antlr.Token
	right  IBitwiseXorExprContext
}

func NewEmptyBitwiseOrExprContext() *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
	return p
}

func InitEmptyBitwiseOrExprContext(p *BitwiseOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
}

func (*BitwiseOrExprContext) IsBitwiseOrExprContext() {}

func NewBitwiseOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr

	return p
}

func (s *BitwiseOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseOrExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrExprContext) GetLeft() IBitwiseXorExprContext { return s.left }

func (s *BitwiseOrExprContext) GetRight() IBitwiseXorExprContext { return s.right }

func (s *BitwiseOrExprContext) SetLeft(v IBitwiseXorExprContext) { s.left = v }

func (s *BitwiseOrExprContext) SetRight(v IBitwiseXorExprContext) { s.right = v }

func (s *BitwiseOrExprContext) AllBitwiseXorExpr() []IBitwiseXorExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			len++
		}
	}

	tst := make([]IBitwiseXorExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitwiseXorExprContext); ok {
			tst[i] = t.(IBitwiseXorExprContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseOrExprContext) BitwiseXorExpr(i int) IBitwiseXorExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseOrExprContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPIPE)
}

func (s *BitwiseOrExprContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE, i)
}

func (s *BitwiseOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseOrExpr() (localctx IBitwiseOrExprContext) {
	localctx = NewBitwiseOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_bitwiseOrExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)

		var _x = p.BitwiseXorExpr()

		localctx.(*BitwiseOrExprContext).left = _x
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptPIPE {
		{
			p.SetState(585)

			var _m = p.Match(ManuscriptPIPE)

			localctx.(*BitwiseOrExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)

			var _x = p.BitwiseXorExpr()

			localctx.(*BitwiseOrExprContext).right = _x
		}

		p.SetState(591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseXorExprContext is an interface to support dynamic dispatch.
type IBitwiseXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseAndExprContext)

	// Getter signatures
	AllBitwiseAndExpr() []IBitwiseAndExprContext
	BitwiseAndExpr(i int) IBitwiseAndExprContext
	AllCARET() []antlr.TerminalNode
	CARET(i int) antlr.TerminalNode

	// IsBitwiseXorExprContext differentiates from other interfaces.
	IsBitwiseXorExprContext()
}

type BitwiseXorExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseAndExprContext
	op     antlr.Token
	right  IBitwiseAndExprContext
}

func NewEmptyBitwiseXorExprContext() *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
	return p
}

func InitEmptyBitwiseXorExprContext(p *BitwiseXorExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
}

func (*BitwiseXorExprContext) IsBitwiseXorExprContext() {}

func NewBitwiseXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr

	return p
}

func (s *BitwiseXorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExprContext) GetLeft() IBitwiseAndExprContext { return s.left }

func (s *BitwiseXorExprContext) GetRight() IBitwiseAndExprContext { return s.right }

func (s *BitwiseXorExprContext) SetLeft(v IBitwiseAndExprContext) { s.left = v }

func (s *BitwiseXorExprContext) SetRight(v IBitwiseAndExprContext) { s.right = v }

func (s *BitwiseXorExprContext) AllBitwiseAndExpr() []IBitwiseAndExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			len++
		}
	}

	tst := make([]IBitwiseAndExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitwiseAndExprContext); ok {
			tst[i] = t.(IBitwiseAndExprContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseXorExprContext) BitwiseAndExpr(i int) IBitwiseAndExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseXorExprContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCARET)
}

func (s *BitwiseXorExprContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET, i)
}

func (s *BitwiseXorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseXorExpr() (localctx IBitwiseXorExprContext) {
	localctx = NewBitwiseXorExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_bitwiseXorExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(592)

		var _x = p.BitwiseAndExpr()

		localctx.(*BitwiseXorExprContext).left = _x
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptCARET {
		{
			p.SetState(593)

			var _m = p.Match(ManuscriptCARET)

			localctx.(*BitwiseXorExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)

			var _x = p.BitwiseAndExpr()

			localctx.(*BitwiseXorExprContext).right = _x
		}

		p.SetState(599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseAndExprContext is an interface to support dynamic dispatch.
type IBitwiseAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	AllEqualityExpr() []IEqualityExprContext
	EqualityExpr(i int) IEqualityExprContext
	AllAMP() []antlr.TerminalNode
	AMP(i int) antlr.TerminalNode

	// IsBitwiseAndExprContext differentiates from other interfaces.
	IsBitwiseAndExprContext()
}

type BitwiseAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyBitwiseAndExprContext() *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
	return p
}

func InitEmptyBitwiseAndExprContext(p *BitwiseAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
}

func (*BitwiseAndExprContext) IsBitwiseAndExprContext() {}

func NewBitwiseAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr

	return p
}

func (s *BitwiseAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *BitwiseAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *BitwiseAndExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *BitwiseAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *BitwiseAndExprContext) AllEqualityExpr() []IEqualityExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityExprContext); ok {
			len++
		}
	}

	tst := make([]IEqualityExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityExprContext); ok {
			tst[i] = t.(IEqualityExprContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseAndExprContext) EqualityExpr(i int) IEqualityExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *BitwiseAndExprContext) AllAMP() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptAMP)
}

func (s *BitwiseAndExprContext) AMP(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP, i)
}

func (s *BitwiseAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseAndExpr() (localctx IBitwiseAndExprContext) {
	localctx = NewBitwiseAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_bitwiseAndExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)

		var _x = p.EqualityExpr()

		localctx.(*BitwiseAndExprContext).left = _x
	}
	p.SetState(605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptAMP {
		{
			p.SetState(601)

			var _m = p.Match(ManuscriptAMP)

			localctx.(*BitwiseAndExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(602)

			var _x = p.EqualityExpr()

			localctx.(*BitwiseAndExprContext).right = _x
		}

		p.SetState(607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	AllComparisonExpr() []IComparisonExprContext
	ComparisonExpr(i int) IComparisonExprContext
	AllEQUALS_EQUALS() []antlr.TerminalNode
	EQUALS_EQUALS(i int) antlr.TerminalNode
	AllNEQ() []antlr.TerminalNode
	NEQ(i int) antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) AllComparisonExpr() []IComparisonExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonExprContext); ok {
			len++
		}
	}

	tst := make([]IComparisonExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonExprContext); ok {
			tst[i] = t.(IComparisonExprContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprContext) ComparisonExpr(i int) IComparisonExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) AllEQUALS_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptEQUALS_EQUALS)
}

func (s *EqualityExprContext) EQUALS_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, i)
}

func (s *EqualityExprContext) AllNEQ() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptNEQ)
}

func (s *EqualityExprContext) NEQ(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, i)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_equalityExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(608)

		var _x = p.ComparisonExpr()

		localctx.(*EqualityExprContext).left = _x
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ {
		{
			p.SetState(609)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*EqualityExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*EqualityExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(610)

			var _x = p.ComparisonExpr()

			localctx.(*EqualityExprContext).right = _x
		}

		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IShiftExprContext

	// GetRight returns the right rule contexts.
	GetRight() IShiftExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IShiftExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IShiftExprContext)

	// Getter signatures
	AllShiftExpr() []IShiftExprContext
	ShiftExpr(i int) IShiftExprContext
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllLT_EQUALS() []antlr.TerminalNode
	LT_EQUALS(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode
	AllGT_EQUALS() []antlr.TerminalNode
	GT_EQUALS(i int) antlr.TerminalNode

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IShiftExprContext
	op     antlr.Token
	right  IShiftExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExprContext) GetLeft() IShiftExprContext { return s.left }

func (s *ComparisonExprContext) GetRight() IShiftExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IShiftExprContext) { s.left = v }

func (s *ComparisonExprContext) SetRight(v IShiftExprContext) { s.right = v }

func (s *ComparisonExprContext) AllShiftExpr() []IShiftExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShiftExprContext); ok {
			len++
		}
	}

	tst := make([]IShiftExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShiftExprContext); ok {
			tst[i] = t.(IShiftExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprContext) ShiftExpr(i int) IShiftExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ComparisonExprContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLT)
}

func (s *ComparisonExprContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, i)
}

func (s *ComparisonExprContext) AllLT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLT_EQUALS)
}

func (s *ComparisonExprContext) LT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, i)
}

func (s *ComparisonExprContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptGT)
}

func (s *ComparisonExprContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, i)
}

func (s *ComparisonExprContext) AllGT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptGT_EQUALS)
}

func (s *ComparisonExprContext) GT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, i)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_comparisonExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)

		var _x = p.ShiftExpr()

		localctx.(*ComparisonExprContext).left = _x
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(617)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ComparisonExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&527765581332480) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ComparisonExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(618)

				var _x = p.ShiftExpr()

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExprContext is an interface to support dynamic dispatch.
type IShiftExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAdditiveExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAdditiveExprContext)

	// Getter signatures
	AllAdditiveExpr() []IAdditiveExprContext
	AdditiveExpr(i int) IAdditiveExprContext
	AllLSHIFT() []antlr.TerminalNode
	LSHIFT(i int) antlr.TerminalNode
	AllRSHIFT() []antlr.TerminalNode
	RSHIFT(i int) antlr.TerminalNode

	// IsShiftExprContext differentiates from other interfaces.
	IsShiftExprContext()
}

type ShiftExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IAdditiveExprContext
}

func NewEmptyShiftExprContext() *ShiftExprContext {
	var p = new(ShiftExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
	return p
}

func InitEmptyShiftExprContext(p *ShiftExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
}

func (*ShiftExprContext) IsShiftExprContext() {}

func NewShiftExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExprContext {
	var p = new(ShiftExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_shiftExpr

	return p
}

func (s *ShiftExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExprContext) GetOp() antlr.Token { return s.op }

func (s *ShiftExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ShiftExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *ShiftExprContext) GetRight() IAdditiveExprContext { return s.right }

func (s *ShiftExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *ShiftExprContext) SetRight(v IAdditiveExprContext) { s.right = v }

func (s *ShiftExprContext) AllAdditiveExpr() []IAdditiveExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExprContext); ok {
			tst[i] = t.(IAdditiveExprContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExprContext) AdditiveExpr(i int) IAdditiveExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ShiftExprContext) AllLSHIFT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLSHIFT)
}

func (s *ShiftExprContext) LSHIFT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLSHIFT, i)
}

func (s *ShiftExprContext) AllRSHIFT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRSHIFT)
}

func (s *ShiftExprContext) RSHIFT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRSHIFT, i)
}

func (s *ShiftExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterShiftExpr(s)
	}
}

func (s *ShiftExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitShiftExpr(s)
	}
}

func (s *ShiftExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitShiftExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ShiftExpr() (localctx IShiftExprContext) {
	localctx = NewShiftExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_shiftExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)

		var _x = p.AdditiveExpr()

		localctx.(*ShiftExprContext).left = _x
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptLSHIFT || _la == ManuscriptRSHIFT {
		{
			p.SetState(625)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShiftExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == ManuscriptLSHIFT || _la == ManuscriptRSHIFT) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShiftExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(626)

			var _x = p.AdditiveExpr()

			localctx.(*ShiftExprContext).right = _x
		}

		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	AllMultiplicativeExpr() []IMultiplicativeExprContext
	MultiplicativeExpr(i int) IMultiplicativeExprContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) AllMultiplicativeExpr() []IMultiplicativeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExprContext); ok {
			tst[i] = t.(IMultiplicativeExprContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExprContext) MultiplicativeExpr(i int) IMultiplicativeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPLUS)
}

func (s *AdditiveExprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, i)
}

func (s *AdditiveExprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptMINUS)
}

func (s *AdditiveExprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, i)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_additiveExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)

		var _x = p.MultiplicativeExpr()

		localctx.(*AdditiveExprContext).left = _x
	}
	p.SetState(637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(633)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(634)

				var _x = p.MultiplicativeExpr()

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IUnaryExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IUnaryExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	AllUnaryExpr() []IUnaryExprContext
	UnaryExpr(i int) IUnaryExprContext
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode
	AllMOD() []antlr.TerminalNode
	MOD(i int) antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IUnaryExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IUnaryExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IUnaryExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) AllUnaryExpr() []IUnaryExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryExprContext); ok {
			len++
		}
	}

	tst := make([]IUnaryExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryExprContext); ok {
			tst[i] = t.(IUnaryExprContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprContext) UnaryExpr(i int) IUnaryExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSTAR)
}

func (s *MultiplicativeExprContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, i)
}

func (s *MultiplicativeExprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSLASH)
}

func (s *MultiplicativeExprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, i)
}

func (s *MultiplicativeExprContext) AllMOD() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptMOD)
}

func (s *MultiplicativeExprContext) MOD(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD, i)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_multiplicativeExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)

		var _x = p.UnaryExpr()

		localctx.(*MultiplicativeExprContext).left = _x
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8070450532247928832) != 0 {
		{
			p.SetState(641)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*MultiplicativeExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8070450532247928832) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*MultiplicativeExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(642)

			var _x = p.UnaryExpr()

			localctx.(*MultiplicativeExprContext).right = _x
		}

		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	TRY() antlr.TerminalNode
	AwaitExpr() IAwaitExprContext

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *UnaryExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *UnaryExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *UnaryExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *UnaryExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *UnaryExprContext) AwaitExpr() IAwaitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAwaitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAwaitExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (s *UnaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitUnaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(648)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169328841326297088) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(649)
			p.UnaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(650)
			p.AwaitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAwaitExprContext is an interface to support dynamic dispatch.
type IAwaitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	TRY() antlr.TerminalNode
	AWAIT() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAwaitExprContext differentiates from other interfaces.
	IsAwaitExprContext()
}

type AwaitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExprContext() *AwaitExprContext {
	var p = new(AwaitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
	return p
}

func InitEmptyAwaitExprContext(p *AwaitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
}

func (*AwaitExprContext) IsAwaitExprContext() {}

func NewAwaitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExprContext {
	var p = new(AwaitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_awaitExpr

	return p
}

func (s *AwaitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *AwaitExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *AwaitExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(ManuscriptAWAIT, 0)
}

func (s *AwaitExprContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ManuscriptASYNC, 0)
}

func (s *AwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAwaitExpr(s)
	}
}

func (s *AwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAwaitExpr(s)
	}
}

func (s *AwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AwaitExpr() (localctx IAwaitExprContext) {
	localctx = NewAwaitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ManuscriptRULE_awaitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptTRY {
		{
			p.SetState(653)
			p.Match(ManuscriptTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAWAIT {
		{
			p.SetState(656)
			p.Match(ManuscriptAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptASYNC {
		{
			p.SetState(659)
			p.Match(ManuscriptASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

	{
		p.SetState(662)
		p.PostfixExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMember returns the member token.
	GetMember() antlr.Token

	// SetMember sets the member token.
	SetMember(antlr.Token)

	// GetArgs returns the args rule contexts.
	GetArgs() IExprListContext

	// GetIndexExpr returns the indexExpr rule contexts.
	GetIndexExpr() IExprContext

	// SetArgs sets the args rule contexts.
	SetArgs(IExprListContext)

	// SetIndexExpr sets the indexExpr rule contexts.
	SetIndexExpr(IExprContext)

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllLSQBR() []antlr.TerminalNode
	LSQBR(i int) antlr.TerminalNode
	AllRSQBR() []antlr.TerminalNode
	RSQBR(i int) antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllExprList() []IExprListContext
	ExprList(i int) IExprListContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	args      IExprListContext
	member    antlr.Token
	indexExpr IExprContext
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) GetMember() antlr.Token { return s.member }

func (s *PostfixExprContext) SetMember(v antlr.Token) { s.member = v }

func (s *PostfixExprContext) GetArgs() IExprListContext { return s.args }

func (s *PostfixExprContext) GetIndexExpr() IExprContext { return s.indexExpr }

func (s *PostfixExprContext) SetArgs(v IExprListContext) { s.args = v }

func (s *PostfixExprContext) SetIndexExpr(v IExprContext) { s.indexExpr = v }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLPAREN)
}

func (s *PostfixExprContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, i)
}

func (s *PostfixExprContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRPAREN)
}

func (s *PostfixExprContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, i)
}

func (s *PostfixExprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptDOT)
}

func (s *PostfixExprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, i)
}

func (s *PostfixExprContext) AllLSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLSQBR)
}

func (s *PostfixExprContext) LSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, i)
}

func (s *PostfixExprContext) AllRSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRSQBR)
}

func (s *PostfixExprContext) RSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, i)
}

func (s *PostfixExprContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *PostfixExprContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *PostfixExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PostfixExprContext) AllExprList() []IExprListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprListContext); ok {
			len++
		}
	}

	tst := make([]IExprListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprListContext); ok {
			tst[i] = t.(IExprListContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) ExprList(i int) IExprListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ManuscriptRULE_postfixExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.PrimaryExpr()
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(676)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case ManuscriptLPAREN:
				{
					p.SetState(665)
					p.Match(ManuscriptLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(667)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
					{
						p.SetState(666)

						var _x = p.ExprList()

						localctx.(*PostfixExprContext).args = _x
					}

				}
				{
					p.SetState(669)
					p.Match(ManuscriptRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case ManuscriptDOT:
				{
					p.SetState(670)
					p.Match(ManuscriptDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(671)

					var _m = p.Match(ManuscriptID)

					localctx.(*PostfixExprContext).member = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case ManuscriptLSQBR:
				{
					p.SetState(672)
					p.Match(ManuscriptLSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(673)

					var _x = p.Expr()

					localctx.(*PostfixExprContext).indexExpr = _x
				}
				{
					p.SetState(674)
					p.Match(ManuscriptRSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParenExpr returns the parenExpr rule contexts.
	GetParenExpr() IExprContext

	// SetParenExpr sets the parenExpr rule contexts.
	SetParenExpr(IExprContext)

	// Getter signatures
	Literal() ILiteralContext
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expr() IExprContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext
	MapLiteral() IMapLiteralContext
	SetLiteral() ISetLiteralContext
	FnExpr() IFnExprContext
	MatchExpr() IMatchExprContext
	VOID() antlr.TerminalNode
	NULL() antlr.TerminalNode
	TaggedBlockString() ITaggedBlockStringContext
	StructInitExpr() IStructInitExprContext

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	parenExpr IExprContext
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) GetParenExpr() IExprContext { return s.parenExpr }

func (s *PrimaryExprContext) SetParenExpr(v IExprContext) { s.parenExpr = v }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PrimaryExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *PrimaryExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *PrimaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PrimaryExprContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *PrimaryExprContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryExprContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PrimaryExprContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *PrimaryExprContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *PrimaryExprContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *PrimaryExprContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *PrimaryExprContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *PrimaryExprContext) TaggedBlockString() ITaggedBlockStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaggedBlockStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaggedBlockStringContext)
}

func (s *PrimaryExprContext) StructInitExpr() IStructInitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructInitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructInitExprContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ManuscriptRULE_primaryExpr)
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(683)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)

			var _x = p.Expr()

			localctx.(*PrimaryExprContext).parenExpr = _x
		}
		{
			p.SetState(685)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(687)
			p.ArrayLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(688)
			p.ObjectLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(689)
			p.MapLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(690)
			p.SetLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(691)
			p.FnExpr()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(692)
			p.MatchExpr()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(693)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(694)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(695)
			p.TaggedBlockString()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(696)
			p.StructInitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFnParams returns the fnParams rule contexts.
	GetFnParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetFnParams sets the fnParams rule contexts.
	SetFnParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	fnParams   IParametersContext
	returnType ITypeAnnotationContext
	block      ICodeBlockContext
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) GetFnParams() IParametersContext { return s.fnParams }

func (s *FnExprContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *FnExprContext) GetBlock() ICodeBlockContext { return s.block }

func (s *FnExprContext) SetFnParams(v IParametersContext) { s.fnParams = v }

func (s *FnExprContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *FnExprContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(701)

			var _x = p.Parameters()

			localctx.(*FnExprContext).fnParams = _x
		}

	}
	{
		p.SetState(704)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8796093030432) != 0) || _la == ManuscriptID {
		{
			p.SetState(705)

			var _x = p.TypeAnnotation()

			localctx.(*FnExprContext).returnType = _x
		}

	}
	{
		p.SetState(708)

		var _x = p.CodeBlock()

		localctx.(*FnExprContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValueToMatch returns the valueToMatch rule contexts.
	GetValueToMatch() IExprContext

	// Get_caseClause returns the _caseClause rule contexts.
	Get_caseClause() ICaseClauseContext

	// GetDef returns the def rule contexts.
	GetDef() IDefaultClauseContext

	// SetValueToMatch sets the valueToMatch rule contexts.
	SetValueToMatch(IExprContext)

	// Set_caseClause sets the _caseClause rule contexts.
	Set_caseClause(ICaseClauseContext)

	// SetDef sets the def rule contexts.
	SetDef(IDefaultClauseContext)

	// GetCs returns the cs rule context list.
	GetCs() []ICaseClauseContext

	// SetCs sets the cs rule context list.
	SetCs([]ICaseClauseContext)

	// Getter signatures
	MATCH() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	Expr() IExprContext
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	DefaultClause() IDefaultClauseContext

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	valueToMatch IExprContext
	_caseClause  ICaseClauseContext
	cs           []ICaseClauseContext
	def          IDefaultClauseContext
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) GetValueToMatch() IExprContext { return s.valueToMatch }

func (s *MatchExprContext) Get_caseClause() ICaseClauseContext { return s._caseClause }

func (s *MatchExprContext) GetDef() IDefaultClauseContext { return s.def }

func (s *MatchExprContext) SetValueToMatch(v IExprContext) { s.valueToMatch = v }

func (s *MatchExprContext) Set_caseClause(v ICaseClauseContext) { s._caseClause = v }

func (s *MatchExprContext) SetDef(v IDefaultClauseContext) { s.def = v }

func (s *MatchExprContext) GetCs() []ICaseClauseContext { return s.cs }

func (s *MatchExprContext) SetCs(v []ICaseClauseContext) { s.cs = v }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ManuscriptRULE_matchExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(711)

		var _x = p.Expr()

		localctx.(*MatchExprContext).valueToMatch = _x
	}
	{
		p.SetState(712)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(713)

			var _x = p.CaseClause()

			localctx.(*MatchExprContext)._caseClause = _x
		}
		localctx.(*MatchExprContext).cs = append(localctx.(*MatchExprContext).cs, localctx.(*MatchExprContext)._caseClause)

		p.SetState(718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptDEFAULT {
		{
			p.SetState(719)

			var _x = p.DefaultClause()

			localctx.(*MatchExprContext).def = _x
		}

	}
	{
		p.SetState(722)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IExprContext

	// GetResultExpr returns the resultExpr rule contexts.
	GetResultExpr() IExprContext

	// GetResultBlock returns the resultBlock rule contexts.
	GetResultBlock() ICodeBlockContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IExprContext)

	// SetResultExpr sets the resultExpr rule contexts.
	SetResultExpr(IExprContext)

	// SetResultBlock sets the resultBlock rule contexts.
	SetResultBlock(ICodeBlockContext)

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	pattern     IExprContext
	resultExpr  IExprContext
	resultBlock ICodeBlockContext
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) GetPattern() IExprContext { return s.pattern }

func (s *CaseClauseContext) GetResultExpr() IExprContext { return s.resultExpr }

func (s *CaseClauseContext) GetResultBlock() ICodeBlockContext { return s.resultBlock }

func (s *CaseClauseContext) SetPattern(v IExprContext) { s.pattern = v }

func (s *CaseClauseContext) SetResultExpr(v IExprContext) { s.resultExpr = v }

func (s *CaseClauseContext) SetResultBlock(v ICodeBlockContext) { s.resultBlock = v }

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ManuscriptRULE_caseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(724)

		var _x = p.Expr()

		localctx.(*CaseClauseContext).pattern = _x
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(725)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(726)

			var _x = p.Expr()

			localctx.(*CaseClauseContext).resultExpr = _x
		}

	case ManuscriptLBRACE:
		{
			p.SetState(727)

			var _x = p.CodeBlock()

			localctx.(*CaseClauseContext).resultBlock = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(730)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResultExpr returns the resultExpr rule contexts.
	GetResultExpr() IExprContext

	// GetResultBlock returns the resultBlock rule contexts.
	GetResultBlock() ICodeBlockContext

	// SetResultExpr sets the resultExpr rule contexts.
	SetResultExpr(IExprContext)

	// SetResultBlock sets the resultBlock rule contexts.
	SetResultBlock(ICodeBlockContext)

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	resultExpr  IExprContext
	resultBlock ICodeBlockContext
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) GetResultExpr() IExprContext { return s.resultExpr }

func (s *DefaultClauseContext) GetResultBlock() ICodeBlockContext { return s.resultBlock }

func (s *DefaultClauseContext) SetResultExpr(v IExprContext) { s.resultExpr = v }

func (s *DefaultClauseContext) SetResultBlock(v ICodeBlockContext) { s.resultBlock = v }

func (s *DefaultClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFAULT, 0)
}

func (s *DefaultClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *DefaultClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DefaultClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *DefaultClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ManuscriptRULE_defaultClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(733)
		p.Match(ManuscriptDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(734)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(735)

			var _x = p.Expr()

			localctx.(*DefaultClauseContext).resultExpr = _x
		}

	case ManuscriptLBRACE:
		{
			p.SetState(736)

			var _x = p.CodeBlock()

			localctx.(*DefaultClauseContext).resultBlock = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(739)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *SingleQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *SingleQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *SingleQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(742)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&1755) != 0 {
		{
			p.SetState(743)

			var _x = p.StringPart()

			localctx.(*SingleQuotedStringContext)._stringPart = _x
		}
		localctx.(*SingleQuotedStringContext).parts = append(localctx.(*SingleQuotedStringContext).parts, localctx.(*SingleQuotedStringContext)._stringPart)

		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(749)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *MultiQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *MultiQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *MultiQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&1755) != 0 {
		{
			p.SetState(752)

			var _x = p.StringPart()

			localctx.(*MultiQuotedStringContext)._stringPart = _x
		}
		localctx.(*MultiQuotedStringContext).parts = append(localctx.(*MultiQuotedStringContext).parts, localctx.(*MultiQuotedStringContext)._stringPart)

		p.SetState(757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(758)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	DOUBLE_QUOTE_START() antlr.TerminalNode
	DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsDoubleQuotedStringContext differentiates from other interfaces.
	IsDoubleQuotedStringContext()
}

type DoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptyDoubleQuotedStringContext() *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
	return p
}

func InitEmptyDoubleQuotedStringContext(p *DoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
}

func (*DoubleQuotedStringContext) IsDoubleQuotedStringContext() {}

func NewDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_doubleQuotedString

	return p
}

func (s *DoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *DoubleQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *DoubleQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *DoubleQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *DoubleQuotedStringContext) DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_QUOTE_START, 0)
}

func (s *DoubleQuotedStringContext) DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_END, 0)
}

func (s *DoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *DoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *DoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DoubleQuotedString() (localctx IDoubleQuotedStringContext) {
	localctx = NewDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ManuscriptRULE_doubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(760)
		p.Match(ManuscriptDOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&1755) != 0 {
		{
			p.SetState(761)

			var _x = p.StringPart()

			localctx.(*DoubleQuotedStringContext)._stringPart = _x
		}
		localctx.(*DoubleQuotedStringContext).parts = append(localctx.(*DoubleQuotedStringContext).parts, localctx.(*DoubleQuotedStringContext)._stringPart)

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(ManuscriptDOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IMultiDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiDoubleQuotedStringContext differentiates from other interfaces.
	IsMultiDoubleQuotedStringContext()
}

type MultiDoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptyMultiDoubleQuotedStringContext() *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
	return p
}

func InitEmptyMultiDoubleQuotedStringContext(p *MultiDoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
}

func (*MultiDoubleQuotedStringContext) IsMultiDoubleQuotedStringContext() {}

func NewMultiDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString

	return p
}

func (s *MultiDoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiDoubleQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *MultiDoubleQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *MultiDoubleQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *MultiDoubleQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_QUOTE_START, 0)
}

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_END, 0)
}

func (s *MultiDoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiDoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiDoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiDoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiDoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiDoubleQuotedString() (localctx IMultiDoubleQuotedStringContext) {
	localctx = NewMultiDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ManuscriptRULE_multiDoubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(ManuscriptMULTI_DOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&1755) != 0 {
		{
			p.SetState(770)

			var _x = p.StringPart()

			localctx.(*MultiDoubleQuotedStringContext)._stringPart = _x
		}
		localctx.(*MultiDoubleQuotedStringContext).parts = append(localctx.(*MultiDoubleQuotedStringContext).parts, localctx.(*MultiDoubleQuotedStringContext)._stringPart)

		p.SetState(775)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(776)
		p.Match(ManuscriptMULTI_DOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInterp returns the interp rule contexts.
	GetInterp() IInterpolationContext

	// SetInterp sets the interp rule contexts.
	SetInterp(IInterpolationContext)

	// Getter signatures
	SINGLE_STR_CONTENT() antlr.TerminalNode
	MULTI_STR_CONTENT() antlr.TerminalNode
	DOUBLE_STR_CONTENT() antlr.TerminalNode
	MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode
	Interpolation() IInterpolationContext

	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	interp IInterpolationContext
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) GetInterp() IInterpolationContext { return s.interp }

func (s *StringPartContext) SetInterp(v IInterpolationContext) { s.interp = v }

func (s *StringPartContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *StringPartContext) DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPart(s)
	}
}

func (s *StringPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPart(s)
	}
}

func (s *StringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ManuscriptRULE_stringPart)
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(778)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(779)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(780)
			p.Match(ManuscriptDOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_DOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(781)
			p.Match(ManuscriptMULTI_DOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START, ManuscriptDOUBLE_STR_INTERP_START, ManuscriptMULTI_DOUBLE_STR_INTERP_START:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(782)

			var _x = p.Interpolation()

			localctx.(*StringPartContext).interp = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	DOUBLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode
	Expr() IExprContext

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExprContext
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) GetValue() IExprContext { return s.value }

func (s *InterpolationContext) SetValue(v IExprContext) { s.value = v }

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-88)) & ^0x3f) == 0 && ((int64(1)<<(_la-88))&585) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(786)

		var _x = p.Expr()

		localctx.(*InterpolationContext).value = _x
	}
	{
		p.SetState(787)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNullConstant returns the nullConstant token.
	GetNullConstant() antlr.Token

	// GetVoidConstant returns the voidConstant token.
	GetVoidConstant() antlr.Token

	// SetNullConstant sets the nullConstant token.
	SetNullConstant(antlr.Token)

	// SetVoidConstant sets the voidConstant token.
	SetVoidConstant(antlr.Token)

	// GetStringLit returns the stringLit rule contexts.
	GetStringLit() IStringLiteralContext

	// GetNumLit returns the numLit rule contexts.
	GetNumLit() INumberLiteralContext

	// GetBoolLit returns the boolLit rule contexts.
	GetBoolLit() IBooleanLiteralContext

	// SetStringLit sets the stringLit rule contexts.
	SetStringLit(IStringLiteralContext)

	// SetNumLit sets the numLit rule contexts.
	SetNumLit(INumberLiteralContext)

	// SetBoolLit sets the boolLit rule contexts.
	SetBoolLit(IBooleanLiteralContext)

	// Getter signatures
	StringLiteral() IStringLiteralContext
	NumberLiteral() INumberLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	NULL() antlr.TerminalNode
	VOID() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	stringLit    IStringLiteralContext
	numLit       INumberLiteralContext
	boolLit      IBooleanLiteralContext
	nullConstant antlr.Token
	voidConstant antlr.Token
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) GetNullConstant() antlr.Token { return s.nullConstant }

func (s *LiteralContext) GetVoidConstant() antlr.Token { return s.voidConstant }

func (s *LiteralContext) SetNullConstant(v antlr.Token) { s.nullConstant = v }

func (s *LiteralContext) SetVoidConstant(v antlr.Token) { s.voidConstant = v }

func (s *LiteralContext) GetStringLit() IStringLiteralContext { return s.stringLit }

func (s *LiteralContext) GetNumLit() INumberLiteralContext { return s.numLit }

func (s *LiteralContext) GetBoolLit() IBooleanLiteralContext { return s.boolLit }

func (s *LiteralContext) SetStringLit(v IStringLiteralContext) { s.stringLit = v }

func (s *LiteralContext) SetNumLit(v INumberLiteralContext) { s.numLit = v }

func (s *LiteralContext) SetBoolLit(v IBooleanLiteralContext) { s.boolLit = v }

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LiteralContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ManuscriptRULE_literal)
	p.SetState(794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(789)

			var _x = p.StringLiteral()

			localctx.(*LiteralContext).stringLit = _x
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(790)

			var _x = p.NumberLiteral()

			localctx.(*LiteralContext).numLit = _x
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(791)

			var _x = p.BooleanLiteral()

			localctx.(*LiteralContext).boolLit = _x
		}

	case ManuscriptNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(792)

			var _m = p.Match(ManuscriptNULL)

			localctx.(*LiteralContext).nullConstant = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(793)

			var _m = p.Match(ManuscriptVOID)

			localctx.(*LiteralContext).voidConstant = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSglQuotedStr returns the sglQuotedStr rule contexts.
	GetSglQuotedStr() ISingleQuotedStringContext

	// GetMulQuotedStr returns the mulQuotedStr rule contexts.
	GetMulQuotedStr() IMultiQuotedStringContext

	// GetDblQuotedStr returns the dblQuotedStr rule contexts.
	GetDblQuotedStr() IDoubleQuotedStringContext

	// GetMulDblQuotedStr returns the mulDblQuotedStr rule contexts.
	GetMulDblQuotedStr() IMultiDoubleQuotedStringContext

	// SetSglQuotedStr sets the sglQuotedStr rule contexts.
	SetSglQuotedStr(ISingleQuotedStringContext)

	// SetMulQuotedStr sets the mulQuotedStr rule contexts.
	SetMulQuotedStr(IMultiQuotedStringContext)

	// SetDblQuotedStr sets the dblQuotedStr rule contexts.
	SetDblQuotedStr(IDoubleQuotedStringContext)

	// SetMulDblQuotedStr sets the mulDblQuotedStr rule contexts.
	SetMulDblQuotedStr(IMultiDoubleQuotedStringContext)

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext
	MultiQuotedString() IMultiQuotedStringContext
	DoubleQuotedString() IDoubleQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	sglQuotedStr    ISingleQuotedStringContext
	mulQuotedStr    IMultiQuotedStringContext
	dblQuotedStr    IDoubleQuotedStringContext
	mulDblQuotedStr IMultiDoubleQuotedStringContext
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) GetSglQuotedStr() ISingleQuotedStringContext { return s.sglQuotedStr }

func (s *StringLiteralContext) GetMulQuotedStr() IMultiQuotedStringContext { return s.mulQuotedStr }

func (s *StringLiteralContext) GetDblQuotedStr() IDoubleQuotedStringContext { return s.dblQuotedStr }

func (s *StringLiteralContext) GetMulDblQuotedStr() IMultiDoubleQuotedStringContext {
	return s.mulDblQuotedStr
}

func (s *StringLiteralContext) SetSglQuotedStr(v ISingleQuotedStringContext) { s.sglQuotedStr = v }

func (s *StringLiteralContext) SetMulQuotedStr(v IMultiQuotedStringContext) { s.mulQuotedStr = v }

func (s *StringLiteralContext) SetDblQuotedStr(v IDoubleQuotedStringContext) { s.dblQuotedStr = v }

func (s *StringLiteralContext) SetMulDblQuotedStr(v IMultiDoubleQuotedStringContext) {
	s.mulDblQuotedStr = v
}

func (s *StringLiteralContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *StringLiteralContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *StringLiteralContext) DoubleQuotedString() IDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleQuotedStringContext)
}

func (s *StringLiteralContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ManuscriptRULE_stringLiteral)
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(796)

			var _x = p.SingleQuotedString()

			localctx.(*StringLiteralContext).sglQuotedStr = _x
		}

	case ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(797)

			var _x = p.MultiQuotedString()

			localctx.(*StringLiteralContext).mulQuotedStr = _x
		}

	case ManuscriptDOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(798)

			var _x = p.DoubleQuotedString()

			localctx.(*StringLiteralContext).dblQuotedStr = _x
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(799)

			var _x = p.MultiDoubleQuotedString()

			localctx.(*StringLiteralContext).mulDblQuotedStr = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntValue returns the intValue token.
	GetIntValue() antlr.Token

	// GetFloatValue returns the floatValue token.
	GetFloatValue() antlr.Token

	// GetHexValue returns the hexValue token.
	GetHexValue() antlr.Token

	// GetBinaryValue returns the binaryValue token.
	GetBinaryValue() antlr.Token

	// GetOctalValue returns the octalValue token.
	GetOctalValue() antlr.Token

	// SetIntValue sets the intValue token.
	SetIntValue(antlr.Token)

	// SetFloatValue sets the floatValue token.
	SetFloatValue(antlr.Token)

	// SetHexValue sets the hexValue token.
	SetHexValue(antlr.Token)

	// SetBinaryValue sets the binaryValue token.
	SetBinaryValue(antlr.Token)

	// SetOctalValue sets the octalValue token.
	SetOctalValue(antlr.Token)

	// Getter signatures
	INTEGER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	HEX_LITERAL() antlr.TerminalNode
	BINARY_LITERAL() antlr.TerminalNode
	OCTAL_LITERAL() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	intValue    antlr.Token
	floatValue  antlr.Token
	hexValue    antlr.Token
	binaryValue antlr.Token
	octalValue  antlr.Token
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) GetIntValue() antlr.Token { return s.intValue }

func (s *NumberLiteralContext) GetFloatValue() antlr.Token { return s.floatValue }

func (s *NumberLiteralContext) GetHexValue() antlr.Token { return s.hexValue }

func (s *NumberLiteralContext) GetBinaryValue() antlr.Token { return s.binaryValue }

func (s *NumberLiteralContext) GetOctalValue() antlr.Token { return s.octalValue }

func (s *NumberLiteralContext) SetIntValue(v antlr.Token) { s.intValue = v }

func (s *NumberLiteralContext) SetFloatValue(v antlr.Token) { s.floatValue = v }

func (s *NumberLiteralContext) SetHexValue(v antlr.Token) { s.hexValue = v }

func (s *NumberLiteralContext) SetBinaryValue(v antlr.Token) { s.binaryValue = v }

func (s *NumberLiteralContext) SetOctalValue(v antlr.Token) { s.octalValue = v }

func (s *NumberLiteralContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *NumberLiteralContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *NumberLiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *NumberLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *NumberLiteralContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptOCTAL_LITERAL, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ManuscriptRULE_numberLiteral)
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(802)

			var _m = p.Match(ManuscriptINTEGER)

			localctx.(*NumberLiteralContext).intValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(803)

			var _m = p.Match(ManuscriptFLOAT)

			localctx.(*NumberLiteralContext).floatValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(804)

			var _m = p.Match(ManuscriptHEX_LITERAL)

			localctx.(*NumberLiteralContext).hexValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(805)

			var _m = p.Match(ManuscriptBINARY_LITERAL)

			localctx.(*NumberLiteralContext).binaryValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptOCTAL_LITERAL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(806)

			var _m = p.Match(ManuscriptOCTAL_LITERAL)

			localctx.(*NumberLiteralContext).octalValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ManuscriptRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptTRUE || _la == ManuscriptFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetItems returns the items rule contexts.
	GetItems() IExprListContext

	// SetItems sets the items rule contexts.
	SetItems(IExprListContext)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	ExprList() IExprListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	items  IExprListContext
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) GetItems() IExprListContext { return s.items }

func (s *ArrayLiteralContext) SetItems(v IExprListContext) { s.items = v }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(812)

			var _x = p.ExprList()

			localctx.(*ArrayLiteralContext).items = _x
		}

	}
	{
		p.SetState(815)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_objectField returns the _objectField rule contexts.
	Get_objectField() IObjectFieldContext

	// Set_objectField sets the _objectField rule contexts.
	Set_objectField(IObjectFieldContext)

	// GetObjFields returns the objFields rule context list.
	GetObjFields() []IObjectFieldContext

	// SetObjFields sets the objFields rule context list.
	SetObjFields([]IObjectFieldContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_objectField IObjectFieldContext
	objFields    []IObjectFieldContext
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) Get_objectField() IObjectFieldContext { return s._objectField }

func (s *ObjectLiteralContext) Set_objectField(v IObjectFieldContext) { s._objectField = v }

func (s *ObjectLiteralContext) GetObjFields() []IObjectFieldContext { return s.objFields }

func (s *ObjectLiteralContext) SetObjFields(v []IObjectFieldContext) { s.objFields = v }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ManuscriptRULE_objectLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-83)) & ^0x3f) == 0 && ((int64(1)<<(_la-83))&31) != 0 {
		{
			p.SetState(818)

			var _x = p.ObjectField()

			localctx.(*ObjectLiteralContext)._objectField = _x
		}
		localctx.(*ObjectLiteralContext).objFields = append(localctx.(*ObjectLiteralContext).objFields, localctx.(*ObjectLiteralContext)._objectField)
		p.SetState(823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(819)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(820)

					var _x = p.ObjectField()

					localctx.(*ObjectLiteralContext)._objectField = _x
				}
				localctx.(*ObjectLiteralContext).objFields = append(localctx.(*ObjectLiteralContext).objFields, localctx.(*ObjectLiteralContext)._objectField)

			}
			p.SetState(825)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(826)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(831)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldNameContext is an interface to support dynamic dispatch.
type IObjectFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKeyName returns the keyName token.
	GetKeyName() antlr.Token

	// SetKeyName sets the keyName token.
	SetKeyName(antlr.Token)

	// GetKeyString returns the keyString rule contexts.
	GetKeyString() IStringLiteralContext

	// SetKeyString sets the keyString rule contexts.
	SetKeyString(IStringLiteralContext)

	// Getter signatures
	ID() antlr.TerminalNode
	StringLiteral() IStringLiteralContext

	// IsObjectFieldNameContext differentiates from other interfaces.
	IsObjectFieldNameContext()
}

type ObjectFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	keyName   antlr.Token
	keyString IStringLiteralContext
}

func NewEmptyObjectFieldNameContext() *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
	return p
}

func InitEmptyObjectFieldNameContext(p *ObjectFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
}

func (*ObjectFieldNameContext) IsObjectFieldNameContext() {}

func NewObjectFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldName

	return p
}

func (s *ObjectFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldNameContext) GetKeyName() antlr.Token { return s.keyName }

func (s *ObjectFieldNameContext) SetKeyName(v antlr.Token) { s.keyName = v }

func (s *ObjectFieldNameContext) GetKeyString() IStringLiteralContext { return s.keyString }

func (s *ObjectFieldNameContext) SetKeyString(v IStringLiteralContext) { s.keyString = v }

func (s *ObjectFieldNameContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ObjectFieldNameContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ObjectFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldName(s)
	}
}

func (s *ObjectFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldName(s)
	}
}

func (s *ObjectFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldName() (localctx IObjectFieldNameContext) {
	localctx = NewObjectFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ManuscriptRULE_objectFieldName)
	p.SetState(835)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(833)

			var _m = p.Match(ManuscriptID)

			localctx.(*ObjectFieldNameContext).keyName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(834)

			var _x = p.StringLiteral()

			localctx.(*ObjectFieldNameContext).keyString = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IObjectFieldNameContext

	// GetVal returns the val rule contexts.
	GetVal() IExprContext

	// SetKey sets the key rule contexts.
	SetKey(IObjectFieldNameContext)

	// SetVal sets the val rule contexts.
	SetVal(IExprContext)

	// Getter signatures
	ObjectFieldName() IObjectFieldNameContext
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IObjectFieldNameContext
	val    IExprContext
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) GetKey() IObjectFieldNameContext { return s.key }

func (s *ObjectFieldContext) GetVal() IExprContext { return s.val }

func (s *ObjectFieldContext) SetKey(v IObjectFieldNameContext) { s.key = v }

func (s *ObjectFieldContext) SetVal(v IExprContext) { s.val = v }

func (s *ObjectFieldContext) ObjectFieldName() IObjectFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldNameContext)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(837)

		var _x = p.ObjectFieldName()

		localctx.(*ObjectFieldContext).key = _x
	}
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(838)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(839)

			var _x = p.Expr()

			localctx.(*ObjectFieldContext).val = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mapField returns the _mapField rule contexts.
	Get_mapField() IMapFieldContext

	// Set_mapField sets the _mapField rule contexts.
	Set_mapField(IMapFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IMapFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IMapFieldContext)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	COLON() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_mapField IMapFieldContext
	fields    []IMapFieldContext
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) Get_mapField() IMapFieldContext { return s._mapField }

func (s *MapLiteralContext) Set_mapField(v IMapFieldContext) { s._mapField = v }

func (s *MapLiteralContext) GetFields() []IMapFieldContext { return s.fields }

func (s *MapLiteralContext) SetFields(v []IMapFieldContext) { s.fields = v }

func (s *MapLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *MapLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *MapLiteralContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ManuscriptRULE_mapLiteral)
	var _la int

	var _alt int

	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(842)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(843)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(844)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(845)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(857)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
			{
				p.SetState(846)

				var _x = p.MapField()

				localctx.(*MapLiteralContext)._mapField = _x
			}
			localctx.(*MapLiteralContext).fields = append(localctx.(*MapLiteralContext).fields, localctx.(*MapLiteralContext)._mapField)
			p.SetState(851)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(847)
						p.Match(ManuscriptCOMMA)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(848)

						var _x = p.MapField()

						localctx.(*MapLiteralContext)._mapField = _x
					}
					localctx.(*MapLiteralContext).fields = append(localctx.(*MapLiteralContext).fields, localctx.(*MapLiteralContext)._mapField)

				}
				p.SetState(853)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(855)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == ManuscriptCOMMA {
				{
					p.SetState(854)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		{
			p.SetState(859)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExprContext

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetKey sets the key rule contexts.
	SetKey(IExprContext)

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	COLON() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExprContext
	value  IExprContext
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) GetKey() IExprContext { return s.key }

func (s *MapFieldContext) GetValue() IExprContext { return s.value }

func (s *MapFieldContext) SetKey(v IExprContext) { s.key = v }

func (s *MapFieldContext) SetValue(v IExprContext) { s.value = v }

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(862)

		var _x = p.Expr()

		localctx.(*MapFieldContext).key = _x
	}
	{
		p.SetState(863)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(864)

		var _x = p.Expr()

		localctx.(*MapFieldContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetElements returns the elements rule context list.
	GetElements() []IExprContext

	// SetElements sets the elements rule context list.
	SetElements([]IExprContext)

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	_expr    IExprContext
	elements []IExprContext
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) Get_expr() IExprContext { return s._expr }

func (s *SetLiteralContext) Set_expr(v IExprContext) { s._expr = v }

func (s *SetLiteralContext) GetElements() []IExprContext { return s.elements }

func (s *SetLiteralContext) SetElements(v []IExprContext) { s.elements = v }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ManuscriptRULE_setLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(ManuscriptLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-9169282104695939040) != 0) || ((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1023) != 0) {
		{
			p.SetState(867)

			var _x = p.Expr()

			localctx.(*SetLiteralContext)._expr = _x
		}
		localctx.(*SetLiteralContext).elements = append(localctx.(*SetLiteralContext).elements, localctx.(*SetLiteralContext)._expr)
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(868)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(869)

					var _x = p.Expr()

					localctx.(*SetLiteralContext)._expr = _x
				}
				localctx.(*SetLiteralContext).elements = append(localctx.(*SetLiteralContext).elements, localctx.(*SetLiteralContext)._expr)

			}
			p.SetState(874)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(875)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(880)
		p.Match(ManuscriptGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ManuscriptBREAK, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ManuscriptRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Match(ManuscriptBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCONTINUE, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ManuscriptRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		p.Match(ManuscriptCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetMessage returns the message rule contexts.
	GetMessage() IStringLiteralContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetMessage sets the message rule contexts.
	SetMessage(IStringLiteralContext)

	// Getter signatures
	CHECK() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	Expr() IExprContext
	StringLiteral() IStringLiteralContext
	SEMICOLON() antlr.TerminalNode

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
	message   IStringLiteralContext
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) GetCondition() IExprContext { return s.condition }

func (s *CheckStmtContext) GetMessage() IStringLiteralContext { return s.message }

func (s *CheckStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *CheckStmtContext) SetMessage(v IStringLiteralContext) { s.message = v }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *CheckStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *CheckStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CheckStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (s *CheckStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCheckStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ManuscriptRULE_checkStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(ManuscriptCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(887)

		var _x = p.Expr()

		localctx.(*CheckStmtContext).condition = _x
	}
	{
		p.SetState(888)
		p.Match(ManuscriptCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(889)

		var _x = p.StringLiteral()

		localctx.(*CheckStmtContext).message = _x
	}
	p.SetState(891)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(890)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaggedBlockStringContext is an interface to support dynamic dispatch.
type ITaggedBlockStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTag returns the tag token.
	GetTag() antlr.Token

	// SetTag sets the tag token.
	SetTag(antlr.Token)

	// GetBlockStrMultiSingle returns the blockStrMultiSingle rule contexts.
	GetBlockStrMultiSingle() IMultiQuotedStringContext

	// GetBlockStrMultiDouble returns the blockStrMultiDouble rule contexts.
	GetBlockStrMultiDouble() IMultiDoubleQuotedStringContext

	// SetBlockStrMultiSingle sets the blockStrMultiSingle rule contexts.
	SetBlockStrMultiSingle(IMultiQuotedStringContext)

	// SetBlockStrMultiDouble sets the blockStrMultiDouble rule contexts.
	SetBlockStrMultiDouble(IMultiDoubleQuotedStringContext)

	// Getter signatures
	ID() antlr.TerminalNode
	MultiQuotedString() IMultiQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsTaggedBlockStringContext differentiates from other interfaces.
	IsTaggedBlockStringContext()
}

type TaggedBlockStringContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	tag                 antlr.Token
	blockStrMultiSingle IMultiQuotedStringContext
	blockStrMultiDouble IMultiDoubleQuotedStringContext
}

func NewEmptyTaggedBlockStringContext() *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
	return p
}

func InitEmptyTaggedBlockStringContext(p *TaggedBlockStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
}

func (*TaggedBlockStringContext) IsTaggedBlockStringContext() {}

func NewTaggedBlockStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_taggedBlockString

	return p
}

func (s *TaggedBlockStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TaggedBlockStringContext) GetTag() antlr.Token { return s.tag }

func (s *TaggedBlockStringContext) SetTag(v antlr.Token) { s.tag = v }

func (s *TaggedBlockStringContext) GetBlockStrMultiSingle() IMultiQuotedStringContext {
	return s.blockStrMultiSingle
}

func (s *TaggedBlockStringContext) GetBlockStrMultiDouble() IMultiDoubleQuotedStringContext {
	return s.blockStrMultiDouble
}

func (s *TaggedBlockStringContext) SetBlockStrMultiSingle(v IMultiQuotedStringContext) {
	s.blockStrMultiSingle = v
}

func (s *TaggedBlockStringContext) SetBlockStrMultiDouble(v IMultiDoubleQuotedStringContext) {
	s.blockStrMultiDouble = v
}

func (s *TaggedBlockStringContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TaggedBlockStringContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *TaggedBlockStringContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *TaggedBlockStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaggedBlockStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaggedBlockStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTaggedBlockString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TaggedBlockString() (localctx ITaggedBlockStringContext) {
	localctx = NewTaggedBlockStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ManuscriptRULE_taggedBlockString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(893)

		var _m = p.Match(ManuscriptID)

		localctx.(*TaggedBlockStringContext).tag = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptMULTI_QUOTE_START:
		{
			p.SetState(894)

			var _x = p.MultiQuotedString()

			localctx.(*TaggedBlockStringContext).blockStrMultiSingle = _x
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		{
			p.SetState(895)

			var _x = p.MultiDoubleQuotedString()

			localctx.(*TaggedBlockStringContext).blockStrMultiDouble = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructInitExprContext is an interface to support dynamic dispatch.
type IStructInitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_structField returns the _structField rule contexts.
	Get_structField() IStructFieldContext

	// Set_structField sets the _structField rule contexts.
	Set_structField(IStructFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IStructFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IStructFieldContext)

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStructInitExprContext differentiates from other interfaces.
	IsStructInitExprContext()
}

type StructInitExprContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_structField IStructFieldContext
	fields       []IStructFieldContext
}

func NewEmptyStructInitExprContext() *StructInitExprContext {
	var p = new(StructInitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
	return p
}

func InitEmptyStructInitExprContext(p *StructInitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
}

func (*StructInitExprContext) IsStructInitExprContext() {}

func NewStructInitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructInitExprContext {
	var p = new(StructInitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structInitExpr

	return p
}

func (s *StructInitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StructInitExprContext) Get_structField() IStructFieldContext { return s._structField }

func (s *StructInitExprContext) Set_structField(v IStructFieldContext) { s._structField = v }

func (s *StructInitExprContext) GetFields() []IStructFieldContext { return s.fields }

func (s *StructInitExprContext) SetFields(v []IStructFieldContext) { s.fields = v }

func (s *StructInitExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructInitExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *StructInitExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *StructInitExprContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *StructInitExprContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *StructInitExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *StructInitExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *StructInitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructInitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructInitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructInitExpr(s)
	}
}

func (s *StructInitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructInitExpr(s)
	}
}

func (s *StructInitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructInitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructInitExpr() (localctx IStructInitExprContext) {
	localctx = NewStructInitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ManuscriptRULE_structInitExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(899)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(900)

			var _x = p.StructField()

			localctx.(*StructInitExprContext)._structField = _x
		}
		localctx.(*StructInitExprContext).fields = append(localctx.(*StructInitExprContext).fields, localctx.(*StructInitExprContext)._structField)
		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(901)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(902)

					var _x = p.StructField()

					localctx.(*StructInitExprContext)._structField = _x
				}
				localctx.(*StructInitExprContext).fields = append(localctx.(*StructInitExprContext).fields, localctx.(*StructInitExprContext)._structField)

			}
			p.SetState(907)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(908)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(913)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key token.
	GetKey() antlr.Token

	// SetKey sets the key token.
	SetKey(antlr.Token)

	// GetVal returns the val rule contexts.
	GetVal() IExprContext

	// SetVal sets the val rule contexts.
	SetVal(IExprContext)

	// Getter signatures
	COLON() antlr.TerminalNode
	ID() antlr.TerminalNode
	Expr() IExprContext

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    antlr.Token
	val    IExprContext
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) GetKey() antlr.Token { return s.key }

func (s *StructFieldContext) SetKey(v antlr.Token) { s.key = v }

func (s *StructFieldContext) GetVal() IExprContext { return s.val }

func (s *StructFieldContext) SetVal(v IExprContext) { s.val = v }

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *StructFieldContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ManuscriptRULE_structField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(915)

		var _m = p.Match(ManuscriptID)

		localctx.(*StructFieldContext).key = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(916)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(917)

		var _x = p.Expr()

		localctx.(*StructFieldContext).val = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
