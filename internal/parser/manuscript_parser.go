// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'", "'interface'",
		"'import'", "'export'", "'extern'", "'void'", "'check'", "'try'", "'catch'",
		"'in'", "'as'", "'is'", "'extends'", "'from'", "'null'", "'if'", "'else'",
		"'for'", "'while'", "'true'", "'false'", "'match'", "'case'", "'async'",
		"'await'", "'methods'", "'self'", "", "", "'['", "']'", "'('", "')'",
		"'<'", "'>'", "'<='", "'>='", "':'", "';'", "','", "'='", "'=='", "'+'",
		"'-'", "'++'", "'--'", "'||'", "'&&'", "'*'", "'/'", "'!'", "'?'", "'.'",
		"'!='", "'|'", "'&'", "'^'",
	}
	staticData.SymbolicNames = []string{
		"", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN", "YIELD",
		"TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID", "CHECK",
		"TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL", "IF", "ELSE",
		"FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC", "AWAIT",
		"METHODS", "SELF", "LBRACE", "RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN",
		"LT", "GT", "LT_EQUALS", "GT_EQUALS", "COLON", "SEMICOLON", "COMMA",
		"EQUALS", "EQUALS_EQUALS", "PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS",
		"PIPE_PIPE", "AMP_AMP", "STAR", "SLASH", "EXCLAMATION", "QUESTION",
		"DOT", "NEQ", "PIPE", "AMP", "CARET", "HEX_LITERAL", "BINARY_LITERAL",
		"FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"SINGLE_STR_INTERP_START", "SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START",
		"MULTI_STR_CONTENT", "MULTI_STR_END", "INTERP_LBRACE", "INTERP_RBRACE",
		"INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "programItem", "importStmt", "importItem", "externStmt",
		"externItem", "exportStmt", "letDecl", "letAssignment", "letPattern",
		"arrayPattn", "objectPattn", "fnDecl", "parameters", "param", "typeDecl",
		"fieldDecl", "ifaceDecl", "methodDecl", "methodBlockDecl", "methodImpl",
		"typeAnnotation", "baseTypeAnnotation", "functionType", "stmt", "exprStmt",
		"returnStmt", "yieldStmt", "ifStmt", "forStmt", "forInitPattn", "loopPattern",
		"whileStmt", "codeBlock", "expr", "assignmentExpr", "logicalOrExpr",
		"logicalAndExpr", "equalityExpr", "comparisonExpr", "additiveExpr",
		"multiplicativeExpr", "unaryExpr", "awaitExpr", "postfixExpr", "primaryExpr",
		"fnExpr", "lambdaExpr", "tryBlockExpr", "matchExpr", "caseClause", "singleQuotedString",
		"multiQuotedString", "stringPart", "interpolation", "literal", "stringLiteral",
		"numberLiteral", "booleanLiteral", "arrayLiteral", "objectLiteral",
		"objectField", "mapLiteral", "mapField", "setLiteral", "tupleLiteral",
		"importStr", "tupleType",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 80, 839, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 1, 0,
		5, 0, 138, 8, 0, 10, 0, 12, 0, 141, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 153, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 5, 2, 160, 8, 2, 10, 2, 12, 2, 163, 9, 2, 3, 2, 165, 8, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 173, 8, 2, 1, 2, 3, 2, 176, 8, 2, 1,
		3, 1, 3, 1, 3, 3, 3, 181, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 188,
		8, 4, 10, 4, 12, 4, 191, 9, 4, 3, 4, 193, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 201, 8, 4, 1, 4, 3, 4, 204, 8, 4, 1, 5, 1, 5, 1, 5, 3,
		5, 209, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 216, 8, 6, 1, 6, 3, 6,
		219, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 5, 7, 225, 8, 7, 10, 7, 12, 7, 228,
		9, 7, 1, 7, 3, 7, 231, 8, 7, 1, 8, 1, 8, 1, 8, 3, 8, 236, 8, 8, 1, 9, 1,
		9, 1, 9, 3, 9, 241, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 247, 8, 10,
		10, 10, 12, 10, 250, 9, 10, 3, 10, 252, 8, 10, 1, 10, 1, 10, 1, 11, 1,
		11, 1, 11, 1, 11, 5, 11, 260, 8, 11, 10, 11, 12, 11, 263, 9, 11, 3, 11,
		265, 8, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 273, 8, 12,
		1, 12, 1, 12, 1, 12, 3, 12, 278, 8, 12, 1, 12, 3, 12, 281, 8, 12, 1, 12,
		1, 12, 1, 13, 1, 13, 1, 13, 5, 13, 288, 8, 13, 10, 13, 12, 13, 291, 9,
		13, 1, 14, 3, 14, 294, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		301, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 309, 8, 15,
		10, 15, 12, 15, 312, 9, 15, 3, 15, 314, 8, 15, 1, 15, 1, 15, 5, 15, 318,
		8, 15, 10, 15, 12, 15, 321, 9, 15, 1, 15, 1, 15, 1, 16, 1, 16, 3, 16, 327,
		8, 16, 1, 16, 1, 16, 1, 16, 3, 16, 332, 8, 16, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 5, 17, 340, 8, 17, 10, 17, 12, 17, 343, 9, 17, 3, 17,
		345, 8, 17, 1, 17, 1, 17, 5, 17, 349, 8, 17, 10, 17, 12, 17, 352, 9, 17,
		1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 360, 8, 18, 1, 18, 1,
		18, 1, 18, 3, 18, 365, 8, 18, 1, 18, 3, 18, 368, 8, 18, 1, 18, 3, 18, 371,
		8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 377, 8, 19, 1, 19, 1, 19, 1,
		19, 5, 19, 382, 8, 19, 10, 19, 12, 19, 385, 9, 19, 1, 19, 1, 19, 1, 20,
		1, 20, 1, 20, 1, 20, 3, 20, 393, 8, 20, 1, 20, 1, 20, 1, 20, 3, 20, 398,
		8, 20, 1, 20, 3, 20, 401, 8, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1,
		21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 415, 8, 21, 10, 21,
		12, 21, 418, 9, 21, 1, 22, 1, 22, 1, 22, 3, 22, 423, 8, 22, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 5, 23, 430, 8, 23, 10, 23, 12, 23, 433, 9, 23, 3,
		23, 435, 8, 23, 1, 23, 1, 23, 3, 23, 439, 8, 23, 1, 24, 1, 24, 1, 24, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 450, 8, 24, 1, 25, 1, 25,
		3, 25, 454, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 460, 8, 26, 10, 26,
		12, 26, 463, 9, 26, 3, 26, 465, 8, 26, 1, 26, 3, 26, 468, 8, 26, 1, 27,
		1, 27, 3, 27, 472, 8, 27, 1, 27, 3, 27, 475, 8, 27, 1, 28, 1, 28, 1, 28,
		1, 28, 1, 28, 3, 28, 482, 8, 28, 1, 29, 1, 29, 3, 29, 486, 8, 29, 1, 29,
		1, 29, 3, 29, 490, 8, 29, 1, 29, 1, 29, 3, 29, 494, 8, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 502, 8, 29, 1, 29, 3, 29, 505, 8, 29,
		1, 30, 1, 30, 3, 30, 509, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
		31, 3, 31, 517, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 523, 8, 32, 1,
		33, 1, 33, 5, 33, 527, 8, 33, 10, 33, 12, 33, 530, 9, 33, 1, 33, 1, 33,
		1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 3, 35, 539, 8, 35, 1, 36, 1, 36, 1,
		36, 5, 36, 544, 8, 36, 10, 36, 12, 36, 547, 9, 36, 1, 37, 1, 37, 1, 37,
		5, 37, 552, 8, 37, 10, 37, 12, 37, 555, 9, 37, 1, 38, 1, 38, 1, 38, 5,
		38, 560, 8, 38, 10, 38, 12, 38, 563, 9, 38, 1, 39, 1, 39, 1, 39, 5, 39,
		568, 8, 39, 10, 39, 12, 39, 571, 9, 39, 1, 40, 1, 40, 1, 40, 5, 40, 576,
		8, 40, 10, 40, 12, 40, 579, 9, 40, 1, 41, 1, 41, 1, 41, 5, 41, 584, 8,
		41, 10, 41, 12, 41, 587, 9, 41, 1, 42, 1, 42, 1, 42, 3, 42, 592, 8, 42,
		1, 43, 3, 43, 595, 8, 43, 1, 43, 3, 43, 598, 8, 43, 1, 43, 3, 43, 601,
		8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 610, 8,
		44, 10, 44, 12, 44, 613, 9, 44, 3, 44, 615, 8, 44, 1, 44, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 624, 8, 44, 10, 44, 12, 44, 627, 9,
		44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 647, 8,
		45, 1, 46, 1, 46, 1, 46, 3, 46, 652, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46,
		657, 8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3, 47, 664, 8, 47, 1, 47,
		1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 1, 49, 5, 49, 679, 8, 49, 10, 49, 12, 49, 682, 9, 49, 3, 49, 684, 8,
		49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 693, 8, 50,
		1, 51, 1, 51, 5, 51, 697, 8, 51, 10, 51, 12, 51, 700, 9, 51, 1, 51, 1,
		51, 1, 52, 1, 52, 5, 52, 706, 8, 52, 10, 52, 12, 52, 709, 9, 52, 1, 52,
		1, 52, 1, 53, 1, 53, 1, 53, 3, 53, 716, 8, 53, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 727, 8, 55, 1, 56, 1, 56,
		3, 56, 731, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 737, 8, 57, 1, 58,
		1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 745, 8, 59, 10, 59, 12, 59, 748,
		9, 59, 3, 59, 750, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 5,
		60, 758, 8, 60, 10, 60, 12, 60, 761, 9, 60, 3, 60, 763, 8, 60, 1, 60, 1,
		60, 1, 61, 1, 61, 1, 61, 3, 61, 770, 8, 61, 1, 62, 1, 62, 1, 62, 1, 62,
		1, 62, 1, 62, 1, 62, 5, 62, 779, 8, 62, 10, 62, 12, 62, 782, 9, 62, 3,
		62, 784, 8, 62, 1, 62, 3, 62, 787, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 799, 8, 64, 10, 64, 12, 64,
		802, 9, 64, 3, 64, 804, 8, 64, 1, 64, 3, 64, 807, 8, 64, 1, 65, 1, 65,
		1, 65, 1, 65, 5, 65, 813, 8, 65, 10, 65, 12, 65, 816, 9, 65, 3, 65, 818,
		8, 65, 1, 65, 1, 65, 1, 66, 1, 66, 3, 66, 824, 8, 66, 1, 67, 1, 67, 1,
		67, 1, 67, 5, 67, 830, 8, 67, 10, 67, 12, 67, 833, 9, 67, 3, 67, 835, 8,
		67, 1, 67, 1, 67, 1, 67, 0, 0, 68, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 0, 7, 2, 0, 49, 49, 61, 61, 1, 0, 41, 44,
		1, 0, 50, 51, 1, 0, 56, 57, 3, 0, 14, 15, 50, 51, 58, 58, 2, 0, 72, 72,
		75, 75, 1, 0, 27, 28, 920, 0, 139, 1, 0, 0, 0, 2, 152, 1, 0, 0, 0, 4, 154,
		1, 0, 0, 0, 6, 177, 1, 0, 0, 0, 8, 182, 1, 0, 0, 0, 10, 205, 1, 0, 0, 0,
		12, 210, 1, 0, 0, 0, 14, 220, 1, 0, 0, 0, 16, 232, 1, 0, 0, 0, 18, 240,
		1, 0, 0, 0, 20, 242, 1, 0, 0, 0, 22, 255, 1, 0, 0, 0, 24, 268, 1, 0, 0,
		0, 26, 284, 1, 0, 0, 0, 28, 293, 1, 0, 0, 0, 30, 302, 1, 0, 0, 0, 32, 324,
		1, 0, 0, 0, 34, 333, 1, 0, 0, 0, 36, 355, 1, 0, 0, 0, 38, 372, 1, 0, 0,
		0, 40, 388, 1, 0, 0, 0, 42, 404, 1, 0, 0, 0, 44, 422, 1, 0, 0, 0, 46, 424,
		1, 0, 0, 0, 48, 449, 1, 0, 0, 0, 50, 451, 1, 0, 0, 0, 52, 455, 1, 0, 0,
		0, 54, 469, 1, 0, 0, 0, 56, 476, 1, 0, 0, 0, 58, 483, 1, 0, 0, 0, 60, 508,
		1, 0, 0, 0, 62, 516, 1, 0, 0, 0, 64, 518, 1, 0, 0, 0, 66, 524, 1, 0, 0,
		0, 68, 533, 1, 0, 0, 0, 70, 535, 1, 0, 0, 0, 72, 540, 1, 0, 0, 0, 74, 548,
		1, 0, 0, 0, 76, 556, 1, 0, 0, 0, 78, 564, 1, 0, 0, 0, 80, 572, 1, 0, 0,
		0, 82, 580, 1, 0, 0, 0, 84, 591, 1, 0, 0, 0, 86, 594, 1, 0, 0, 0, 88, 604,
		1, 0, 0, 0, 90, 646, 1, 0, 0, 0, 92, 648, 1, 0, 0, 0, 94, 660, 1, 0, 0,
		0, 96, 669, 1, 0, 0, 0, 98, 672, 1, 0, 0, 0, 100, 687, 1, 0, 0, 0, 102,
		694, 1, 0, 0, 0, 104, 703, 1, 0, 0, 0, 106, 715, 1, 0, 0, 0, 108, 717,
		1, 0, 0, 0, 110, 726, 1, 0, 0, 0, 112, 730, 1, 0, 0, 0, 114, 736, 1, 0,
		0, 0, 116, 738, 1, 0, 0, 0, 118, 740, 1, 0, 0, 0, 120, 753, 1, 0, 0, 0,
		122, 766, 1, 0, 0, 0, 124, 786, 1, 0, 0, 0, 126, 788, 1, 0, 0, 0, 128,
		806, 1, 0, 0, 0, 130, 808, 1, 0, 0, 0, 132, 823, 1, 0, 0, 0, 134, 825,
		1, 0, 0, 0, 136, 138, 3, 2, 1, 0, 137, 136, 1, 0, 0, 0, 138, 141, 1, 0,
		0, 0, 139, 137, 1, 0, 0, 0, 139, 140, 1, 0, 0, 0, 140, 142, 1, 0, 0, 0,
		141, 139, 1, 0, 0, 0, 142, 143, 5, 0, 0, 1, 143, 1, 1, 0, 0, 0, 144, 153,
		3, 4, 2, 0, 145, 153, 3, 8, 4, 0, 146, 153, 3, 12, 6, 0, 147, 153, 3, 48,
		24, 0, 148, 153, 3, 30, 15, 0, 149, 153, 3, 34, 17, 0, 150, 153, 3, 24,
		12, 0, 151, 153, 3, 38, 19, 0, 152, 144, 1, 0, 0, 0, 152, 145, 1, 0, 0,
		0, 152, 146, 1, 0, 0, 0, 152, 147, 1, 0, 0, 0, 152, 148, 1, 0, 0, 0, 152,
		149, 1, 0, 0, 0, 152, 150, 1, 0, 0, 0, 152, 151, 1, 0, 0, 0, 153, 3, 1,
		0, 0, 0, 154, 172, 5, 10, 0, 0, 155, 164, 5, 35, 0, 0, 156, 161, 3, 6,
		3, 0, 157, 158, 5, 47, 0, 0, 158, 160, 3, 6, 3, 0, 159, 157, 1, 0, 0, 0,
		160, 163, 1, 0, 0, 0, 161, 159, 1, 0, 0, 0, 161, 162, 1, 0, 0, 0, 162,
		165, 1, 0, 0, 0, 163, 161, 1, 0, 0, 0, 164, 156, 1, 0, 0, 0, 164, 165,
		1, 0, 0, 0, 165, 166, 1, 0, 0, 0, 166, 167, 5, 36, 0, 0, 167, 168, 5, 21,
		0, 0, 168, 173, 3, 132, 66, 0, 169, 170, 5, 69, 0, 0, 170, 171, 5, 21,
		0, 0, 171, 173, 3, 132, 66, 0, 172, 155, 1, 0, 0, 0, 172, 169, 1, 0, 0,
		0, 173, 175, 1, 0, 0, 0, 174, 176, 5, 46, 0, 0, 175, 174, 1, 0, 0, 0, 175,
		176, 1, 0, 0, 0, 176, 5, 1, 0, 0, 0, 177, 180, 5, 69, 0, 0, 178, 179, 5,
		18, 0, 0, 179, 181, 5, 69, 0, 0, 180, 178, 1, 0, 0, 0, 180, 181, 1, 0,
		0, 0, 181, 7, 1, 0, 0, 0, 182, 200, 5, 12, 0, 0, 183, 192, 5, 35, 0, 0,
		184, 189, 3, 10, 5, 0, 185, 186, 5, 47, 0, 0, 186, 188, 3, 10, 5, 0, 187,
		185, 1, 0, 0, 0, 188, 191, 1, 0, 0, 0, 189, 187, 1, 0, 0, 0, 189, 190,
		1, 0, 0, 0, 190, 193, 1, 0, 0, 0, 191, 189, 1, 0, 0, 0, 192, 184, 1, 0,
		0, 0, 192, 193, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0, 194, 195, 5, 36, 0, 0,
		195, 196, 5, 21, 0, 0, 196, 201, 3, 132, 66, 0, 197, 198, 5, 69, 0, 0,
		198, 199, 5, 21, 0, 0, 199, 201, 3, 132, 66, 0, 200, 183, 1, 0, 0, 0, 200,
		197, 1, 0, 0, 0, 201, 203, 1, 0, 0, 0, 202, 204, 5, 46, 0, 0, 203, 202,
		1, 0, 0, 0, 203, 204, 1, 0, 0, 0, 204, 9, 1, 0, 0, 0, 205, 208, 5, 69,
		0, 0, 206, 207, 5, 18, 0, 0, 207, 209, 5, 69, 0, 0, 208, 206, 1, 0, 0,
		0, 208, 209, 1, 0, 0, 0, 209, 11, 1, 0, 0, 0, 210, 215, 5, 11, 0, 0, 211,
		216, 3, 24, 12, 0, 212, 216, 3, 14, 7, 0, 213, 216, 3, 30, 15, 0, 214,
		216, 3, 34, 17, 0, 215, 211, 1, 0, 0, 0, 215, 212, 1, 0, 0, 0, 215, 213,
		1, 0, 0, 0, 215, 214, 1, 0, 0, 0, 216, 218, 1, 0, 0, 0, 217, 219, 5, 46,
		0, 0, 218, 217, 1, 0, 0, 0, 218, 219, 1, 0, 0, 0, 219, 13, 1, 0, 0, 0,
		220, 221, 5, 4, 0, 0, 221, 226, 3, 16, 8, 0, 222, 223, 5, 47, 0, 0, 223,
		225, 3, 16, 8, 0, 224, 222, 1, 0, 0, 0, 225, 228, 1, 0, 0, 0, 226, 224,
		1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 230, 1, 0, 0, 0, 228, 226, 1, 0,
		0, 0, 229, 231, 5, 46, 0, 0, 230, 229, 1, 0, 0, 0, 230, 231, 1, 0, 0, 0,
		231, 15, 1, 0, 0, 0, 232, 235, 3, 18, 9, 0, 233, 234, 5, 48, 0, 0, 234,
		236, 3, 68, 34, 0, 235, 233, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 17,
		1, 0, 0, 0, 237, 241, 5, 69, 0, 0, 238, 241, 3, 20, 10, 0, 239, 241, 3,
		22, 11, 0, 240, 237, 1, 0, 0, 0, 240, 238, 1, 0, 0, 0, 240, 239, 1, 0,
		0, 0, 241, 19, 1, 0, 0, 0, 242, 251, 5, 37, 0, 0, 243, 248, 5, 69, 0, 0,
		244, 245, 5, 47, 0, 0, 245, 247, 5, 69, 0, 0, 246, 244, 1, 0, 0, 0, 247,
		250, 1, 0, 0, 0, 248, 246, 1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 252,
		1, 0, 0, 0, 250, 248, 1, 0, 0, 0, 251, 243, 1, 0, 0, 0, 251, 252, 1, 0,
		0, 0, 252, 253, 1, 0, 0, 0, 253, 254, 5, 38, 0, 0, 254, 21, 1, 0, 0, 0,
		255, 264, 5, 35, 0, 0, 256, 261, 5, 69, 0, 0, 257, 258, 5, 47, 0, 0, 258,
		260, 5, 69, 0, 0, 259, 257, 1, 0, 0, 0, 260, 263, 1, 0, 0, 0, 261, 259,
		1, 0, 0, 0, 261, 262, 1, 0, 0, 0, 262, 265, 1, 0, 0, 0, 263, 261, 1, 0,
		0, 0, 264, 256, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0,
		266, 267, 5, 36, 0, 0, 267, 23, 1, 0, 0, 0, 268, 269, 5, 5, 0, 0, 269,
		270, 5, 69, 0, 0, 270, 272, 5, 39, 0, 0, 271, 273, 3, 26, 13, 0, 272, 271,
		1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 274, 1, 0, 0, 0, 274, 277, 5, 40,
		0, 0, 275, 276, 5, 45, 0, 0, 276, 278, 3, 42, 21, 0, 277, 275, 1, 0, 0,
		0, 277, 278, 1, 0, 0, 0, 278, 280, 1, 0, 0, 0, 279, 281, 5, 58, 0, 0, 280,
		279, 1, 0, 0, 0, 280, 281, 1, 0, 0, 0, 281, 282, 1, 0, 0, 0, 282, 283,
		3, 66, 33, 0, 283, 25, 1, 0, 0, 0, 284, 289, 3, 28, 14, 0, 285, 286, 5,
		47, 0, 0, 286, 288, 3, 28, 14, 0, 287, 285, 1, 0, 0, 0, 288, 291, 1, 0,
		0, 0, 289, 287, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 27, 1, 0, 0, 0,
		291, 289, 1, 0, 0, 0, 292, 294, 5, 69, 0, 0, 293, 292, 1, 0, 0, 0, 293,
		294, 1, 0, 0, 0, 294, 295, 1, 0, 0, 0, 295, 296, 5, 69, 0, 0, 296, 297,
		5, 45, 0, 0, 297, 300, 3, 42, 21, 0, 298, 299, 5, 48, 0, 0, 299, 301, 3,
		68, 34, 0, 300, 298, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 29, 1, 0, 0,
		0, 302, 303, 5, 8, 0, 0, 303, 313, 5, 69, 0, 0, 304, 305, 5, 20, 0, 0,
		305, 310, 3, 42, 21, 0, 306, 307, 5, 47, 0, 0, 307, 309, 3, 42, 21, 0,
		308, 306, 1, 0, 0, 0, 309, 312, 1, 0, 0, 0, 310, 308, 1, 0, 0, 0, 310,
		311, 1, 0, 0, 0, 311, 314, 1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 313, 304,
		1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 319, 5, 35,
		0, 0, 316, 318, 3, 32, 16, 0, 317, 316, 1, 0, 0, 0, 318, 321, 1, 0, 0,
		0, 319, 317, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 322, 1, 0, 0, 0, 321,
		319, 1, 0, 0, 0, 322, 323, 5, 36, 0, 0, 323, 31, 1, 0, 0, 0, 324, 326,
		5, 69, 0, 0, 325, 327, 5, 59, 0, 0, 326, 325, 1, 0, 0, 0, 326, 327, 1,
		0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 329, 5, 45, 0, 0, 329, 331, 3, 42,
		21, 0, 330, 332, 5, 46, 0, 0, 331, 330, 1, 0, 0, 0, 331, 332, 1, 0, 0,
		0, 332, 33, 1, 0, 0, 0, 333, 334, 5, 9, 0, 0, 334, 344, 5, 69, 0, 0, 335,
		336, 5, 20, 0, 0, 336, 341, 3, 42, 21, 0, 337, 338, 5, 47, 0, 0, 338, 340,
		3, 42, 21, 0, 339, 337, 1, 0, 0, 0, 340, 343, 1, 0, 0, 0, 341, 339, 1,
		0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 345, 1, 0, 0, 0, 343, 341, 1, 0, 0,
		0, 344, 335, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346,
		350, 5, 35, 0, 0, 347, 349, 3, 36, 18, 0, 348, 347, 1, 0, 0, 0, 349, 352,
		1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 353, 1, 0,
		0, 0, 352, 350, 1, 0, 0, 0, 353, 354, 5, 36, 0, 0, 354, 35, 1, 0, 0, 0,
		355, 356, 5, 5, 0, 0, 356, 357, 5, 69, 0, 0, 357, 359, 5, 39, 0, 0, 358,
		360, 3, 26, 13, 0, 359, 358, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 361,
		1, 0, 0, 0, 361, 364, 5, 40, 0, 0, 362, 363, 5, 45, 0, 0, 363, 365, 3,
		42, 21, 0, 364, 362, 1, 0, 0, 0, 364, 365, 1, 0, 0, 0, 365, 367, 1, 0,
		0, 0, 366, 368, 5, 58, 0, 0, 367, 366, 1, 0, 0, 0, 367, 368, 1, 0, 0, 0,
		368, 370, 1, 0, 0, 0, 369, 371, 5, 46, 0, 0, 370, 369, 1, 0, 0, 0, 370,
		371, 1, 0, 0, 0, 371, 37, 1, 0, 0, 0, 372, 376, 5, 33, 0, 0, 373, 374,
		3, 42, 21, 0, 374, 375, 5, 25, 0, 0, 375, 377, 1, 0, 0, 0, 376, 373, 1,
		0, 0, 0, 376, 377, 1, 0, 0, 0, 377, 378, 1, 0, 0, 0, 378, 379, 3, 42, 21,
		0, 379, 383, 5, 35, 0, 0, 380, 382, 3, 40, 20, 0, 381, 380, 1, 0, 0, 0,
		382, 385, 1, 0, 0, 0, 383, 381, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384,
		386, 1, 0, 0, 0, 385, 383, 1, 0, 0, 0, 386, 387, 5, 36, 0, 0, 387, 39,
		1, 0, 0, 0, 388, 389, 5, 5, 0, 0, 389, 390, 5, 69, 0, 0, 390, 392, 5, 39,
		0, 0, 391, 393, 3, 26, 13, 0, 392, 391, 1, 0, 0, 0, 392, 393, 1, 0, 0,
		0, 393, 394, 1, 0, 0, 0, 394, 397, 5, 40, 0, 0, 395, 396, 5, 45, 0, 0,
		396, 398, 3, 42, 21, 0, 397, 395, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398,
		400, 1, 0, 0, 0, 399, 401, 5, 58, 0, 0, 400, 399, 1, 0, 0, 0, 400, 401,
		1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 403, 3, 66, 33, 0, 403, 41, 1, 0,
		0, 0, 404, 416, 3, 44, 22, 0, 405, 406, 5, 37, 0, 0, 406, 415, 5, 38, 0,
		0, 407, 408, 5, 37, 0, 0, 408, 409, 5, 45, 0, 0, 409, 410, 3, 42, 21, 0,
		410, 411, 5, 38, 0, 0, 411, 415, 1, 0, 0, 0, 412, 413, 5, 41, 0, 0, 413,
		415, 5, 42, 0, 0, 414, 405, 1, 0, 0, 0, 414, 407, 1, 0, 0, 0, 414, 412,
		1, 0, 0, 0, 415, 418, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 416, 417, 1, 0,
		0, 0, 417, 43, 1, 0, 0, 0, 418, 416, 1, 0, 0, 0, 419, 423, 5, 69, 0, 0,
		420, 423, 3, 134, 67, 0, 421, 423, 3, 46, 23, 0, 422, 419, 1, 0, 0, 0,
		422, 420, 1, 0, 0, 0, 422, 421, 1, 0, 0, 0, 423, 45, 1, 0, 0, 0, 424, 425,
		5, 5, 0, 0, 425, 434, 5, 39, 0, 0, 426, 431, 3, 42, 21, 0, 427, 428, 5,
		47, 0, 0, 428, 430, 3, 42, 21, 0, 429, 427, 1, 0, 0, 0, 430, 433, 1, 0,
		0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 435, 1, 0, 0, 0,
		433, 431, 1, 0, 0, 0, 434, 426, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435,
		436, 1, 0, 0, 0, 436, 438, 5, 40, 0, 0, 437, 439, 3, 42, 21, 0, 438, 437,
		1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 47, 1, 0, 0, 0, 440, 450, 3, 14,
		7, 0, 441, 450, 3, 50, 25, 0, 442, 450, 3, 52, 26, 0, 443, 450, 3, 54,
		27, 0, 444, 450, 3, 56, 28, 0, 445, 450, 3, 58, 29, 0, 446, 450, 3, 64,
		32, 0, 447, 450, 3, 66, 33, 0, 448, 450, 5, 46, 0, 0, 449, 440, 1, 0, 0,
		0, 449, 441, 1, 0, 0, 0, 449, 442, 1, 0, 0, 0, 449, 443, 1, 0, 0, 0, 449,
		444, 1, 0, 0, 0, 449, 445, 1, 0, 0, 0, 449, 446, 1, 0, 0, 0, 449, 447,
		1, 0, 0, 0, 449, 448, 1, 0, 0, 0, 450, 49, 1, 0, 0, 0, 451, 453, 3, 68,
		34, 0, 452, 454, 5, 46, 0, 0, 453, 452, 1, 0, 0, 0, 453, 454, 1, 0, 0,
		0, 454, 51, 1, 0, 0, 0, 455, 464, 5, 6, 0, 0, 456, 461, 3, 68, 34, 0, 457,
		458, 5, 47, 0, 0, 458, 460, 3, 68, 34, 0, 459, 457, 1, 0, 0, 0, 460, 463,
		1, 0, 0, 0, 461, 459, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 465, 1, 0,
		0, 0, 463, 461, 1, 0, 0, 0, 464, 456, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0,
		465, 467, 1, 0, 0, 0, 466, 468, 5, 46, 0, 0, 467, 466, 1, 0, 0, 0, 467,
		468, 1, 0, 0, 0, 468, 53, 1, 0, 0, 0, 469, 471, 5, 7, 0, 0, 470, 472, 3,
		68, 34, 0, 471, 470, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474, 1, 0,
		0, 0, 473, 475, 5, 46, 0, 0, 474, 473, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0,
		475, 55, 1, 0, 0, 0, 476, 477, 5, 23, 0, 0, 477, 478, 3, 68, 34, 0, 478,
		481, 3, 66, 33, 0, 479, 480, 5, 24, 0, 0, 480, 482, 3, 66, 33, 0, 481,
		479, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 57, 1, 0, 0, 0, 483, 501, 5,
		25, 0, 0, 484, 486, 3, 60, 30, 0, 485, 484, 1, 0, 0, 0, 485, 486, 1, 0,
		0, 0, 486, 487, 1, 0, 0, 0, 487, 489, 5, 46, 0, 0, 488, 490, 3, 68, 34,
		0, 489, 488, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 491, 1, 0, 0, 0, 491,
		493, 5, 46, 0, 0, 492, 494, 3, 68, 34, 0, 493, 492, 1, 0, 0, 0, 493, 494,
		1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 502, 3, 66, 33, 0, 496, 497, 3,
		62, 31, 0, 497, 498, 5, 17, 0, 0, 498, 499, 3, 68, 34, 0, 499, 500, 3,
		66, 33, 0, 500, 502, 1, 0, 0, 0, 501, 485, 1, 0, 0, 0, 501, 496, 1, 0,
		0, 0, 502, 504, 1, 0, 0, 0, 503, 505, 5, 46, 0, 0, 504, 503, 1, 0, 0, 0,
		504, 505, 1, 0, 0, 0, 505, 59, 1, 0, 0, 0, 506, 509, 3, 14, 7, 0, 507,
		509, 3, 50, 25, 0, 508, 506, 1, 0, 0, 0, 508, 507, 1, 0, 0, 0, 509, 61,
		1, 0, 0, 0, 510, 517, 5, 69, 0, 0, 511, 512, 5, 37, 0, 0, 512, 513, 5,
		69, 0, 0, 513, 514, 5, 47, 0, 0, 514, 515, 5, 69, 0, 0, 515, 517, 5, 38,
		0, 0, 516, 510, 1, 0, 0, 0, 516, 511, 1, 0, 0, 0, 517, 63, 1, 0, 0, 0,
		518, 519, 5, 26, 0, 0, 519, 520, 3, 68, 34, 0, 520, 522, 3, 66, 33, 0,
		521, 523, 5, 46, 0, 0, 522, 521, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523,
		65, 1, 0, 0, 0, 524, 528, 5, 35, 0, 0, 525, 527, 3, 48, 24, 0, 526, 525,
		1, 0, 0, 0, 527, 530, 1, 0, 0, 0, 528, 526, 1, 0, 0, 0, 528, 529, 1, 0,
		0, 0, 529, 531, 1, 0, 0, 0, 530, 528, 1, 0, 0, 0, 531, 532, 5, 36, 0, 0,
		532, 67, 1, 0, 0, 0, 533, 534, 3, 70, 35, 0, 534, 69, 1, 0, 0, 0, 535,
		538, 3, 72, 36, 0, 536, 537, 5, 48, 0, 0, 537, 539, 3, 70, 35, 0, 538,
		536, 1, 0, 0, 0, 538, 539, 1, 0, 0, 0, 539, 71, 1, 0, 0, 0, 540, 545, 3,
		74, 37, 0, 541, 542, 5, 54, 0, 0, 542, 544, 3, 74, 37, 0, 543, 541, 1,
		0, 0, 0, 544, 547, 1, 0, 0, 0, 545, 543, 1, 0, 0, 0, 545, 546, 1, 0, 0,
		0, 546, 73, 1, 0, 0, 0, 547, 545, 1, 0, 0, 0, 548, 553, 3, 76, 38, 0, 549,
		550, 5, 55, 0, 0, 550, 552, 3, 76, 38, 0, 551, 549, 1, 0, 0, 0, 552, 555,
		1, 0, 0, 0, 553, 551, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 75, 1, 0,
		0, 0, 555, 553, 1, 0, 0, 0, 556, 561, 3, 78, 39, 0, 557, 558, 7, 0, 0,
		0, 558, 560, 3, 78, 39, 0, 559, 557, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0,
		561, 559, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 77, 1, 0, 0, 0, 563, 561,
		1, 0, 0, 0, 564, 569, 3, 80, 40, 0, 565, 566, 7, 1, 0, 0, 566, 568, 3,
		80, 40, 0, 567, 565, 1, 0, 0, 0, 568, 571, 1, 0, 0, 0, 569, 567, 1, 0,
		0, 0, 569, 570, 1, 0, 0, 0, 570, 79, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0,
		572, 577, 3, 82, 41, 0, 573, 574, 7, 2, 0, 0, 574, 576, 3, 82, 41, 0, 575,
		573, 1, 0, 0, 0, 576, 579, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 577, 578,
		1, 0, 0, 0, 578, 81, 1, 0, 0, 0, 579, 577, 1, 0, 0, 0, 580, 585, 3, 84,
		42, 0, 581, 582, 7, 3, 0, 0, 582, 584, 3, 84, 42, 0, 583, 581, 1, 0, 0,
		0, 584, 587, 1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586,
		83, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 588, 589, 7, 4, 0, 0, 589, 592, 3,
		84, 42, 0, 590, 592, 3, 86, 43, 0, 591, 588, 1, 0, 0, 0, 591, 590, 1, 0,
		0, 0, 592, 85, 1, 0, 0, 0, 593, 595, 5, 15, 0, 0, 594, 593, 1, 0, 0, 0,
		594, 595, 1, 0, 0, 0, 595, 597, 1, 0, 0, 0, 596, 598, 5, 32, 0, 0, 597,
		596, 1, 0, 0, 0, 597, 598, 1, 0, 0, 0, 598, 600, 1, 0, 0, 0, 599, 601,
		5, 31, 0, 0, 600, 599, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0, 601, 602, 1, 0,
		0, 0, 602, 603, 3, 88, 44, 0, 603, 87, 1, 0, 0, 0, 604, 625, 3, 90, 45,
		0, 605, 614, 5, 39, 0, 0, 606, 611, 3, 68, 34, 0, 607, 608, 5, 47, 0, 0,
		608, 610, 3, 68, 34, 0, 609, 607, 1, 0, 0, 0, 610, 613, 1, 0, 0, 0, 611,
		609, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 615, 1, 0, 0, 0, 613, 611,
		1, 0, 0, 0, 614, 606, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 616, 1, 0,
		0, 0, 616, 624, 5, 40, 0, 0, 617, 618, 5, 60, 0, 0, 618, 624, 5, 69, 0,
		0, 619, 620, 5, 37, 0, 0, 620, 621, 3, 68, 34, 0, 621, 622, 5, 38, 0, 0,
		622, 624, 1, 0, 0, 0, 623, 605, 1, 0, 0, 0, 623, 617, 1, 0, 0, 0, 623,
		619, 1, 0, 0, 0, 624, 627, 1, 0, 0, 0, 625, 623, 1, 0, 0, 0, 625, 626,
		1, 0, 0, 0, 626, 89, 1, 0, 0, 0, 627, 625, 1, 0, 0, 0, 628, 647, 3, 110,
		55, 0, 629, 647, 5, 69, 0, 0, 630, 647, 5, 34, 0, 0, 631, 632, 5, 39, 0,
		0, 632, 633, 3, 68, 34, 0, 633, 634, 5, 40, 0, 0, 634, 647, 1, 0, 0, 0,
		635, 647, 3, 118, 59, 0, 636, 647, 3, 120, 60, 0, 637, 647, 3, 124, 62,
		0, 638, 647, 3, 128, 64, 0, 639, 647, 3, 130, 65, 0, 640, 647, 3, 92, 46,
		0, 641, 647, 3, 94, 47, 0, 642, 647, 3, 96, 48, 0, 643, 647, 3, 98, 49,
		0, 644, 647, 5, 13, 0, 0, 645, 647, 5, 22, 0, 0, 646, 628, 1, 0, 0, 0,
		646, 629, 1, 0, 0, 0, 646, 630, 1, 0, 0, 0, 646, 631, 1, 0, 0, 0, 646,
		635, 1, 0, 0, 0, 646, 636, 1, 0, 0, 0, 646, 637, 1, 0, 0, 0, 646, 638,
		1, 0, 0, 0, 646, 639, 1, 0, 0, 0, 646, 640, 1, 0, 0, 0, 646, 641, 1, 0,
		0, 0, 646, 642, 1, 0, 0, 0, 646, 643, 1, 0, 0, 0, 646, 644, 1, 0, 0, 0,
		646, 645, 1, 0, 0, 0, 647, 91, 1, 0, 0, 0, 648, 649, 5, 5, 0, 0, 649, 651,
		5, 39, 0, 0, 650, 652, 3, 26, 13, 0, 651, 650, 1, 0, 0, 0, 651, 652, 1,
		0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 656, 5, 40, 0, 0, 654, 655, 5, 45,
		0, 0, 655, 657, 3, 42, 21, 0, 656, 654, 1, 0, 0, 0, 656, 657, 1, 0, 0,
		0, 657, 658, 1, 0, 0, 0, 658, 659, 3, 66, 33, 0, 659, 93, 1, 0, 0, 0, 660,
		661, 5, 5, 0, 0, 661, 663, 5, 39, 0, 0, 662, 664, 3, 26, 13, 0, 663, 662,
		1, 0, 0, 0, 663, 664, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 666, 5, 40,
		0, 0, 666, 667, 5, 48, 0, 0, 667, 668, 3, 68, 34, 0, 668, 95, 1, 0, 0,
		0, 669, 670, 5, 15, 0, 0, 670, 671, 3, 66, 33, 0, 671, 97, 1, 0, 0, 0,
		672, 673, 5, 29, 0, 0, 673, 674, 3, 68, 34, 0, 674, 683, 5, 35, 0, 0, 675,
		680, 3, 100, 50, 0, 676, 677, 5, 47, 0, 0, 677, 679, 3, 100, 50, 0, 678,
		676, 1, 0, 0, 0, 679, 682, 1, 0, 0, 0, 680, 678, 1, 0, 0, 0, 680, 681,
		1, 0, 0, 0, 681, 684, 1, 0, 0, 0, 682, 680, 1, 0, 0, 0, 683, 675, 1, 0,
		0, 0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 686, 5, 36, 0, 0,
		686, 99, 1, 0, 0, 0, 687, 688, 5, 30, 0, 0, 688, 689, 3, 68, 34, 0, 689,
		690, 5, 45, 0, 0, 690, 692, 3, 68, 34, 0, 691, 693, 5, 46, 0, 0, 692, 691,
		1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 101, 1, 0, 0, 0, 694, 698, 5, 70,
		0, 0, 695, 697, 3, 106, 53, 0, 696, 695, 1, 0, 0, 0, 697, 700, 1, 0, 0,
		0, 698, 696, 1, 0, 0, 0, 698, 699, 1, 0, 0, 0, 699, 701, 1, 0, 0, 0, 700,
		698, 1, 0, 0, 0, 701, 702, 5, 74, 0, 0, 702, 103, 1, 0, 0, 0, 703, 707,
		5, 71, 0, 0, 704, 706, 3, 106, 53, 0, 705, 704, 1, 0, 0, 0, 706, 709, 1,
		0, 0, 0, 707, 705, 1, 0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 710, 1, 0, 0,
		0, 709, 707, 1, 0, 0, 0, 710, 711, 5, 77, 0, 0, 711, 105, 1, 0, 0, 0, 712,
		716, 5, 73, 0, 0, 713, 716, 5, 76, 0, 0, 714, 716, 3, 108, 54, 0, 715,
		712, 1, 0, 0, 0, 715, 713, 1, 0, 0, 0, 715, 714, 1, 0, 0, 0, 716, 107,
		1, 0, 0, 0, 717, 718, 7, 5, 0, 0, 718, 719, 3, 68, 34, 0, 719, 720, 5,
		79, 0, 0, 720, 109, 1, 0, 0, 0, 721, 727, 3, 112, 56, 0, 722, 727, 3, 114,
		57, 0, 723, 727, 3, 116, 58, 0, 724, 727, 5, 22, 0, 0, 725, 727, 5, 13,
		0, 0, 726, 721, 1, 0, 0, 0, 726, 722, 1, 0, 0, 0, 726, 723, 1, 0, 0, 0,
		726, 724, 1, 0, 0, 0, 726, 725, 1, 0, 0, 0, 727, 111, 1, 0, 0, 0, 728,
		731, 3, 102, 51, 0, 729, 731, 3, 104, 52, 0, 730, 728, 1, 0, 0, 0, 730,
		729, 1, 0, 0, 0, 731, 113, 1, 0, 0, 0, 732, 737, 5, 68, 0, 0, 733, 737,
		5, 67, 0, 0, 734, 737, 5, 65, 0, 0, 735, 737, 5, 66, 0, 0, 736, 732, 1,
		0, 0, 0, 736, 733, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 736, 735, 1, 0, 0,
		0, 737, 115, 1, 0, 0, 0, 738, 739, 7, 6, 0, 0, 739, 117, 1, 0, 0, 0, 740,
		749, 5, 37, 0, 0, 741, 746, 3, 68, 34, 0, 742, 743, 5, 47, 0, 0, 743, 745,
		3, 68, 34, 0, 744, 742, 1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746, 744, 1,
		0, 0, 0, 746, 747, 1, 0, 0, 0, 747, 750, 1, 0, 0, 0, 748, 746, 1, 0, 0,
		0, 749, 741, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751,
		752, 5, 38, 0, 0, 752, 119, 1, 0, 0, 0, 753, 762, 5, 35, 0, 0, 754, 759,
		3, 122, 61, 0, 755, 756, 5, 47, 0, 0, 756, 758, 3, 122, 61, 0, 757, 755,
		1, 0, 0, 0, 758, 761, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 759, 760, 1, 0,
		0, 0, 760, 763, 1, 0, 0, 0, 761, 759, 1, 0, 0, 0, 762, 754, 1, 0, 0, 0,
		762, 763, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 765, 5, 36, 0, 0, 765,
		121, 1, 0, 0, 0, 766, 769, 5, 69, 0, 0, 767, 768, 5, 45, 0, 0, 768, 770,
		3, 68, 34, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 123, 1,
		0, 0, 0, 771, 772, 5, 37, 0, 0, 772, 773, 5, 45, 0, 0, 773, 787, 5, 38,
		0, 0, 774, 783, 5, 37, 0, 0, 775, 780, 3, 126, 63, 0, 776, 777, 5, 47,
		0, 0, 777, 779, 3, 126, 63, 0, 778, 776, 1, 0, 0, 0, 779, 782, 1, 0, 0,
		0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 784, 1, 0, 0, 0, 782,
		780, 1, 0, 0, 0, 783, 775, 1, 0, 0, 0, 783, 784, 1, 0, 0, 0, 784, 785,
		1, 0, 0, 0, 785, 787, 5, 38, 0, 0, 786, 771, 1, 0, 0, 0, 786, 774, 1, 0,
		0, 0, 787, 125, 1, 0, 0, 0, 788, 789, 3, 68, 34, 0, 789, 790, 5, 45, 0,
		0, 790, 791, 3, 68, 34, 0, 791, 127, 1, 0, 0, 0, 792, 793, 5, 41, 0, 0,
		793, 807, 5, 42, 0, 0, 794, 803, 5, 41, 0, 0, 795, 800, 3, 68, 34, 0, 796,
		797, 5, 47, 0, 0, 797, 799, 3, 68, 34, 0, 798, 796, 1, 0, 0, 0, 799, 802,
		1, 0, 0, 0, 800, 798, 1, 0, 0, 0, 800, 801, 1, 0, 0, 0, 801, 804, 1, 0,
		0, 0, 802, 800, 1, 0, 0, 0, 803, 795, 1, 0, 0, 0, 803, 804, 1, 0, 0, 0,
		804, 805, 1, 0, 0, 0, 805, 807, 5, 42, 0, 0, 806, 792, 1, 0, 0, 0, 806,
		794, 1, 0, 0, 0, 807, 129, 1, 0, 0, 0, 808, 817, 5, 39, 0, 0, 809, 814,
		3, 68, 34, 0, 810, 811, 5, 47, 0, 0, 811, 813, 3, 68, 34, 0, 812, 810,
		1, 0, 0, 0, 813, 816, 1, 0, 0, 0, 814, 812, 1, 0, 0, 0, 814, 815, 1, 0,
		0, 0, 815, 818, 1, 0, 0, 0, 816, 814, 1, 0, 0, 0, 817, 809, 1, 0, 0, 0,
		817, 818, 1, 0, 0, 0, 818, 819, 1, 0, 0, 0, 819, 820, 5, 40, 0, 0, 820,
		131, 1, 0, 0, 0, 821, 824, 3, 102, 51, 0, 822, 824, 3, 104, 52, 0, 823,
		821, 1, 0, 0, 0, 823, 822, 1, 0, 0, 0, 824, 133, 1, 0, 0, 0, 825, 834,
		5, 39, 0, 0, 826, 831, 3, 42, 21, 0, 827, 828, 5, 47, 0, 0, 828, 830, 3,
		42, 21, 0, 829, 827, 1, 0, 0, 0, 830, 833, 1, 0, 0, 0, 831, 829, 1, 0,
		0, 0, 831, 832, 1, 0, 0, 0, 832, 835, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0,
		834, 826, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836,
		837, 5, 40, 0, 0, 837, 135, 1, 0, 0, 0, 112, 139, 152, 161, 164, 172, 175,
		180, 189, 192, 200, 203, 208, 215, 218, 226, 230, 235, 240, 248, 251, 261,
		264, 272, 277, 280, 289, 293, 300, 310, 313, 319, 326, 331, 341, 344, 350,
		359, 364, 367, 370, 376, 383, 392, 397, 400, 414, 416, 422, 431, 434, 438,
		449, 453, 461, 464, 467, 471, 474, 481, 485, 489, 493, 501, 504, 508, 516,
		522, 528, 538, 545, 553, 561, 569, 577, 585, 591, 594, 597, 600, 611, 614,
		623, 625, 646, 651, 656, 663, 680, 683, 692, 698, 707, 715, 726, 730, 736,
		746, 749, 759, 762, 769, 780, 783, 786, 800, 803, 806, 814, 817, 823, 831,
		834,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                     = antlr.TokenEOF
	ManuscriptWS                      = 1
	ManuscriptCOMMENT                 = 2
	ManuscriptMULTI_LINE_COMMENT      = 3
	ManuscriptLET                     = 4
	ManuscriptFN                      = 5
	ManuscriptRETURN                  = 6
	ManuscriptYIELD                   = 7
	ManuscriptTYPE                    = 8
	ManuscriptINTERFACE               = 9
	ManuscriptIMPORT                  = 10
	ManuscriptEXPORT                  = 11
	ManuscriptEXTERN                  = 12
	ManuscriptVOID                    = 13
	ManuscriptCHECK                   = 14
	ManuscriptTRY                     = 15
	ManuscriptCATCH                   = 16
	ManuscriptIN                      = 17
	ManuscriptAS                      = 18
	ManuscriptIS                      = 19
	ManuscriptEXTENDS                 = 20
	ManuscriptFROM                    = 21
	ManuscriptNULL                    = 22
	ManuscriptIF                      = 23
	ManuscriptELSE                    = 24
	ManuscriptFOR                     = 25
	ManuscriptWHILE                   = 26
	ManuscriptTRUE                    = 27
	ManuscriptFALSE                   = 28
	ManuscriptMATCH                   = 29
	ManuscriptCASE                    = 30
	ManuscriptASYNC                   = 31
	ManuscriptAWAIT                   = 32
	ManuscriptMETHODS                 = 33
	ManuscriptSELF                    = 34
	ManuscriptLBRACE                  = 35
	ManuscriptRBRACE                  = 36
	ManuscriptLSQBR                   = 37
	ManuscriptRSQBR                   = 38
	ManuscriptLPAREN                  = 39
	ManuscriptRPAREN                  = 40
	ManuscriptLT                      = 41
	ManuscriptGT                      = 42
	ManuscriptLT_EQUALS               = 43
	ManuscriptGT_EQUALS               = 44
	ManuscriptCOLON                   = 45
	ManuscriptSEMICOLON               = 46
	ManuscriptCOMMA                   = 47
	ManuscriptEQUALS                  = 48
	ManuscriptEQUALS_EQUALS           = 49
	ManuscriptPLUS                    = 50
	ManuscriptMINUS                   = 51
	ManuscriptPLUS_PLUS               = 52
	ManuscriptMINUS_MINUS             = 53
	ManuscriptPIPE_PIPE               = 54
	ManuscriptAMP_AMP                 = 55
	ManuscriptSTAR                    = 56
	ManuscriptSLASH                   = 57
	ManuscriptEXCLAMATION             = 58
	ManuscriptQUESTION                = 59
	ManuscriptDOT                     = 60
	ManuscriptNEQ                     = 61
	ManuscriptPIPE                    = 62
	ManuscriptAMP                     = 63
	ManuscriptCARET                   = 64
	ManuscriptHEX_LITERAL             = 65
	ManuscriptBINARY_LITERAL          = 66
	ManuscriptFLOAT                   = 67
	ManuscriptINTEGER                 = 68
	ManuscriptID                      = 69
	ManuscriptSINGLE_QUOTE_START      = 70
	ManuscriptMULTI_QUOTE_START       = 71
	ManuscriptSINGLE_STR_INTERP_START = 72
	ManuscriptSINGLE_STR_CONTENT      = 73
	ManuscriptSINGLE_STR_END          = 74
	ManuscriptMULTI_STR_INTERP_START  = 75
	ManuscriptMULTI_STR_CONTENT       = 76
	ManuscriptMULTI_STR_END           = 77
	ManuscriptINTERP_LBRACE           = 78
	ManuscriptINTERP_RBRACE           = 79
	ManuscriptINTERP_WS               = 80
)

// Manuscript rules.
const (
	ManuscriptRULE_program            = 0
	ManuscriptRULE_programItem        = 1
	ManuscriptRULE_importStmt         = 2
	ManuscriptRULE_importItem         = 3
	ManuscriptRULE_externStmt         = 4
	ManuscriptRULE_externItem         = 5
	ManuscriptRULE_exportStmt         = 6
	ManuscriptRULE_letDecl            = 7
	ManuscriptRULE_letAssignment      = 8
	ManuscriptRULE_letPattern         = 9
	ManuscriptRULE_arrayPattn         = 10
	ManuscriptRULE_objectPattn        = 11
	ManuscriptRULE_fnDecl             = 12
	ManuscriptRULE_parameters         = 13
	ManuscriptRULE_param              = 14
	ManuscriptRULE_typeDecl           = 15
	ManuscriptRULE_fieldDecl          = 16
	ManuscriptRULE_ifaceDecl          = 17
	ManuscriptRULE_methodDecl         = 18
	ManuscriptRULE_methodBlockDecl    = 19
	ManuscriptRULE_methodImpl         = 20
	ManuscriptRULE_typeAnnotation     = 21
	ManuscriptRULE_baseTypeAnnotation = 22
	ManuscriptRULE_functionType       = 23
	ManuscriptRULE_stmt               = 24
	ManuscriptRULE_exprStmt           = 25
	ManuscriptRULE_returnStmt         = 26
	ManuscriptRULE_yieldStmt          = 27
	ManuscriptRULE_ifStmt             = 28
	ManuscriptRULE_forStmt            = 29
	ManuscriptRULE_forInitPattn       = 30
	ManuscriptRULE_loopPattern        = 31
	ManuscriptRULE_whileStmt          = 32
	ManuscriptRULE_codeBlock          = 33
	ManuscriptRULE_expr               = 34
	ManuscriptRULE_assignmentExpr     = 35
	ManuscriptRULE_logicalOrExpr      = 36
	ManuscriptRULE_logicalAndExpr     = 37
	ManuscriptRULE_equalityExpr       = 38
	ManuscriptRULE_comparisonExpr     = 39
	ManuscriptRULE_additiveExpr       = 40
	ManuscriptRULE_multiplicativeExpr = 41
	ManuscriptRULE_unaryExpr          = 42
	ManuscriptRULE_awaitExpr          = 43
	ManuscriptRULE_postfixExpr        = 44
	ManuscriptRULE_primaryExpr        = 45
	ManuscriptRULE_fnExpr             = 46
	ManuscriptRULE_lambdaExpr         = 47
	ManuscriptRULE_tryBlockExpr       = 48
	ManuscriptRULE_matchExpr          = 49
	ManuscriptRULE_caseClause         = 50
	ManuscriptRULE_singleQuotedString = 51
	ManuscriptRULE_multiQuotedString  = 52
	ManuscriptRULE_stringPart         = 53
	ManuscriptRULE_interpolation      = 54
	ManuscriptRULE_literal            = 55
	ManuscriptRULE_stringLiteral      = 56
	ManuscriptRULE_numberLiteral      = 57
	ManuscriptRULE_booleanLiteral     = 58
	ManuscriptRULE_arrayLiteral       = 59
	ManuscriptRULE_objectLiteral      = 60
	ManuscriptRULE_objectField        = 61
	ManuscriptRULE_mapLiteral         = 62
	ManuscriptRULE_mapField           = 63
	ManuscriptRULE_setLiteral         = 64
	ManuscriptRULE_tupleLiteral       = 65
	ManuscriptRULE_importStr          = 66
	ManuscriptRULE_tupleType          = 67
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_programItem returns the _programItem rule contexts.
	Get_programItem() IProgramItemContext

	// Set_programItem sets the _programItem rule contexts.
	Set_programItem(IProgramItemContext)

	// GetItems returns the items rule context list.
	GetItems() []IProgramItemContext

	// SetItems sets the items rule context list.
	SetItems([]IProgramItemContext)

	// Getter signatures
	EOF() antlr.TerminalNode
	AllProgramItem() []IProgramItemContext
	ProgramItem(i int) IProgramItemContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_programItem IProgramItemContext
	items        []IProgramItemContext
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) Get_programItem() IProgramItemContext { return s._programItem }

func (s *ProgramContext) Set_programItem(v IProgramItemContext) { s._programItem = v }

func (s *ProgramContext) GetItems() []IProgramItemContext { return s.items }

func (s *ProgramContext) SetItems(v []IProgramItemContext) { s.items = v }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllProgramItem() []IProgramItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgramItemContext); ok {
			len++
		}
	}

	tst := make([]IProgramItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgramItemContext); ok {
			tst[i] = t.(IProgramItemContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) ProgramItem(i int) IProgramItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramItemContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291681398459269104) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
		{
			p.SetState(136)

			var _x = p.ProgramItem()

			localctx.(*ProgramContext)._programItem = _x
		}
		localctx.(*ProgramContext).items = append(localctx.(*ProgramContext).items, localctx.(*ProgramContext)._programItem)

		p.SetState(141)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(142)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProgramItemContext is an interface to support dynamic dispatch.
type IProgramItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportStmt() IImportStmtContext
	ExternStmt() IExternStmtContext
	ExportStmt() IExportStmtContext
	Stmt() IStmtContext
	TypeDecl() ITypeDeclContext
	IfaceDecl() IIfaceDeclContext
	FnDecl() IFnDeclContext
	MethodBlockDecl() IMethodBlockDeclContext

	// IsProgramItemContext differentiates from other interfaces.
	IsProgramItemContext()
}

type ProgramItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramItemContext() *ProgramItemContext {
	var p = new(ProgramItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_programItem
	return p
}

func InitEmptyProgramItemContext(p *ProgramItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_programItem
}

func (*ProgramItemContext) IsProgramItemContext() {}

func NewProgramItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramItemContext {
	var p = new(ProgramItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_programItem

	return p
}

func (s *ProgramItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramItemContext) ImportStmt() IImportStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStmtContext)
}

func (s *ProgramItemContext) ExternStmt() IExternStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternStmtContext)
}

func (s *ProgramItemContext) ExportStmt() IExportStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStmtContext)
}

func (s *ProgramItemContext) Stmt() IStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *ProgramItemContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ProgramItemContext) IfaceDecl() IIfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfaceDeclContext)
}

func (s *ProgramItemContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ProgramItemContext) MethodBlockDecl() IMethodBlockDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodBlockDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodBlockDeclContext)
}

func (s *ProgramItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgramItem(s)
	}
}

func (s *ProgramItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgramItem(s)
	}
}

func (s *ProgramItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgramItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ProgramItem() (localctx IProgramItemContext) {
	localctx = NewProgramItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_programItem)
	p.SetState(152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(144)
			p.ImportStmt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(145)
			p.ExternStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(146)
			p.ExportStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(147)
			p.Stmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(148)
			p.TypeDecl()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(149)
			p.IfaceDecl()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(150)
			p.FnDecl()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(151)
			p.MethodBlockDecl()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStmtContext is an interface to support dynamic dispatch.
type IImportStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTarget returns the target token.
	GetTarget() antlr.Token

	// SetTarget sets the target token.
	SetTarget(antlr.Token)

	// Get_importItem returns the _importItem rule contexts.
	Get_importItem() IImportItemContext

	// GetPath returns the path rule contexts.
	GetPath() IImportStrContext

	// Set_importItem sets the _importItem rule contexts.
	Set_importItem(IImportItemContext)

	// SetPath sets the path rule contexts.
	SetPath(IImportStrContext)

	// GetItems returns the items rule context list.
	GetItems() []IImportItemContext

	// SetItems sets the items rule context list.
	SetItems([]IImportItemContext)

	// Getter signatures
	IMPORT() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	ImportStr() IImportStrContext
	ID() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	AllImportItem() []IImportItemContext
	ImportItem(i int) IImportItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportStmtContext differentiates from other interfaces.
	IsImportStmtContext()
}

type ImportStmtContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_importItem IImportItemContext
	items       []IImportItemContext
	path        IImportStrContext
	target      antlr.Token
}

func NewEmptyImportStmtContext() *ImportStmtContext {
	var p = new(ImportStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStmt
	return p
}

func InitEmptyImportStmtContext(p *ImportStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStmt
}

func (*ImportStmtContext) IsImportStmtContext() {}

func NewImportStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStmtContext {
	var p = new(ImportStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importStmt

	return p
}

func (s *ImportStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStmtContext) GetTarget() antlr.Token { return s.target }

func (s *ImportStmtContext) SetTarget(v antlr.Token) { s.target = v }

func (s *ImportStmtContext) Get_importItem() IImportItemContext { return s._importItem }

func (s *ImportStmtContext) GetPath() IImportStrContext { return s.path }

func (s *ImportStmtContext) Set_importItem(v IImportItemContext) { s._importItem = v }

func (s *ImportStmtContext) SetPath(v IImportStrContext) { s.path = v }

func (s *ImportStmtContext) GetItems() []IImportItemContext { return s.items }

func (s *ImportStmtContext) SetItems(v []IImportItemContext) { s.items = v }

func (s *ImportStmtContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportStmtContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ImportStmtContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ImportStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *ImportStmtContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *ImportStmtContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ImportStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ImportStmtContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *ImportStmtContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *ImportStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ImportStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ImportStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportStmt(s)
	}
}

func (s *ImportStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportStmt(s)
	}
}

func (s *ImportStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportStmt() (localctx IImportStmtContext) {
	localctx = NewImportStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(154)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		{
			p.SetState(155)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(164)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptID {
			{
				p.SetState(156)

				var _x = p.ImportItem()

				localctx.(*ImportStmtContext)._importItem = _x
			}
			localctx.(*ImportStmtContext).items = append(localctx.(*ImportStmtContext).items, localctx.(*ImportStmtContext)._importItem)
			p.SetState(161)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptCOMMA {
				{
					p.SetState(157)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(158)

					var _x = p.ImportItem()

					localctx.(*ImportStmtContext)._importItem = _x
				}
				localctx.(*ImportStmtContext).items = append(localctx.(*ImportStmtContext).items, localctx.(*ImportStmtContext)._importItem)

				p.SetState(163)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(166)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(167)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(168)

			var _x = p.ImportStr()

			localctx.(*ImportStmtContext).path = _x
		}

	case ManuscriptID:
		{
			p.SetState(169)

			var _m = p.Match(ManuscriptID)

			localctx.(*ImportStmtContext).target = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(170)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(171)

			var _x = p.ImportStr()

			localctx.(*ImportStmtContext).path = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(175)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(174)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
	alias  antlr.Token
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) GetName() antlr.Token { return s.name }

func (s *ImportItemContext) GetAlias() antlr.Token { return s.alias }

func (s *ImportItemContext) SetName(v antlr.Token) { s.name = v }

func (s *ImportItemContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(177)

		var _m = p.Match(ManuscriptID)

		localctx.(*ImportItemContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(178)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(179)

			var _m = p.Match(ManuscriptID)

			localctx.(*ImportItemContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternStmtContext is an interface to support dynamic dispatch.
type IExternStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTarget returns the target token.
	GetTarget() antlr.Token

	// SetTarget sets the target token.
	SetTarget(antlr.Token)

	// Get_externItem returns the _externItem rule contexts.
	Get_externItem() IExternItemContext

	// GetPath returns the path rule contexts.
	GetPath() IImportStrContext

	// Set_externItem sets the _externItem rule contexts.
	Set_externItem(IExternItemContext)

	// SetPath sets the path rule contexts.
	SetPath(IImportStrContext)

	// GetItems returns the items rule context list.
	GetItems() []IExternItemContext

	// SetItems sets the items rule context list.
	SetItems([]IExternItemContext)

	// Getter signatures
	EXTERN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	ImportStr() IImportStrContext
	ID() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	AllExternItem() []IExternItemContext
	ExternItem(i int) IExternItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternStmtContext differentiates from other interfaces.
	IsExternStmtContext()
}

type ExternStmtContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_externItem IExternItemContext
	items       []IExternItemContext
	path        IImportStrContext
	target      antlr.Token
}

func NewEmptyExternStmtContext() *ExternStmtContext {
	var p = new(ExternStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externStmt
	return p
}

func InitEmptyExternStmtContext(p *ExternStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externStmt
}

func (*ExternStmtContext) IsExternStmtContext() {}

func NewExternStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternStmtContext {
	var p = new(ExternStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externStmt

	return p
}

func (s *ExternStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternStmtContext) GetTarget() antlr.Token { return s.target }

func (s *ExternStmtContext) SetTarget(v antlr.Token) { s.target = v }

func (s *ExternStmtContext) Get_externItem() IExternItemContext { return s._externItem }

func (s *ExternStmtContext) GetPath() IImportStrContext { return s.path }

func (s *ExternStmtContext) Set_externItem(v IExternItemContext) { s._externItem = v }

func (s *ExternStmtContext) SetPath(v IImportStrContext) { s.path = v }

func (s *ExternStmtContext) GetItems() []IExternItemContext { return s.items }

func (s *ExternStmtContext) SetItems(v []IExternItemContext) { s.items = v }

func (s *ExternStmtContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternStmtContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ExternStmtContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ExternStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *ExternStmtContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *ExternStmtContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ExternStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExternStmtContext) AllExternItem() []IExternItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternItemContext); ok {
			len++
		}
	}

	tst := make([]IExternItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternItemContext); ok {
			tst[i] = t.(IExternItemContext)
			i++
		}
	}

	return tst
}

func (s *ExternStmtContext) ExternItem(i int) IExternItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternItemContext)
}

func (s *ExternStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExternStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExternStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternStmt(s)
	}
}

func (s *ExternStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternStmt(s)
	}
}

func (s *ExternStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternStmt() (localctx IExternStmtContext) {
	localctx = NewExternStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_externStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(182)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		{
			p.SetState(183)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(192)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptID {
			{
				p.SetState(184)

				var _x = p.ExternItem()

				localctx.(*ExternStmtContext)._externItem = _x
			}
			localctx.(*ExternStmtContext).items = append(localctx.(*ExternStmtContext).items, localctx.(*ExternStmtContext)._externItem)
			p.SetState(189)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptCOMMA {
				{
					p.SetState(185)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(186)

					var _x = p.ExternItem()

					localctx.(*ExternStmtContext)._externItem = _x
				}
				localctx.(*ExternStmtContext).items = append(localctx.(*ExternStmtContext).items, localctx.(*ExternStmtContext)._externItem)

				p.SetState(191)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(194)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(195)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(196)

			var _x = p.ImportStr()

			localctx.(*ExternStmtContext).path = _x
		}

	case ManuscriptID:
		{
			p.SetState(197)

			var _m = p.Match(ManuscriptID)

			localctx.(*ExternStmtContext).target = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(198)
			p.Match(ManuscriptFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(199)

			var _x = p.ImportStr()

			localctx.(*ExternStmtContext).path = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(203)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(202)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternItemContext is an interface to support dynamic dispatch.
type IExternItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// GetAlias returns the alias token.
	GetAlias() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// SetAlias sets the alias token.
	SetAlias(antlr.Token)

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsExternItemContext differentiates from other interfaces.
	IsExternItemContext()
}

type ExternItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
	alias  antlr.Token
}

func NewEmptyExternItemContext() *ExternItemContext {
	var p = new(ExternItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externItem
	return p
}

func InitEmptyExternItemContext(p *ExternItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externItem
}

func (*ExternItemContext) IsExternItemContext() {}

func NewExternItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternItemContext {
	var p = new(ExternItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externItem

	return p
}

func (s *ExternItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternItemContext) GetName() antlr.Token { return s.name }

func (s *ExternItemContext) GetAlias() antlr.Token { return s.alias }

func (s *ExternItemContext) SetName(v antlr.Token) { s.name = v }

func (s *ExternItemContext) SetAlias(v antlr.Token) { s.alias = v }

func (s *ExternItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ExternItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ExternItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ExternItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternItem(s)
	}
}

func (s *ExternItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternItem(s)
	}
}

func (s *ExternItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternItem() (localctx IExternItemContext) {
	localctx = NewExternItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_externItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(205)

		var _m = p.Match(ManuscriptID)

		localctx.(*ExternItemContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(206)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(207)

			var _m = p.Match(ManuscriptID)

			localctx.(*ExternItemContext).alias = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStmtContext is an interface to support dynamic dispatch.
type IExportStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	FnDecl() IFnDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	IfaceDecl() IIfaceDeclContext
	SEMICOLON() antlr.TerminalNode

	// IsExportStmtContext differentiates from other interfaces.
	IsExportStmtContext()
}

type ExportStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStmtContext() *ExportStmtContext {
	var p = new(ExportStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportStmt
	return p
}

func InitEmptyExportStmtContext(p *ExportStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportStmt
}

func (*ExportStmtContext) IsExportStmtContext() {}

func NewExportStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStmtContext {
	var p = new(ExportStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportStmt

	return p
}

func (s *ExportStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStmtContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportStmtContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportStmtContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportStmtContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportStmtContext) IfaceDecl() IIfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfaceDeclContext)
}

func (s *ExportStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExportStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportStmt(s)
	}
}

func (s *ExportStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportStmt(s)
	}
}

func (s *ExportStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportStmt() (localctx IExportStmtContext) {
	localctx = NewExportStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_exportStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(210)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		{
			p.SetState(211)
			p.FnDecl()
		}

	case ManuscriptLET:
		{
			p.SetState(212)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		{
			p.SetState(213)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		{
			p.SetState(214)
			p.IfaceDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(218)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(217)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_letAssignment returns the _letAssignment rule contexts.
	Get_letAssignment() ILetAssignmentContext

	// Set_letAssignment sets the _letAssignment rule contexts.
	Set_letAssignment(ILetAssignmentContext)

	// GetAssignments returns the assignments rule context list.
	GetAssignments() []ILetAssignmentContext

	// SetAssignments sets the assignments rule context list.
	SetAssignments([]ILetAssignmentContext)

	// Getter signatures
	LET() antlr.TerminalNode
	AllLetAssignment() []ILetAssignmentContext
	LetAssignment(i int) ILetAssignmentContext
	SEMICOLON() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	_letAssignment ILetAssignmentContext
	assignments    []ILetAssignmentContext
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) Get_letAssignment() ILetAssignmentContext { return s._letAssignment }

func (s *LetDeclContext) Set_letAssignment(v ILetAssignmentContext) { s._letAssignment = v }

func (s *LetDeclContext) GetAssignments() []ILetAssignmentContext { return s.assignments }

func (s *LetDeclContext) SetAssignments(v []ILetAssignmentContext) { s.assignments = v }

func (s *LetDeclContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclContext) AllLetAssignment() []ILetAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetAssignmentContext); ok {
			len++
		}
	}

	tst := make([]ILetAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetAssignmentContext); ok {
			tst[i] = t.(ILetAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *LetDeclContext) LetAssignment(i int) ILetAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetAssignmentContext)
}

func (s *LetDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *LetDeclContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDecl(s)
	}
}

func (s *LetDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDecl(s)
	}
}

func (s *LetDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_letDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(220)
		p.Match(ManuscriptLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(221)

		var _x = p.LetAssignment()

		localctx.(*LetDeclContext)._letAssignment = _x
	}
	localctx.(*LetDeclContext).assignments = append(localctx.(*LetDeclContext).assignments, localctx.(*LetDeclContext)._letAssignment)
	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptCOMMA {
		{
			p.SetState(222)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(223)

			var _x = p.LetAssignment()

			localctx.(*LetDeclContext)._letAssignment = _x
		}
		localctx.(*LetDeclContext).assignments = append(localctx.(*LetDeclContext).assignments, localctx.(*LetDeclContext)._letAssignment)

		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	p.SetState(230)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(229)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetAssignmentContext is an interface to support dynamic dispatch.
type ILetAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() ILetPatternContext

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(ILetPatternContext)

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	LetPattern() ILetPatternContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetAssignmentContext differentiates from other interfaces.
	IsLetAssignmentContext()
}

type LetAssignmentContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern ILetPatternContext
	value   IExprContext
}

func NewEmptyLetAssignmentContext() *LetAssignmentContext {
	var p = new(LetAssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letAssignment
	return p
}

func InitEmptyLetAssignmentContext(p *LetAssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letAssignment
}

func (*LetAssignmentContext) IsLetAssignmentContext() {}

func NewLetAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetAssignmentContext {
	var p = new(LetAssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letAssignment

	return p
}

func (s *LetAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *LetAssignmentContext) GetPattern() ILetPatternContext { return s.pattern }

func (s *LetAssignmentContext) GetValue() IExprContext { return s.value }

func (s *LetAssignmentContext) SetPattern(v ILetPatternContext) { s.pattern = v }

func (s *LetAssignmentContext) SetValue(v IExprContext) { s.value = v }

func (s *LetAssignmentContext) LetPattern() ILetPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetPatternContext)
}

func (s *LetAssignmentContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetAssignmentContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetAssignment(s)
	}
}

func (s *LetAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetAssignment(s)
	}
}

func (s *LetAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetAssignment() (localctx ILetAssignmentContext) {
	localctx = NewLetAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_letAssignment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)

		var _x = p.LetPattern()

		localctx.(*LetAssignmentContext).pattern = _x
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(233)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(234)

			var _x = p.Expr()

			localctx.(*LetAssignmentContext).value = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetPatternContext is an interface to support dynamic dispatch.
type ILetPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSimple returns the simple token.
	GetSimple() antlr.Token

	// SetSimple sets the simple token.
	SetSimple(antlr.Token)

	// GetArray returns the array rule contexts.
	GetArray() IArrayPattnContext

	// GetObject returns the object rule contexts.
	GetObject() IObjectPattnContext

	// SetArray sets the array rule contexts.
	SetArray(IArrayPattnContext)

	// SetObject sets the object rule contexts.
	SetObject(IObjectPattnContext)

	// Getter signatures
	ID() antlr.TerminalNode
	ArrayPattn() IArrayPattnContext
	ObjectPattn() IObjectPattnContext

	// IsLetPatternContext differentiates from other interfaces.
	IsLetPatternContext()
}

type LetPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	simple antlr.Token
	array  IArrayPattnContext
	object IObjectPattnContext
}

func NewEmptyLetPatternContext() *LetPatternContext {
	var p = new(LetPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letPattern
	return p
}

func InitEmptyLetPatternContext(p *LetPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letPattern
}

func (*LetPatternContext) IsLetPatternContext() {}

func NewLetPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetPatternContext {
	var p = new(LetPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letPattern

	return p
}

func (s *LetPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *LetPatternContext) GetSimple() antlr.Token { return s.simple }

func (s *LetPatternContext) SetSimple(v antlr.Token) { s.simple = v }

func (s *LetPatternContext) GetArray() IArrayPattnContext { return s.array }

func (s *LetPatternContext) GetObject() IObjectPattnContext { return s.object }

func (s *LetPatternContext) SetArray(v IArrayPattnContext) { s.array = v }

func (s *LetPatternContext) SetObject(v IObjectPattnContext) { s.object = v }

func (s *LetPatternContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LetPatternContext) ArrayPattn() IArrayPattnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayPattnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayPattnContext)
}

func (s *LetPatternContext) ObjectPattn() IObjectPattnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectPattnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectPattnContext)
}

func (s *LetPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetPattern(s)
	}
}

func (s *LetPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetPattern(s)
	}
}

func (s *LetPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetPattern() (localctx ILetPatternContext) {
	localctx = NewLetPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_letPattern)
	p.SetState(240)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(237)

			var _m = p.Match(ManuscriptID)

			localctx.(*LetPatternContext).simple = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(238)

			var _x = p.ArrayPattn()

			localctx.(*LetPatternContext).array = _x
		}

	case ManuscriptLBRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(239)

			var _x = p.ObjectPattn()

			localctx.(*LetPatternContext).object = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayPattnContext is an interface to support dynamic dispatch.
type IArrayPattnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetNames returns the names token list.
	GetNames() []antlr.Token

	// SetNames sets the names token list.
	SetNames([]antlr.Token)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayPattnContext differentiates from other interfaces.
	IsArrayPattnContext()
}

type ArrayPattnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_ID    antlr.Token
	names  []antlr.Token
}

func NewEmptyArrayPattnContext() *ArrayPattnContext {
	var p = new(ArrayPattnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayPattn
	return p
}

func InitEmptyArrayPattnContext(p *ArrayPattnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayPattn
}

func (*ArrayPattnContext) IsArrayPattnContext() {}

func NewArrayPattnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayPattnContext {
	var p = new(ArrayPattnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayPattn

	return p
}

func (s *ArrayPattnContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayPattnContext) Get_ID() antlr.Token { return s._ID }

func (s *ArrayPattnContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ArrayPattnContext) GetNames() []antlr.Token { return s.names }

func (s *ArrayPattnContext) SetNames(v []antlr.Token) { s.names = v }

func (s *ArrayPattnContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayPattnContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayPattnContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ArrayPattnContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ArrayPattnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ArrayPattnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ArrayPattnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayPattnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayPattnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayPattn(s)
	}
}

func (s *ArrayPattnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayPattn(s)
	}
}

func (s *ArrayPattnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayPattn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayPattn() (localctx IArrayPattnContext) {
	localctx = NewArrayPattnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_arrayPattn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(242)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(251)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(243)

			var _m = p.Match(ManuscriptID)

			localctx.(*ArrayPattnContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ArrayPattnContext).names = append(localctx.(*ArrayPattnContext).names, localctx.(*ArrayPattnContext)._ID)
		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(244)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(245)

				var _m = p.Match(ManuscriptID)

				localctx.(*ArrayPattnContext)._ID = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ArrayPattnContext).names = append(localctx.(*ArrayPattnContext).names, localctx.(*ArrayPattnContext)._ID)

			p.SetState(250)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(253)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectPattnContext is an interface to support dynamic dispatch.
type IObjectPattnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID returns the _ID token.
	Get_ID() antlr.Token

	// Set_ID sets the _ID token.
	Set_ID(antlr.Token)

	// GetNames returns the names token list.
	GetNames() []antlr.Token

	// SetNames sets the names token list.
	SetNames([]antlr.Token)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectPattnContext differentiates from other interfaces.
	IsObjectPattnContext()
}

type ObjectPattnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_ID    antlr.Token
	names  []antlr.Token
}

func NewEmptyObjectPattnContext() *ObjectPattnContext {
	var p = new(ObjectPattnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectPattn
	return p
}

func InitEmptyObjectPattnContext(p *ObjectPattnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectPattn
}

func (*ObjectPattnContext) IsObjectPattnContext() {}

func NewObjectPattnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectPattnContext {
	var p = new(ObjectPattnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectPattn

	return p
}

func (s *ObjectPattnContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectPattnContext) Get_ID() antlr.Token { return s._ID }

func (s *ObjectPattnContext) Set_ID(v antlr.Token) { s._ID = v }

func (s *ObjectPattnContext) GetNames() []antlr.Token { return s.names }

func (s *ObjectPattnContext) SetNames(v []antlr.Token) { s.names = v }

func (s *ObjectPattnContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectPattnContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectPattnContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ObjectPattnContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ObjectPattnContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectPattnContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectPattnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPattnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectPattnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectPattn(s)
	}
}

func (s *ObjectPattnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectPattn(s)
	}
}

func (s *ObjectPattnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectPattn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectPattn() (localctx IObjectPattnContext) {
	localctx = NewObjectPattnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_objectPattn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(255)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(256)

			var _m = p.Match(ManuscriptID)

			localctx.(*ObjectPattnContext)._ID = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ObjectPattnContext).names = append(localctx.(*ObjectPattnContext).names, localctx.(*ObjectPattnContext)._ID)
		p.SetState(261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(257)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(258)

				var _m = p.Match(ManuscriptID)

				localctx.(*ObjectPattnContext)._ID = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			localctx.(*ObjectPattnContext).names = append(localctx.(*ObjectPattnContext).names, localctx.(*ObjectPattnContext)._ID)

			p.SetState(263)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(266)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ID() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	COLON() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	name       antlr.Token
	params     IParametersContext
	returnType ITypeAnnotationContext
	block      ICodeBlockContext
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) GetName() antlr.Token { return s.name }

func (s *FnDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *FnDeclContext) GetParams() IParametersContext { return s.params }

func (s *FnDeclContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *FnDeclContext) GetBlock() ICodeBlockContext { return s.block }

func (s *FnDeclContext) SetParams(v IParametersContext) { s.params = v }

func (s *FnDeclContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *FnDeclContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *FnDeclContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnDeclContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnDeclContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *FnDeclContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnDeclContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_fnDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(268)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(269)

		var _m = p.Match(ManuscriptID)

		localctx.(*FnDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(270)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(271)

			var _x = p.Parameters()

			localctx.(*FnDeclContext).params = _x
		}

	}
	{
		p.SetState(274)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(275)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(276)

			var _x = p.TypeAnnotation()

			localctx.(*FnDeclContext).returnType = _x
		}

	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(279)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(282)

		var _x = p.CodeBlock()

		localctx.(*FnDeclContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_parameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Param()
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptCOMMA {
		{
			p.SetState(285)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(286)
			p.Param()
		}

		p.SetState(291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label token.
	GetLabel() antlr.Token

	// GetName returns the name token.
	GetName() antlr.Token

	// SetLabel sets the label token.
	SetLabel(antlr.Token)

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeAnnotationContext

	// GetDefaultValue returns the defaultValue rule contexts.
	GetDefaultValue() IExprContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeAnnotationContext)

	// SetDefaultValue sets the defaultValue rule contexts.
	SetDefaultValue(IExprContext)

	// Getter signatures
	COLON() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	label        antlr.Token
	name         antlr.Token
	type_        ITypeAnnotationContext
	defaultValue IExprContext
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) GetLabel() antlr.Token { return s.label }

func (s *ParamContext) GetName() antlr.Token { return s.name }

func (s *ParamContext) SetLabel(v antlr.Token) { s.label = v }

func (s *ParamContext) SetName(v antlr.Token) { s.name = v }

func (s *ParamContext) GetType_() ITypeAnnotationContext { return s.type_ }

func (s *ParamContext) GetDefaultValue() IExprContext { return s.defaultValue }

func (s *ParamContext) SetType_(v ITypeAnnotationContext) { s.type_ = v }

func (s *ParamContext) SetDefaultValue(v IExprContext) { s.defaultValue = v }

func (s *ParamContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ParamContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ParamContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(293)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(292)

			var _m = p.Match(ManuscriptID)

			localctx.(*ParamContext).label = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(295)

		var _m = p.Match(ManuscriptID)

		localctx.(*ParamContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(296)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(297)

		var _x = p.TypeAnnotation()

		localctx.(*ParamContext).type_ = _x
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(298)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(299)

			var _x = p.Expr()

			localctx.(*ParamContext).defaultValue = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Get_typeAnnotation returns the _typeAnnotation rule contexts.
	Get_typeAnnotation() ITypeAnnotationContext

	// Get_fieldDecl returns the _fieldDecl rule contexts.
	Get_fieldDecl() IFieldDeclContext

	// Set_typeAnnotation sets the _typeAnnotation rule contexts.
	Set_typeAnnotation(ITypeAnnotationContext)

	// Set_fieldDecl sets the _fieldDecl rule contexts.
	Set_fieldDecl(IFieldDeclContext)

	// GetBaseTypes returns the baseTypes rule context list.
	GetBaseTypes() []ITypeAnnotationContext

	// GetFields returns the fields rule context list.
	GetFields() []IFieldDeclContext

	// SetBaseTypes sets the baseTypes rule context list.
	SetBaseTypes([]ITypeAnnotationContext)

	// SetFields sets the fields rule context list.
	SetFields([]IFieldDeclContext)

	// Getter signatures
	TYPE() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	name            antlr.Token
	_typeAnnotation ITypeAnnotationContext
	baseTypes       []ITypeAnnotationContext
	_fieldDecl      IFieldDeclContext
	fields          []IFieldDeclContext
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) GetName() antlr.Token { return s.name }

func (s *TypeDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *TypeDeclContext) Get_typeAnnotation() ITypeAnnotationContext { return s._typeAnnotation }

func (s *TypeDeclContext) Get_fieldDecl() IFieldDeclContext { return s._fieldDecl }

func (s *TypeDeclContext) Set_typeAnnotation(v ITypeAnnotationContext) { s._typeAnnotation = v }

func (s *TypeDeclContext) Set_fieldDecl(v IFieldDeclContext) { s._fieldDecl = v }

func (s *TypeDeclContext) GetBaseTypes() []ITypeAnnotationContext { return s.baseTypes }

func (s *TypeDeclContext) GetFields() []IFieldDeclContext { return s.fields }

func (s *TypeDeclContext) SetBaseTypes(v []ITypeAnnotationContext) { s.baseTypes = v }

func (s *TypeDeclContext) SetFields(v []IFieldDeclContext) { s.fields = v }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDeclContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeDeclContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDeclContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDeclContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDeclContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_typeDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(303)

		var _m = p.Match(ManuscriptID)

		localctx.(*TypeDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(304)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)

			var _x = p.TypeAnnotation()

			localctx.(*TypeDeclContext)._typeAnnotation = _x
		}
		localctx.(*TypeDeclContext).baseTypes = append(localctx.(*TypeDeclContext).baseTypes, localctx.(*TypeDeclContext)._typeAnnotation)
		p.SetState(310)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(306)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(307)

				var _x = p.TypeAnnotation()

				localctx.(*TypeDeclContext)._typeAnnotation = _x
			}
			localctx.(*TypeDeclContext).baseTypes = append(localctx.(*TypeDeclContext).baseTypes, localctx.(*TypeDeclContext)._typeAnnotation)

			p.SetState(312)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(315)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(319)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptID {
		{
			p.SetState(316)

			var _x = p.FieldDecl()

			localctx.(*TypeDeclContext)._fieldDecl = _x
		}
		localctx.(*TypeDeclContext).fields = append(localctx.(*TypeDeclContext).fields, localctx.(*TypeDeclContext)._fieldDecl)

		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(322)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetType_ returns the type_ rule contexts.
	GetType_() ITypeAnnotationContext

	// SetType_ sets the type_ rule contexts.
	SetType_(ITypeAnnotationContext)

	// Getter signatures
	COLON() antlr.TerminalNode
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
	type_  ITypeAnnotationContext
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) GetName() antlr.Token { return s.name }

func (s *FieldDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *FieldDeclContext) GetType_() ITypeAnnotationContext { return s.type_ }

func (s *FieldDeclContext) SetType_(v ITypeAnnotationContext) { s.type_ = v }

func (s *FieldDeclContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *FieldDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)

		var _m = p.Match(ManuscriptID)

		localctx.(*FieldDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(325)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(328)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(329)

		var _x = p.TypeAnnotation()

		localctx.(*FieldDeclContext).type_ = _x
	}
	p.SetState(331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(330)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfaceDeclContext is an interface to support dynamic dispatch.
type IIfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Get_typeAnnotation returns the _typeAnnotation rule contexts.
	Get_typeAnnotation() ITypeAnnotationContext

	// Get_methodDecl returns the _methodDecl rule contexts.
	Get_methodDecl() IMethodDeclContext

	// Set_typeAnnotation sets the _typeAnnotation rule contexts.
	Set_typeAnnotation(ITypeAnnotationContext)

	// Set_methodDecl sets the _methodDecl rule contexts.
	Set_methodDecl(IMethodDeclContext)

	// GetBaseIfaces returns the baseIfaces rule context list.
	GetBaseIfaces() []ITypeAnnotationContext

	// GetMethods returns the methods rule context list.
	GetMethods() []IMethodDeclContext

	// SetBaseIfaces sets the baseIfaces rule context list.
	SetBaseIfaces([]ITypeAnnotationContext)

	// SetMethods sets the methods rule context list.
	SetMethods([]IMethodDeclContext)

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllMethodDecl() []IMethodDeclContext
	MethodDecl(i int) IMethodDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIfaceDeclContext differentiates from other interfaces.
	IsIfaceDeclContext()
}

type IfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	name            antlr.Token
	_typeAnnotation ITypeAnnotationContext
	baseIfaces      []ITypeAnnotationContext
	_methodDecl     IMethodDeclContext
	methods         []IMethodDeclContext
}

func NewEmptyIfaceDeclContext() *IfaceDeclContext {
	var p = new(IfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifaceDecl
	return p
}

func InitEmptyIfaceDeclContext(p *IfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifaceDecl
}

func (*IfaceDeclContext) IsIfaceDeclContext() {}

func NewIfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfaceDeclContext {
	var p = new(IfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifaceDecl

	return p
}

func (s *IfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *IfaceDeclContext) GetName() antlr.Token { return s.name }

func (s *IfaceDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *IfaceDeclContext) Get_typeAnnotation() ITypeAnnotationContext { return s._typeAnnotation }

func (s *IfaceDeclContext) Get_methodDecl() IMethodDeclContext { return s._methodDecl }

func (s *IfaceDeclContext) Set_typeAnnotation(v ITypeAnnotationContext) { s._typeAnnotation = v }

func (s *IfaceDeclContext) Set_methodDecl(v IMethodDeclContext) { s._methodDecl = v }

func (s *IfaceDeclContext) GetBaseIfaces() []ITypeAnnotationContext { return s.baseIfaces }

func (s *IfaceDeclContext) GetMethods() []IMethodDeclContext { return s.methods }

func (s *IfaceDeclContext) SetBaseIfaces(v []ITypeAnnotationContext) { s.baseIfaces = v }

func (s *IfaceDeclContext) SetMethods(v []IMethodDeclContext) { s.methods = v }

func (s *IfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *IfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *IfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *IfaceDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *IfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *IfaceDeclContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *IfaceDeclContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *IfaceDeclContext) AllMethodDecl() []IMethodDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodDeclContext); ok {
			len++
		}
	}

	tst := make([]IMethodDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodDeclContext); ok {
			tst[i] = t.(IMethodDeclContext)
			i++
		}
	}

	return tst
}

func (s *IfaceDeclContext) MethodDecl(i int) IMethodDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodDeclContext)
}

func (s *IfaceDeclContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *IfaceDeclContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *IfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfaceDecl(s)
	}
}

func (s *IfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfaceDecl(s)
	}
}

func (s *IfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfaceDecl() (localctx IIfaceDeclContext) {
	localctx = NewIfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_ifaceDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(334)

		var _m = p.Match(ManuscriptID)

		localctx.(*IfaceDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(335)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)

			var _x = p.TypeAnnotation()

			localctx.(*IfaceDeclContext)._typeAnnotation = _x
		}
		localctx.(*IfaceDeclContext).baseIfaces = append(localctx.(*IfaceDeclContext).baseIfaces, localctx.(*IfaceDeclContext)._typeAnnotation)
		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(337)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(338)

				var _x = p.TypeAnnotation()

				localctx.(*IfaceDeclContext)._typeAnnotation = _x
			}
			localctx.(*IfaceDeclContext).baseIfaces = append(localctx.(*IfaceDeclContext).baseIfaces, localctx.(*IfaceDeclContext)._typeAnnotation)

			p.SetState(343)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(346)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptFN {
		{
			p.SetState(347)

			var _x = p.MethodDecl()

			localctx.(*IfaceDeclContext)._methodDecl = _x
		}
		localctx.(*IfaceDeclContext).methods = append(localctx.(*IfaceDeclContext).methods, localctx.(*IfaceDeclContext)._methodDecl)

		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(353)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodDeclContext is an interface to support dynamic dispatch.
type IMethodDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ID() antlr.TerminalNode
	COLON() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsMethodDeclContext differentiates from other interfaces.
	IsMethodDeclContext()
}

type MethodDeclContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	name       antlr.Token
	params     IParametersContext
	returnType ITypeAnnotationContext
}

func NewEmptyMethodDeclContext() *MethodDeclContext {
	var p = new(MethodDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodDecl
	return p
}

func InitEmptyMethodDeclContext(p *MethodDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodDecl
}

func (*MethodDeclContext) IsMethodDeclContext() {}

func NewMethodDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclContext {
	var p = new(MethodDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodDecl

	return p
}

func (s *MethodDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclContext) GetName() antlr.Token { return s.name }

func (s *MethodDeclContext) SetName(v antlr.Token) { s.name = v }

func (s *MethodDeclContext) GetParams() IParametersContext { return s.params }

func (s *MethodDeclContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *MethodDeclContext) SetParams(v IParametersContext) { s.params = v }

func (s *MethodDeclContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *MethodDeclContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *MethodDeclContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *MethodDeclContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *MethodDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *MethodDeclContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MethodDeclContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *MethodDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *MethodDeclContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *MethodDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *MethodDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodDecl(s)
	}
}

func (s *MethodDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodDecl(s)
	}
}

func (s *MethodDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodDecl() (localctx IMethodDeclContext) {
	localctx = NewMethodDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_methodDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(355)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)

		var _m = p.Match(ManuscriptID)

		localctx.(*MethodDeclContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(357)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(358)

			var _x = p.Parameters()

			localctx.(*MethodDeclContext).params = _x
		}

	}
	{
		p.SetState(361)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(362)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(363)

			var _x = p.TypeAnnotation()

			localctx.(*MethodDeclContext).returnType = _x
		}

	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(366)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(370)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(369)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodBlockDeclContext is an interface to support dynamic dispatch.
type IMethodBlockDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIfaceName returns the ifaceName rule contexts.
	GetIfaceName() ITypeAnnotationContext

	// GetTypeName returns the typeName rule contexts.
	GetTypeName() ITypeAnnotationContext

	// Get_methodImpl returns the _methodImpl rule contexts.
	Get_methodImpl() IMethodImplContext

	// SetIfaceName sets the ifaceName rule contexts.
	SetIfaceName(ITypeAnnotationContext)

	// SetTypeName sets the typeName rule contexts.
	SetTypeName(ITypeAnnotationContext)

	// Set_methodImpl sets the _methodImpl rule contexts.
	Set_methodImpl(IMethodImplContext)

	// GetImpls returns the impls rule context list.
	GetImpls() []IMethodImplContext

	// SetImpls sets the impls rule context list.
	SetImpls([]IMethodImplContext)

	// Getter signatures
	METHODS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	FOR() antlr.TerminalNode
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext

	// IsMethodBlockDeclContext differentiates from other interfaces.
	IsMethodBlockDeclContext()
}

type MethodBlockDeclContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	ifaceName   ITypeAnnotationContext
	typeName    ITypeAnnotationContext
	_methodImpl IMethodImplContext
	impls       []IMethodImplContext
}

func NewEmptyMethodBlockDeclContext() *MethodBlockDeclContext {
	var p = new(MethodBlockDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodBlockDecl
	return p
}

func InitEmptyMethodBlockDeclContext(p *MethodBlockDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodBlockDecl
}

func (*MethodBlockDeclContext) IsMethodBlockDeclContext() {}

func NewMethodBlockDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBlockDeclContext {
	var p = new(MethodBlockDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodBlockDecl

	return p
}

func (s *MethodBlockDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBlockDeclContext) GetIfaceName() ITypeAnnotationContext { return s.ifaceName }

func (s *MethodBlockDeclContext) GetTypeName() ITypeAnnotationContext { return s.typeName }

func (s *MethodBlockDeclContext) Get_methodImpl() IMethodImplContext { return s._methodImpl }

func (s *MethodBlockDeclContext) SetIfaceName(v ITypeAnnotationContext) { s.ifaceName = v }

func (s *MethodBlockDeclContext) SetTypeName(v ITypeAnnotationContext) { s.typeName = v }

func (s *MethodBlockDeclContext) Set_methodImpl(v IMethodImplContext) { s._methodImpl = v }

func (s *MethodBlockDeclContext) GetImpls() []IMethodImplContext { return s.impls }

func (s *MethodBlockDeclContext) SetImpls(v []IMethodImplContext) { s.impls = v }

func (s *MethodBlockDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodBlockDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodBlockDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodBlockDeclContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *MethodBlockDeclContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *MethodBlockDeclContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *MethodBlockDeclContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodBlockDeclContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodBlockDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBlockDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBlockDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodBlockDecl(s)
	}
}

func (s *MethodBlockDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodBlockDecl(s)
	}
}

func (s *MethodBlockDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodBlockDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodBlockDecl() (localctx IMethodBlockDeclContext) {
	localctx = NewMethodBlockDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_methodBlockDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(372)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(376)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(373)

			var _x = p.TypeAnnotation()

			localctx.(*MethodBlockDeclContext).ifaceName = _x
		}
		{
			p.SetState(374)
			p.Match(ManuscriptFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(378)

		var _x = p.TypeAnnotation()

		localctx.(*MethodBlockDeclContext).typeName = _x
	}
	{
		p.SetState(379)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptFN {
		{
			p.SetState(380)

			var _x = p.MethodImpl()

			localctx.(*MethodBlockDeclContext)._methodImpl = _x
		}
		localctx.(*MethodBlockDeclContext).impls = append(localctx.(*MethodBlockDeclContext).impls, localctx.(*MethodBlockDeclContext)._methodImpl)

		p.SetState(385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(386)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ID() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	COLON() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	name       antlr.Token
	params     IParametersContext
	returnType ITypeAnnotationContext
	block      ICodeBlockContext
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) GetName() antlr.Token { return s.name }

func (s *MethodImplContext) SetName(v antlr.Token) { s.name = v }

func (s *MethodImplContext) GetParams() IParametersContext { return s.params }

func (s *MethodImplContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *MethodImplContext) GetBlock() ICodeBlockContext { return s.block }

func (s *MethodImplContext) SetParams(v IParametersContext) { s.params = v }

func (s *MethodImplContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *MethodImplContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *MethodImplContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *MethodImplContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *MethodImplContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *MethodImplContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MethodImplContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *MethodImplContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *MethodImplContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_methodImpl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(388)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(389)

		var _m = p.Match(ManuscriptID)

		localctx.(*MethodImplContext).name = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(391)

			var _x = p.Parameters()

			localctx.(*MethodImplContext).params = _x
		}

	}
	{
		p.SetState(394)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(395)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(396)

			var _x = p.TypeAnnotation()

			localctx.(*MethodImplContext).returnType = _x
		}

	}
	p.SetState(400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(399)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(402)

		var _x = p.CodeBlock()

		localctx.(*MethodImplContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBase returns the base rule contexts.
	GetBase() IBaseTypeAnnotationContext

	// GetMapValueType returns the mapValueType rule contexts.
	GetMapValueType() ITypeAnnotationContext

	// SetBase sets the base rule contexts.
	SetBase(IBaseTypeAnnotationContext)

	// SetMapValueType sets the mapValueType rule contexts.
	SetMapValueType(ITypeAnnotationContext)

	// Getter signatures
	BaseTypeAnnotation() IBaseTypeAnnotationContext
	AllLSQBR() []antlr.TerminalNode
	LSQBR(i int) antlr.TerminalNode
	AllRSQBR() []antlr.TerminalNode
	RSQBR(i int) antlr.TerminalNode
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext

	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	base         IBaseTypeAnnotationContext
	mapValueType ITypeAnnotationContext
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) GetBase() IBaseTypeAnnotationContext { return s.base }

func (s *TypeAnnotationContext) GetMapValueType() ITypeAnnotationContext { return s.mapValueType }

func (s *TypeAnnotationContext) SetBase(v IBaseTypeAnnotationContext) { s.base = v }

func (s *TypeAnnotationContext) SetMapValueType(v ITypeAnnotationContext) { s.mapValueType = v }

func (s *TypeAnnotationContext) BaseTypeAnnotation() IBaseTypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeAnnotationContext)
}

func (s *TypeAnnotationContext) AllLSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLSQBR)
}

func (s *TypeAnnotationContext) LSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, i)
}

func (s *TypeAnnotationContext) AllRSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRSQBR)
}

func (s *TypeAnnotationContext) RSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, i)
}

func (s *TypeAnnotationContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOLON)
}

func (s *TypeAnnotationContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, i)
}

func (s *TypeAnnotationContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLT)
}

func (s *TypeAnnotationContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, i)
}

func (s *TypeAnnotationContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptGT)
}

func (s *TypeAnnotationContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, i)
}

func (s *TypeAnnotationContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeAnnotationContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnotation(s)
	}
}

func (s *TypeAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_typeAnnotation)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)

		var _x = p.BaseTypeAnnotation()

		localctx.(*TypeAnnotationContext).base = _x
	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(414)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(405)
					p.Match(ManuscriptLSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(406)
					p.Match(ManuscriptRSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				{
					p.SetState(407)
					p.Match(ManuscriptLSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(408)
					p.Match(ManuscriptCOLON)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(409)

					var _x = p.TypeAnnotation()

					localctx.(*TypeAnnotationContext).mapValueType = _x
				}
				{
					p.SetState(410)
					p.Match(ManuscriptRSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				{
					p.SetState(412)
					p.Match(ManuscriptLT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(413)
					p.Match(ManuscriptGT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeAnnotationContext is an interface to support dynamic dispatch.
type IBaseTypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSimpleType returns the simpleType token.
	GetSimpleType() antlr.Token

	// SetSimpleType sets the simpleType token.
	SetSimpleType(antlr.Token)

	// GetTuple returns the tuple rule contexts.
	GetTuple() ITupleTypeContext

	// GetFunction returns the function rule contexts.
	GetFunction() IFunctionTypeContext

	// SetTuple sets the tuple rule contexts.
	SetTuple(ITupleTypeContext)

	// SetFunction sets the function rule contexts.
	SetFunction(IFunctionTypeContext)

	// Getter signatures
	ID() antlr.TerminalNode
	TupleType() ITupleTypeContext
	FunctionType() IFunctionTypeContext

	// IsBaseTypeAnnotationContext differentiates from other interfaces.
	IsBaseTypeAnnotationContext()
}

type BaseTypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	simpleType antlr.Token
	tuple      ITupleTypeContext
	function   IFunctionTypeContext
}

func NewEmptyBaseTypeAnnotationContext() *BaseTypeAnnotationContext {
	var p = new(BaseTypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_baseTypeAnnotation
	return p
}

func InitEmptyBaseTypeAnnotationContext(p *BaseTypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_baseTypeAnnotation
}

func (*BaseTypeAnnotationContext) IsBaseTypeAnnotationContext() {}

func NewBaseTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeAnnotationContext {
	var p = new(BaseTypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_baseTypeAnnotation

	return p
}

func (s *BaseTypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeAnnotationContext) GetSimpleType() antlr.Token { return s.simpleType }

func (s *BaseTypeAnnotationContext) SetSimpleType(v antlr.Token) { s.simpleType = v }

func (s *BaseTypeAnnotationContext) GetTuple() ITupleTypeContext { return s.tuple }

func (s *BaseTypeAnnotationContext) GetFunction() IFunctionTypeContext { return s.function }

func (s *BaseTypeAnnotationContext) SetTuple(v ITupleTypeContext) { s.tuple = v }

func (s *BaseTypeAnnotationContext) SetFunction(v IFunctionTypeContext) { s.function = v }

func (s *BaseTypeAnnotationContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *BaseTypeAnnotationContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *BaseTypeAnnotationContext) FunctionType() IFunctionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTypeContext)
}

func (s *BaseTypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeAnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBaseTypeAnnotation(s)
	}
}

func (s *BaseTypeAnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBaseTypeAnnotation(s)
	}
}

func (s *BaseTypeAnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBaseTypeAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BaseTypeAnnotation() (localctx IBaseTypeAnnotationContext) {
	localctx = NewBaseTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_baseTypeAnnotation)
	p.SetState(422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(419)

			var _m = p.Match(ManuscriptID)

			localctx.(*BaseTypeAnnotationContext).simpleType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(420)

			var _x = p.TupleType()

			localctx.(*BaseTypeAnnotationContext).tuple = _x
		}

	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(421)

			var _x = p.FunctionType()

			localctx.(*BaseTypeAnnotationContext).function = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTypeContext is an interface to support dynamic dispatch.
type IFunctionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_typeAnnotation returns the _typeAnnotation rule contexts.
	Get_typeAnnotation() ITypeAnnotationContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// Set_typeAnnotation sets the _typeAnnotation rule contexts.
	Set_typeAnnotation(ITypeAnnotationContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// GetParamTypes returns the paramTypes rule context list.
	GetParamTypes() []ITypeAnnotationContext

	// SetParamTypes sets the paramTypes rule context list.
	SetParamTypes([]ITypeAnnotationContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionTypeContext differentiates from other interfaces.
	IsFunctionTypeContext()
}

type FunctionTypeContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_typeAnnotation ITypeAnnotationContext
	paramTypes      []ITypeAnnotationContext
	returnType      ITypeAnnotationContext
}

func NewEmptyFunctionTypeContext() *FunctionTypeContext {
	var p = new(FunctionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_functionType
	return p
}

func InitEmptyFunctionTypeContext(p *FunctionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_functionType
}

func (*FunctionTypeContext) IsFunctionTypeContext() {}

func NewFunctionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTypeContext {
	var p = new(FunctionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_functionType

	return p
}

func (s *FunctionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTypeContext) Get_typeAnnotation() ITypeAnnotationContext { return s._typeAnnotation }

func (s *FunctionTypeContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *FunctionTypeContext) Set_typeAnnotation(v ITypeAnnotationContext) { s._typeAnnotation = v }

func (s *FunctionTypeContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *FunctionTypeContext) GetParamTypes() []ITypeAnnotationContext { return s.paramTypes }

func (s *FunctionTypeContext) SetParamTypes(v []ITypeAnnotationContext) { s.paramTypes = v }

func (s *FunctionTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FunctionTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FunctionTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FunctionTypeContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *FunctionTypeContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FunctionTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *FunctionTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *FunctionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFunctionType(s)
	}
}

func (s *FunctionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFunctionType(s)
	}
}

func (s *FunctionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFunctionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FunctionType() (localctx IFunctionTypeContext) {
	localctx = NewFunctionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_functionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(425)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptFN || _la == ManuscriptLPAREN || _la == ManuscriptID {
		{
			p.SetState(426)

			var _x = p.TypeAnnotation()

			localctx.(*FunctionTypeContext)._typeAnnotation = _x
		}
		localctx.(*FunctionTypeContext).paramTypes = append(localctx.(*FunctionTypeContext).paramTypes, localctx.(*FunctionTypeContext)._typeAnnotation)
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(427)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(428)

				var _x = p.TypeAnnotation()

				localctx.(*FunctionTypeContext)._typeAnnotation = _x
			}
			localctx.(*FunctionTypeContext).paramTypes = append(localctx.(*FunctionTypeContext).paramTypes, localctx.(*FunctionTypeContext)._typeAnnotation)

			p.SetState(433)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(436)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(437)

			var _x = p.TypeAnnotation()

			localctx.(*FunctionTypeContext).returnType = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetDecl() ILetDeclContext
	ExprStmt() IExprStmtContext
	ReturnStmt() IReturnStmtContext
	YieldStmt() IYieldStmtContext
	IfStmt() IIfStmtContext
	ForStmt() IForStmtContext
	WhileStmt() IWhileStmtContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *StmtContext) ExprStmt() IExprStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprStmtContext)
}

func (s *StmtContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *StmtContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *StmtContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StmtContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *StmtContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *StmtContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt(s)
	}
}

func (s *StmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt(s)
	}
}

func (s *StmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_stmt)
	p.SetState(449)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(440)
			p.LetDecl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(441)
			p.ExprStmt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(442)
			p.ReturnStmt()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(443)
			p.YieldStmt()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(444)
			p.IfStmt()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(445)
			p.ForStmt()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(446)
			p.WhileStmt()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(447)
			p.CodeBlock()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(448)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprStmtContext is an interface to support dynamic dispatch.
type IExprStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsExprStmtContext differentiates from other interfaces.
	IsExprStmtContext()
}

type ExprStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprStmtContext() *ExprStmtContext {
	var p = new(ExprStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprStmt
	return p
}

func InitEmptyExprStmtContext(p *ExprStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprStmt
}

func (*ExprStmtContext) IsExprStmtContext() {}

func NewExprStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprStmtContext {
	var p = new(ExprStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprStmt

	return p
}

func (s *ExprStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExprStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprStmt(s)
	}
}

func (s *ExprStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprStmt(s)
	}
}

func (s *ExprStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprStmt() (localctx IExprStmtContext) {
	localctx = NewExprStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_exprStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Expr()
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(452)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	SEMICOLON() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ReturnStmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReturnStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ReturnStmtContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ReturnStmtContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_returnStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(456)
			p.Expr()
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(457)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(458)
				p.Expr()
			}

			p.SetState(463)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(467)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(466)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *YieldStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_yieldStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(469)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(470)
			p.Expr()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(473)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// GetElseBlock returns the elseBlock rule contexts.
	GetElseBlock() ICodeBlockContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// SetElseBlock sets the elseBlock rule contexts.
	SetElseBlock(ICodeBlockContext)

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
	block     ICodeBlockContext
	elseBlock ICodeBlockContext
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) GetCondition() IExprContext { return s.condition }

func (s *IfStmtContext) GetBlock() ICodeBlockContext { return s.block }

func (s *IfStmtContext) GetElseBlock() ICodeBlockContext { return s.elseBlock }

func (s *IfStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *IfStmtContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *IfStmtContext) SetElseBlock(v ICodeBlockContext) { s.elseBlock = v }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(477)

		var _x = p.Expr()

		localctx.(*IfStmtContext).condition = _x
	}
	{
		p.SetState(478)

		var _x = p.CodeBlock()

		localctx.(*IfStmtContext).block = _x
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(479)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(480)

			var _x = p.CodeBlock()

			localctx.(*IfStmtContext).elseBlock = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInit returns the init rule contexts.
	GetInit() IForInitPattnContext

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetUpdate returns the update rule contexts.
	GetUpdate() IExprContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() ILoopPatternContext

	// GetIterable returns the iterable rule contexts.
	GetIterable() IExprContext

	// SetInit sets the init rule contexts.
	SetInit(IForInitPattnContext)

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetUpdate sets the update rule contexts.
	SetUpdate(IExprContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(ILoopPatternContext)

	// SetIterable sets the iterable rule contexts.
	SetIterable(IExprContext)

	// Getter signatures
	FOR() antlr.TerminalNode
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	IN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	LoopPattern() ILoopPatternContext
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	ForInitPattn() IForInitPattnContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	init      IForInitPattnContext
	condition IExprContext
	update    IExprContext
	block     ICodeBlockContext
	pattern   ILoopPatternContext
	iterable  IExprContext
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) GetInit() IForInitPattnContext { return s.init }

func (s *ForStmtContext) GetCondition() IExprContext { return s.condition }

func (s *ForStmtContext) GetUpdate() IExprContext { return s.update }

func (s *ForStmtContext) GetBlock() ICodeBlockContext { return s.block }

func (s *ForStmtContext) GetPattern() ILoopPatternContext { return s.pattern }

func (s *ForStmtContext) GetIterable() IExprContext { return s.iterable }

func (s *ForStmtContext) SetInit(v IForInitPattnContext) { s.init = v }

func (s *ForStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *ForStmtContext) SetUpdate(v IExprContext) { s.update = v }

func (s *ForStmtContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *ForStmtContext) SetPattern(v ILoopPatternContext) { s.pattern = v }

func (s *ForStmtContext) SetIterable(v IExprContext) { s.iterable = v }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForStmtContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForStmtContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *ForStmtContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ForStmtContext) LoopPattern() ILoopPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopPatternContext)
}

func (s *ForStmtContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ForStmtContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForStmtContext) ForInitPattn() IForInitPattnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitPattnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitPattnContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_forStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.SetState(485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096816) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
			{
				p.SetState(484)

				var _x = p.ForInitPattn()

				localctx.(*ForStmtContext).init = _x
			}

		}
		{
			p.SetState(487)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
			{
				p.SetState(488)

				var _x = p.Expr()

				localctx.(*ForStmtContext).condition = _x
			}

		}
		{
			p.SetState(491)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(492)

				var _x = p.Expr()

				localctx.(*ForStmtContext).update = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(495)

			var _x = p.CodeBlock()

			localctx.(*ForStmtContext).block = _x
		}

	case 2:
		{
			p.SetState(496)

			var _x = p.LoopPattern()

			localctx.(*ForStmtContext).pattern = _x
		}
		{
			p.SetState(497)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(498)

			var _x = p.Expr()

			localctx.(*ForStmtContext).iterable = _x
		}
		{
			p.SetState(499)

			var _x = p.CodeBlock()

			localctx.(*ForStmtContext).block = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(503)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitPattnContext is an interface to support dynamic dispatch.
type IForInitPattnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetDecl() ILetDeclContext
	ExprStmt() IExprStmtContext

	// IsForInitPattnContext differentiates from other interfaces.
	IsForInitPattnContext()
}

type ForInitPattnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitPattnContext() *ForInitPattnContext {
	var p = new(ForInitPattnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInitPattn
	return p
}

func InitEmptyForInitPattnContext(p *ForInitPattnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInitPattn
}

func (*ForInitPattnContext) IsForInitPattnContext() {}

func NewForInitPattnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitPattnContext {
	var p = new(ForInitPattnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forInitPattn

	return p
}

func (s *ForInitPattnContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitPattnContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ForInitPattnContext) ExprStmt() IExprStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprStmtContext)
}

func (s *ForInitPattnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitPattnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitPattnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForInitPattn(s)
	}
}

func (s *ForInitPattnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForInitPattn(s)
	}
}

func (s *ForInitPattnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForInitPattn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForInitPattn() (localctx IForInitPattnContext) {
	localctx = NewForInitPattnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_forInitPattn)
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(506)
			p.LetDecl()
		}

	case ManuscriptFN, ManuscriptVOID, ManuscriptCHECK, ManuscriptTRY, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptASYNC, ManuscriptAWAIT, ManuscriptSELF, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(507)
			p.ExprStmt()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopPatternContext is an interface to support dynamic dispatch.
type ILoopPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetVarName returns the varName token.
	GetVarName() antlr.Token

	// GetVar1 returns the var1 token.
	GetVar1() antlr.Token

	// GetVar2 returns the var2 token.
	GetVar2() antlr.Token

	// SetVarName sets the varName token.
	SetVarName(antlr.Token)

	// SetVar1 sets the var1 token.
	SetVar1(antlr.Token)

	// SetVar2 sets the var2 token.
	SetVar2(antlr.Token)

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	LSQBR() antlr.TerminalNode
	COMMA() antlr.TerminalNode
	RSQBR() antlr.TerminalNode

	// IsLoopPatternContext differentiates from other interfaces.
	IsLoopPatternContext()
}

type LoopPatternContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	varName antlr.Token
	var1    antlr.Token
	var2    antlr.Token
}

func NewEmptyLoopPatternContext() *LoopPatternContext {
	var p = new(LoopPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopPattern
	return p
}

func InitEmptyLoopPatternContext(p *LoopPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopPattern
}

func (*LoopPatternContext) IsLoopPatternContext() {}

func NewLoopPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopPatternContext {
	var p = new(LoopPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopPattern

	return p
}

func (s *LoopPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopPatternContext) GetVarName() antlr.Token { return s.varName }

func (s *LoopPatternContext) GetVar1() antlr.Token { return s.var1 }

func (s *LoopPatternContext) GetVar2() antlr.Token { return s.var2 }

func (s *LoopPatternContext) SetVarName(v antlr.Token) { s.varName = v }

func (s *LoopPatternContext) SetVar1(v antlr.Token) { s.var1 = v }

func (s *LoopPatternContext) SetVar2(v antlr.Token) { s.var2 = v }

func (s *LoopPatternContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *LoopPatternContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *LoopPatternContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LoopPatternContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LoopPatternContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LoopPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopPattern(s)
	}
}

func (s *LoopPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopPattern(s)
	}
}

func (s *LoopPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopPattern() (localctx ILoopPatternContext) {
	localctx = NewLoopPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_loopPattern)
	p.SetState(516)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(510)

			var _m = p.Match(ManuscriptID)

			localctx.(*LoopPatternContext).varName = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(511)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)

			var _m = p.Match(ManuscriptID)

			localctx.(*LoopPatternContext).var1 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(513)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(514)

			var _m = p.Match(ManuscriptID)

			localctx.(*LoopPatternContext).var2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(515)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExprContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExprContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExprContext
	block     ICodeBlockContext
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) GetCondition() IExprContext { return s.condition }

func (s *WhileStmtContext) GetBlock() ICodeBlockContext { return s.block }

func (s *WhileStmtContext) SetCondition(v IExprContext) { s.condition = v }

func (s *WhileStmtContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *WhileStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(518)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(519)

		var _x = p.Expr()

		localctx.(*WhileStmtContext).condition = _x
	}
	{
		p.SetState(520)

		var _x = p.CodeBlock()

		localctx.(*WhileStmtContext).block = _x
	}
	p.SetState(522)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(521)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stmt returns the _stmt rule contexts.
	Get_stmt() IStmtContext

	// Set_stmt sets the _stmt rule contexts.
	Set_stmt(IStmtContext)

	// GetStmts returns the stmts rule context list.
	GetStmts() []IStmtContext

	// SetStmts sets the stmts rule context list.
	SetStmts([]IStmtContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	_stmt  IStmtContext
	stmts  []IStmtContext
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) Get_stmt() IStmtContext { return s._stmt }

func (s *CodeBlockContext) Set_stmt(v IStmtContext) { s._stmt = v }

func (s *CodeBlockContext) GetStmts() []IStmtContext { return s.stmts }

func (s *CodeBlockContext) SetStmts(v []IStmtContext) { s.stmts = v }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_codeBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291681389869326576) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
		{
			p.SetState(525)

			var _x = p.Stmt()

			localctx.(*CodeBlockContext)._stmt = _x
		}
		localctx.(*CodeBlockContext).stmts = append(localctx.(*CodeBlockContext).stmts, localctx.(*CodeBlockContext)._stmt)

		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(531)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	EQUALS() antlr.TerminalNode
	AssignmentExpr() IAssignmentExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalOrExprContext
	op     antlr.Token
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentExprContext) GetLeft() ILogicalOrExprContext { return s.left }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ILogicalOrExprContext) { s.left = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *AssignmentExprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_assignmentExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)

		var _x = p.LogicalOrExpr()

		localctx.(*AssignmentExprContext).left = _x
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(536)

			var _m = p.Match(ManuscriptEQUALS)

			localctx.(*AssignmentExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	AllLogicalAndExpr() []ILogicalAndExprContext
	LogicalAndExpr(i int) ILogicalAndExprContext
	AllPIPE_PIPE() []antlr.TerminalNode
	PIPE_PIPE(i int) antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) AllLogicalAndExpr() []ILogicalAndExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			len++
		}
	}

	tst := make([]ILogicalAndExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalAndExprContext); ok {
			tst[i] = t.(ILogicalAndExprContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExprContext) LogicalAndExpr(i int) ILogicalAndExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) AllPIPE_PIPE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPIPE_PIPE)
}

func (s *LogicalOrExprContext) PIPE_PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, i)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_logicalOrExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)

		var _x = p.LogicalAndExpr()

		localctx.(*LogicalOrExprContext).left = _x
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(541)

				var _m = p.Match(ManuscriptPIPE_PIPE)

				localctx.(*LogicalOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(542)

				var _x = p.LogicalAndExpr()

				localctx.(*LogicalOrExprContext).right = _x
			}

		}
		p.SetState(547)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	AllEqualityExpr() []IEqualityExprContext
	EqualityExpr(i int) IEqualityExprContext
	AllAMP_AMP() []antlr.TerminalNode
	AMP_AMP(i int) antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *LogicalAndExprContext) AllEqualityExpr() []IEqualityExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityExprContext); ok {
			len++
		}
	}

	tst := make([]IEqualityExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityExprContext); ok {
			tst[i] = t.(IEqualityExprContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExprContext) EqualityExpr(i int) IEqualityExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *LogicalAndExprContext) AllAMP_AMP() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptAMP_AMP)
}

func (s *LogicalAndExprContext) AMP_AMP(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, i)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_logicalAndExpr)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)

		var _x = p.EqualityExpr()

		localctx.(*LogicalAndExprContext).left = _x
	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(549)

				var _m = p.Match(ManuscriptAMP_AMP)

				localctx.(*LogicalAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(550)

				var _x = p.EqualityExpr()

				localctx.(*LogicalAndExprContext).right = _x
			}

		}
		p.SetState(555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	AllComparisonExpr() []IComparisonExprContext
	ComparisonExpr(i int) IComparisonExprContext
	AllEQUALS_EQUALS() []antlr.TerminalNode
	EQUALS_EQUALS(i int) antlr.TerminalNode
	AllNEQ() []antlr.TerminalNode
	NEQ(i int) antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) AllComparisonExpr() []IComparisonExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonExprContext); ok {
			len++
		}
	}

	tst := make([]IComparisonExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonExprContext); ok {
			tst[i] = t.(IComparisonExprContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExprContext) ComparisonExpr(i int) IComparisonExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) AllEQUALS_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptEQUALS_EQUALS)
}

func (s *EqualityExprContext) EQUALS_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, i)
}

func (s *EqualityExprContext) AllNEQ() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptNEQ)
}

func (s *EqualityExprContext) NEQ(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, i)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_equalityExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)

		var _x = p.ComparisonExpr()

		localctx.(*EqualityExprContext).left = _x
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(557)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*EqualityExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*EqualityExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(558)

				var _x = p.ComparisonExpr()

				localctx.(*EqualityExprContext).right = _x
			}

		}
		p.SetState(563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAdditiveExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAdditiveExprContext)

	// Getter signatures
	AllAdditiveExpr() []IAdditiveExprContext
	AdditiveExpr(i int) IAdditiveExprContext
	AllLT() []antlr.TerminalNode
	LT(i int) antlr.TerminalNode
	AllLT_EQUALS() []antlr.TerminalNode
	LT_EQUALS(i int) antlr.TerminalNode
	AllGT() []antlr.TerminalNode
	GT(i int) antlr.TerminalNode
	AllGT_EQUALS() []antlr.TerminalNode
	GT_EQUALS(i int) antlr.TerminalNode

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IAdditiveExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *ComparisonExprContext) GetRight() IAdditiveExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *ComparisonExprContext) SetRight(v IAdditiveExprContext) { s.right = v }

func (s *ComparisonExprContext) AllAdditiveExpr() []IAdditiveExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExprContext); ok {
			tst[i] = t.(IAdditiveExprContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExprContext) AdditiveExpr(i int) IAdditiveExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ComparisonExprContext) AllLT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLT)
}

func (s *ComparisonExprContext) LT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, i)
}

func (s *ComparisonExprContext) AllLT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLT_EQUALS)
}

func (s *ComparisonExprContext) LT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, i)
}

func (s *ComparisonExprContext) AllGT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptGT)
}

func (s *ComparisonExprContext) GT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, i)
}

func (s *ComparisonExprContext) AllGT_EQUALS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptGT_EQUALS)
}

func (s *ComparisonExprContext) GT_EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, i)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_comparisonExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)

		var _x = p.AdditiveExpr()

		localctx.(*ComparisonExprContext).left = _x
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(565)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ComparisonExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&32985348833280) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ComparisonExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(566)

				var _x = p.AdditiveExpr()

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	AllMultiplicativeExpr() []IMultiplicativeExprContext
	MultiplicativeExpr(i int) IMultiplicativeExprContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) AllMultiplicativeExpr() []IMultiplicativeExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExprContext); ok {
			tst[i] = t.(IMultiplicativeExprContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExprContext) MultiplicativeExpr(i int) IMultiplicativeExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPLUS)
}

func (s *AdditiveExprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, i)
}

func (s *AdditiveExprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptMINUS)
}

func (s *AdditiveExprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, i)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_additiveExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)

		var _x = p.MultiplicativeExpr()

		localctx.(*AdditiveExprContext).left = _x
	}
	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(573)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(574)

				var _x = p.MultiplicativeExpr()

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IUnaryExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IUnaryExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	AllUnaryExpr() []IUnaryExprContext
	UnaryExpr(i int) IUnaryExprContext
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IUnaryExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IUnaryExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IUnaryExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) AllUnaryExpr() []IUnaryExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryExprContext); ok {
			len++
		}
	}

	tst := make([]IUnaryExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryExprContext); ok {
			tst[i] = t.(IUnaryExprContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExprContext) UnaryExpr(i int) IUnaryExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSTAR)
}

func (s *MultiplicativeExprContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, i)
}

func (s *MultiplicativeExprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSLASH)
}

func (s *MultiplicativeExprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, i)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_multiplicativeExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)

		var _x = p.UnaryExpr()

		localctx.(*MultiplicativeExprContext).left = _x
	}
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(581)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptSTAR || _la == ManuscriptSLASH) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(582)

				var _x = p.UnaryExpr()

				localctx.(*MultiplicativeExprContext).right = _x
			}

		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	EXCLAMATION() antlr.TerminalNode
	TRY() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	AwaitExpr() IAwaitExprContext

	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *UnaryExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *UnaryExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *UnaryExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *UnaryExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *UnaryExprContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *UnaryExprContext) AwaitExpr() IAwaitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAwaitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAwaitExprContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterUnaryExpr(s)
	}
}

func (s *UnaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitUnaryExpr(s)
	}
}

func (s *UnaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitUnaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(588)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291608075872288768) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(589)
			p.UnaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.AwaitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAwaitExprContext is an interface to support dynamic dispatch.
type IAwaitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	TRY() antlr.TerminalNode
	AWAIT() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAwaitExprContext differentiates from other interfaces.
	IsAwaitExprContext()
}

type AwaitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExprContext() *AwaitExprContext {
	var p = new(AwaitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
	return p
}

func InitEmptyAwaitExprContext(p *AwaitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
}

func (*AwaitExprContext) IsAwaitExprContext() {}

func NewAwaitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExprContext {
	var p = new(AwaitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_awaitExpr

	return p
}

func (s *AwaitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *AwaitExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *AwaitExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(ManuscriptAWAIT, 0)
}

func (s *AwaitExprContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ManuscriptASYNC, 0)
}

func (s *AwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAwaitExpr(s)
	}
}

func (s *AwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAwaitExpr(s)
	}
}

func (s *AwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AwaitExpr() (localctx IAwaitExprContext) {
	localctx = NewAwaitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_awaitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(594)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(593)
			p.Match(ManuscriptTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAWAIT {
		{
			p.SetState(596)
			p.Match(ManuscriptAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptASYNC {
		{
			p.SetState(599)
			p.Match(ManuscriptASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

	{
		p.SetState(602)
		p.PostfixExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMember returns the member token.
	GetMember() antlr.Token

	// SetMember sets the member token.
	SetMember(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// GetIndexExpr returns the indexExpr rule contexts.
	GetIndexExpr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// SetIndexExpr sets the indexExpr rule contexts.
	SetIndexExpr(IExprContext)

	// GetArgs returns the args rule context list.
	GetArgs() []IExprContext

	// SetArgs sets the args rule context list.
	SetArgs([]IExprContext)

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	AllLPAREN() []antlr.TerminalNode
	LPAREN(i int) antlr.TerminalNode
	AllRPAREN() []antlr.TerminalNode
	RPAREN(i int) antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	AllLSQBR() []antlr.TerminalNode
	LSQBR(i int) antlr.TerminalNode
	AllRSQBR() []antlr.TerminalNode
	RSQBR(i int) antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_expr     IExprContext
	args      []IExprContext
	member    antlr.Token
	indexExpr IExprContext
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) GetMember() antlr.Token { return s.member }

func (s *PostfixExprContext) SetMember(v antlr.Token) { s.member = v }

func (s *PostfixExprContext) Get_expr() IExprContext { return s._expr }

func (s *PostfixExprContext) GetIndexExpr() IExprContext { return s.indexExpr }

func (s *PostfixExprContext) Set_expr(v IExprContext) { s._expr = v }

func (s *PostfixExprContext) SetIndexExpr(v IExprContext) { s.indexExpr = v }

func (s *PostfixExprContext) GetArgs() []IExprContext { return s.args }

func (s *PostfixExprContext) SetArgs(v []IExprContext) { s.args = v }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLPAREN)
}

func (s *PostfixExprContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, i)
}

func (s *PostfixExprContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRPAREN)
}

func (s *PostfixExprContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, i)
}

func (s *PostfixExprContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptDOT)
}

func (s *PostfixExprContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, i)
}

func (s *PostfixExprContext) AllLSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptLSQBR)
}

func (s *PostfixExprContext) LSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, i)
}

func (s *PostfixExprContext) AllRSQBR() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptRSQBR)
}

func (s *PostfixExprContext) RSQBR(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, i)
}

func (s *PostfixExprContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *PostfixExprContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *PostfixExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PostfixExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *PostfixExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_postfixExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.PrimaryExpr()
	}
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(623)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case ManuscriptLPAREN:
				{
					p.SetState(605)
					p.Match(ManuscriptLPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(614)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
					{
						p.SetState(606)

						var _x = p.Expr()

						localctx.(*PostfixExprContext)._expr = _x
					}
					localctx.(*PostfixExprContext).args = append(localctx.(*PostfixExprContext).args, localctx.(*PostfixExprContext)._expr)
					p.SetState(611)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					for _la == ManuscriptCOMMA {
						{
							p.SetState(607)
							p.Match(ManuscriptCOMMA)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}
						{
							p.SetState(608)

							var _x = p.Expr()

							localctx.(*PostfixExprContext)._expr = _x
						}
						localctx.(*PostfixExprContext).args = append(localctx.(*PostfixExprContext).args, localctx.(*PostfixExprContext)._expr)

						p.SetState(613)
						p.GetErrorHandler().Sync(p)
						if p.HasError() {
							goto errorExit
						}
						_la = p.GetTokenStream().LA(1)
					}

				}
				{
					p.SetState(616)
					p.Match(ManuscriptRPAREN)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case ManuscriptDOT:
				{
					p.SetState(617)
					p.Match(ManuscriptDOT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(618)

					var _m = p.Match(ManuscriptID)

					localctx.(*PostfixExprContext).member = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case ManuscriptLSQBR:
				{
					p.SetState(619)
					p.Match(ManuscriptLSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(620)

					var _x = p.Expr()

					localctx.(*PostfixExprContext).indexExpr = _x
				}
				{
					p.SetState(621)
					p.Match(ManuscriptRSQBR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParenExpr returns the parenExpr rule contexts.
	GetParenExpr() IExprContext

	// SetParenExpr sets the parenExpr rule contexts.
	SetParenExpr(IExprContext)

	// Getter signatures
	Literal() ILiteralContext
	ID() antlr.TerminalNode
	SELF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Expr() IExprContext
	ArrayLiteral() IArrayLiteralContext
	ObjectLiteral() IObjectLiteralContext
	MapLiteral() IMapLiteralContext
	SetLiteral() ISetLiteralContext
	TupleLiteral() ITupleLiteralContext
	FnExpr() IFnExprContext
	LambdaExpr() ILambdaExprContext
	TryBlockExpr() ITryBlockExprContext
	MatchExpr() IMatchExprContext
	VOID() antlr.TerminalNode
	NULL() antlr.TerminalNode

	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	parenExpr IExprContext
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) GetParenExpr() IExprContext { return s.parenExpr }

func (s *PrimaryExprContext) SetParenExpr(v IExprContext) { s.parenExpr = v }

func (s *PrimaryExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PrimaryExprContext) SELF() antlr.TerminalNode {
	return s.GetToken(ManuscriptSELF, 0)
}

func (s *PrimaryExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *PrimaryExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *PrimaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PrimaryExprContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *PrimaryExprContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryExprContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PrimaryExprContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *PrimaryExprContext) TupleLiteral() ITupleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleLiteralContext)
}

func (s *PrimaryExprContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *PrimaryExprContext) LambdaExpr() ILambdaExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExprContext)
}

func (s *PrimaryExprContext) TryBlockExpr() ITryBlockExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryBlockExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryBlockExprContext)
}

func (s *PrimaryExprContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *PrimaryExprContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *PrimaryExprContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryExpr(s)
	}
}

func (s *PrimaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_primaryExpr)
	p.SetState(646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(628)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(629)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(630)
			p.Match(ManuscriptSELF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(631)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(632)

			var _x = p.Expr()

			localctx.(*PrimaryExprContext).parenExpr = _x
		}
		{
			p.SetState(633)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(635)
			p.ArrayLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(636)
			p.ObjectLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(637)
			p.MapLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(638)
			p.SetLiteral()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(639)
			p.TupleLiteral()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(640)
			p.FnExpr()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(641)
			p.LambdaExpr()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(642)
			p.TryBlockExpr()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(643)
			p.MatchExpr()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(644)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(645)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeAnnotationContext

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeAnnotationContext)

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	COLON() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	params     IParametersContext
	returnType ITypeAnnotationContext
	block      ICodeBlockContext
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) GetParams() IParametersContext { return s.params }

func (s *FnExprContext) GetReturnType() ITypeAnnotationContext { return s.returnType }

func (s *FnExprContext) GetBlock() ICodeBlockContext { return s.block }

func (s *FnExprContext) SetParams(v IParametersContext) { s.params = v }

func (s *FnExprContext) SetReturnType(v ITypeAnnotationContext) { s.returnType = v }

func (s *FnExprContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(649)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(650)

			var _x = p.Parameters()

			localctx.(*FnExprContext).params = _x
		}

	}
	{
		p.SetState(653)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(654)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(655)

			var _x = p.TypeAnnotation()

			localctx.(*FnExprContext).returnType = _x
		}

	}
	{
		p.SetState(658)

		var _x = p.CodeBlock()

		localctx.(*FnExprContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExprContext is an interface to support dynamic dispatch.
type ILambdaExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParams returns the params rule contexts.
	GetParams() IParametersContext

	// GetBody returns the body rule contexts.
	GetBody() IExprContext

	// SetParams sets the params rule contexts.
	SetParams(IParametersContext)

	// SetBody sets the body rule contexts.
	SetBody(IExprContext)

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext
	Parameters() IParametersContext

	// IsLambdaExprContext differentiates from other interfaces.
	IsLambdaExprContext()
}

type LambdaExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	params IParametersContext
	body   IExprContext
}

func NewEmptyLambdaExprContext() *LambdaExprContext {
	var p = new(LambdaExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_lambdaExpr
	return p
}

func InitEmptyLambdaExprContext(p *LambdaExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_lambdaExpr
}

func (*LambdaExprContext) IsLambdaExprContext() {}

func NewLambdaExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExprContext {
	var p = new(LambdaExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_lambdaExpr

	return p
}

func (s *LambdaExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExprContext) GetParams() IParametersContext { return s.params }

func (s *LambdaExprContext) GetBody() IExprContext { return s.body }

func (s *LambdaExprContext) SetParams(v IParametersContext) { s.params = v }

func (s *LambdaExprContext) SetBody(v IExprContext) { s.body = v }

func (s *LambdaExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *LambdaExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LambdaExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LambdaExprContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LambdaExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LambdaExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *LambdaExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLambdaExpr(s)
	}
}

func (s *LambdaExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLambdaExpr(s)
	}
}

func (s *LambdaExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLambdaExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LambdaExpr() (localctx ILambdaExprContext) {
	localctx = NewLambdaExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_lambdaExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(662)

			var _x = p.Parameters()

			localctx.(*LambdaExprContext).params = _x
		}

	}
	{
		p.SetState(665)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(666)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(667)

		var _x = p.Expr()

		localctx.(*LambdaExprContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryBlockExprContext is an interface to support dynamic dispatch.
type ITryBlockExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBlock returns the block rule contexts.
	GetBlock() ICodeBlockContext

	// SetBlock sets the block rule contexts.
	SetBlock(ICodeBlockContext)

	// Getter signatures
	TRY() antlr.TerminalNode
	CodeBlock() ICodeBlockContext

	// IsTryBlockExprContext differentiates from other interfaces.
	IsTryBlockExprContext()
}

type TryBlockExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	block  ICodeBlockContext
}

func NewEmptyTryBlockExprContext() *TryBlockExprContext {
	var p = new(TryBlockExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryBlockExpr
	return p
}

func InitEmptyTryBlockExprContext(p *TryBlockExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryBlockExpr
}

func (*TryBlockExprContext) IsTryBlockExprContext() {}

func NewTryBlockExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryBlockExprContext {
	var p = new(TryBlockExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tryBlockExpr

	return p
}

func (s *TryBlockExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TryBlockExprContext) GetBlock() ICodeBlockContext { return s.block }

func (s *TryBlockExprContext) SetBlock(v ICodeBlockContext) { s.block = v }

func (s *TryBlockExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *TryBlockExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *TryBlockExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryBlockExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryBlockExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTryBlockExpr(s)
	}
}

func (s *TryBlockExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTryBlockExpr(s)
	}
}

func (s *TryBlockExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTryBlockExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TryBlockExpr() (localctx ITryBlockExprContext) {
	localctx = NewTryBlockExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_tryBlockExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(669)
		p.Match(ManuscriptTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(670)

		var _x = p.CodeBlock()

		localctx.(*TryBlockExprContext).block = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValueToMatch returns the valueToMatch rule contexts.
	GetValueToMatch() IExprContext

	// Get_caseClause returns the _caseClause rule contexts.
	Get_caseClause() ICaseClauseContext

	// SetValueToMatch sets the valueToMatch rule contexts.
	SetValueToMatch(IExprContext)

	// Set_caseClause sets the _caseClause rule contexts.
	Set_caseClause(ICaseClauseContext)

	// GetCases returns the cases rule context list.
	GetCases() []ICaseClauseContext

	// SetCases sets the cases rule context list.
	SetCases([]ICaseClauseContext)

	// Getter signatures
	MATCH() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	Expr() IExprContext
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	valueToMatch IExprContext
	_caseClause  ICaseClauseContext
	cases        []ICaseClauseContext
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) GetValueToMatch() IExprContext { return s.valueToMatch }

func (s *MatchExprContext) Get_caseClause() ICaseClauseContext { return s._caseClause }

func (s *MatchExprContext) SetValueToMatch(v IExprContext) { s.valueToMatch = v }

func (s *MatchExprContext) Set_caseClause(v ICaseClauseContext) { s._caseClause = v }

func (s *MatchExprContext) GetCases() []ICaseClauseContext { return s.cases }

func (s *MatchExprContext) SetCases(v []ICaseClauseContext) { s.cases = v }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MatchExprContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_matchExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(673)

		var _x = p.Expr()

		localctx.(*MatchExprContext).valueToMatch = _x
	}
	{
		p.SetState(674)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCASE {
		{
			p.SetState(675)

			var _x = p.CaseClause()

			localctx.(*MatchExprContext)._caseClause = _x
		}
		localctx.(*MatchExprContext).cases = append(localctx.(*MatchExprContext).cases, localctx.(*MatchExprContext)._caseClause)
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(676)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(677)

				var _x = p.CaseClause()

				localctx.(*MatchExprContext)._caseClause = _x
			}
			localctx.(*MatchExprContext).cases = append(localctx.(*MatchExprContext).cases, localctx.(*MatchExprContext)._caseClause)

			p.SetState(682)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(685)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IExprContext

	// GetResult returns the result rule contexts.
	GetResult() IExprContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IExprContext)

	// SetResult sets the result rule contexts.
	SetResult(IExprContext)

	// Getter signatures
	CASE() antlr.TerminalNode
	COLON() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IExprContext
	result  IExprContext
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) GetPattern() IExprContext { return s.pattern }

func (s *CaseClauseContext) GetResult() IExprContext { return s.result }

func (s *CaseClauseContext) SetPattern(v IExprContext) { s.pattern = v }

func (s *CaseClauseContext) SetResult(v IExprContext) { s.result = v }

func (s *CaseClauseContext) CASE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCASE, 0)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_caseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.Match(ManuscriptCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(688)

		var _x = p.Expr()

		localctx.(*CaseClauseContext).pattern = _x
	}
	{
		p.SetState(689)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(690)

		var _x = p.Expr()

		localctx.(*CaseClauseContext).result = _x
	}
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(691)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *SingleQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *SingleQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *SingleQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(698)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&27) != 0 {
		{
			p.SetState(695)

			var _x = p.StringPart()

			localctx.(*SingleQuotedStringContext)._stringPart = _x
		}
		localctx.(*SingleQuotedStringContext).parts = append(localctx.(*SingleQuotedStringContext).parts, localctx.(*SingleQuotedStringContext)._stringPart)

		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(701)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_stringPart returns the _stringPart rule contexts.
	Get_stringPart() IStringPartContext

	// Set_stringPart sets the _stringPart rule contexts.
	Set_stringPart(IStringPartContext)

	// GetParts returns the parts rule context list.
	GetParts() []IStringPartContext

	// SetParts sets the parts rule context list.
	SetParts([]IStringPartContext)

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_stringPart IStringPartContext
	parts       []IStringPartContext
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) Get_stringPart() IStringPartContext { return s._stringPart }

func (s *MultiQuotedStringContext) Set_stringPart(v IStringPartContext) { s._stringPart = v }

func (s *MultiQuotedStringContext) GetParts() []IStringPartContext { return s.parts }

func (s *MultiQuotedStringContext) SetParts(v []IStringPartContext) { s.parts = v }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(703)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-72)) & ^0x3f) == 0 && ((int64(1)<<(_la-72))&27) != 0 {
		{
			p.SetState(704)

			var _x = p.StringPart()

			localctx.(*MultiQuotedStringContext)._stringPart = _x
		}
		localctx.(*MultiQuotedStringContext).parts = append(localctx.(*MultiQuotedStringContext).parts, localctx.(*MultiQuotedStringContext)._stringPart)

		p.SetState(709)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(710)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetInterp returns the interp rule contexts.
	GetInterp() IInterpolationContext

	// SetInterp sets the interp rule contexts.
	SetInterp(IInterpolationContext)

	// Getter signatures
	SINGLE_STR_CONTENT() antlr.TerminalNode
	MULTI_STR_CONTENT() antlr.TerminalNode
	Interpolation() IInterpolationContext

	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	interp IInterpolationContext
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) GetInterp() IInterpolationContext { return s.interp }

func (s *StringPartContext) SetInterp(v IInterpolationContext) { s.interp = v }

func (s *StringPartContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *StringPartContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPart(s)
	}
}

func (s *StringPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPart(s)
	}
}

func (s *StringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_stringPart)
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(712)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(713)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(714)

			var _x = p.Interpolation()

			localctx.(*StringPartContext).interp = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	Expr() IExprContext

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExprContext
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) GetValue() IExprContext { return s.value }

func (s *InterpolationContext) SetValue(v IExprContext) { s.value = v }

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(717)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptSINGLE_STR_INTERP_START || _la == ManuscriptMULTI_STR_INTERP_START) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(718)

		var _x = p.Expr()

		localctx.(*InterpolationContext).value = _x
	}
	{
		p.SetState(719)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StringLiteral() IStringLiteralContext
	NumberLiteral() INumberLiteralContext
	BooleanLiteral() IBooleanLiteralContext
	NULL() antlr.TerminalNode
	VOID() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LiteralContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_literal)
	p.SetState(726)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(721)
			p.StringLiteral()
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(722)
			p.NumberLiteral()
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(723)
			p.BooleanLiteral()
		}

	case ManuscriptNULL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(724)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(725)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext
	MultiQuotedString() IMultiQuotedStringContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *StringLiteralContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_stringLiteral)
	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(728)
			p.SingleQuotedString()
		}

	case ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(729)
			p.MultiQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIntValue returns the intValue token.
	GetIntValue() antlr.Token

	// GetFloatValue returns the floatValue token.
	GetFloatValue() antlr.Token

	// GetHexValue returns the hexValue token.
	GetHexValue() antlr.Token

	// GetBinaryValue returns the binaryValue token.
	GetBinaryValue() antlr.Token

	// SetIntValue sets the intValue token.
	SetIntValue(antlr.Token)

	// SetFloatValue sets the floatValue token.
	SetFloatValue(antlr.Token)

	// SetHexValue sets the hexValue token.
	SetHexValue(antlr.Token)

	// SetBinaryValue sets the binaryValue token.
	SetBinaryValue(antlr.Token)

	// Getter signatures
	INTEGER() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	HEX_LITERAL() antlr.TerminalNode
	BINARY_LITERAL() antlr.TerminalNode

	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	intValue    antlr.Token
	floatValue  antlr.Token
	hexValue    antlr.Token
	binaryValue antlr.Token
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) GetIntValue() antlr.Token { return s.intValue }

func (s *NumberLiteralContext) GetFloatValue() antlr.Token { return s.floatValue }

func (s *NumberLiteralContext) GetHexValue() antlr.Token { return s.hexValue }

func (s *NumberLiteralContext) GetBinaryValue() antlr.Token { return s.binaryValue }

func (s *NumberLiteralContext) SetIntValue(v antlr.Token) { s.intValue = v }

func (s *NumberLiteralContext) SetFloatValue(v antlr.Token) { s.floatValue = v }

func (s *NumberLiteralContext) SetHexValue(v antlr.Token) { s.hexValue = v }

func (s *NumberLiteralContext) SetBinaryValue(v antlr.Token) { s.binaryValue = v }

func (s *NumberLiteralContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *NumberLiteralContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *NumberLiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *NumberLiteralContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumberLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteral(s)
	}
}

func (s *NumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_numberLiteral)
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)

			var _m = p.Match(ManuscriptINTEGER)

			localctx.(*NumberLiteralContext).intValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(733)

			var _m = p.Match(ManuscriptFLOAT)

			localctx.(*NumberLiteralContext).floatValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(734)

			var _m = p.Match(ManuscriptHEX_LITERAL)

			localctx.(*NumberLiteralContext).hexValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(735)

			var _m = p.Match(ManuscriptBINARY_LITERAL)

			localctx.(*NumberLiteralContext).binaryValue = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ManuscriptRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptTRUE || _la == ManuscriptFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetElements returns the elements rule context list.
	GetElements() []IExprContext

	// SetElements sets the elements rule context list.
	SetElements([]IExprContext)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	_expr    IExprContext
	elements []IExprContext
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) Get_expr() IExprContext { return s._expr }

func (s *ArrayLiteralContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ArrayLiteralContext) GetElements() []IExprContext { return s.elements }

func (s *ArrayLiteralContext) SetElements(v []IExprContext) { s.elements = v }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
		{
			p.SetState(741)

			var _x = p.Expr()

			localctx.(*ArrayLiteralContext)._expr = _x
		}
		localctx.(*ArrayLiteralContext).elements = append(localctx.(*ArrayLiteralContext).elements, localctx.(*ArrayLiteralContext)._expr)
		p.SetState(746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(742)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(743)

				var _x = p.Expr()

				localctx.(*ArrayLiteralContext)._expr = _x
			}
			localctx.(*ArrayLiteralContext).elements = append(localctx.(*ArrayLiteralContext).elements, localctx.(*ArrayLiteralContext)._expr)

			p.SetState(748)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(751)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_objectField returns the _objectField rule contexts.
	Get_objectField() IObjectFieldContext

	// Set_objectField sets the _objectField rule contexts.
	Set_objectField(IObjectFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IObjectFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IObjectFieldContext)

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	_objectField IObjectFieldContext
	fields       []IObjectFieldContext
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) Get_objectField() IObjectFieldContext { return s._objectField }

func (s *ObjectLiteralContext) Set_objectField(v IObjectFieldContext) { s._objectField = v }

func (s *ObjectLiteralContext) GetFields() []IObjectFieldContext { return s.fields }

func (s *ObjectLiteralContext) SetFields(v []IObjectFieldContext) { s.fields = v }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectLiteralContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ManuscriptRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(754)

			var _x = p.ObjectField()

			localctx.(*ObjectLiteralContext)._objectField = _x
		}
		localctx.(*ObjectLiteralContext).fields = append(localctx.(*ObjectLiteralContext).fields, localctx.(*ObjectLiteralContext)._objectField)
		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(755)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(756)

				var _x = p.ObjectField()

				localctx.(*ObjectLiteralContext)._objectField = _x
			}
			localctx.(*ObjectLiteralContext).fields = append(localctx.(*ObjectLiteralContext).fields, localctx.(*ObjectLiteralContext)._objectField)

			p.SetState(761)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(764)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key token.
	GetKey() antlr.Token

	// SetKey sets the key token.
	SetKey(antlr.Token)

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	ID() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    antlr.Token
	value  IExprContext
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) GetKey() antlr.Token { return s.key }

func (s *ObjectFieldContext) SetKey(v antlr.Token) { s.key = v }

func (s *ObjectFieldContext) GetValue() IExprContext { return s.value }

func (s *ObjectFieldContext) SetValue(v IExprContext) { s.value = v }

func (s *ObjectFieldContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)

		var _m = p.Match(ManuscriptID)

		localctx.(*ObjectFieldContext).key = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(767)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(768)

			var _x = p.Expr()

			localctx.(*ObjectFieldContext).value = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_mapField returns the _mapField rule contexts.
	Get_mapField() IMapFieldContext

	// Set_mapField sets the _mapField rule contexts.
	Set_mapField(IMapFieldContext)

	// GetFields returns the fields rule context list.
	GetFields() []IMapFieldContext

	// SetFields sets the fields rule context list.
	SetFields([]IMapFieldContext)

	// Getter signatures
	LSQBR() antlr.TerminalNode
	COLON() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	_mapField IMapFieldContext
	fields    []IMapFieldContext
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) Get_mapField() IMapFieldContext { return s._mapField }

func (s *MapLiteralContext) Set_mapField(v IMapFieldContext) { s._mapField = v }

func (s *MapLiteralContext) GetFields() []IMapFieldContext { return s.fields }

func (s *MapLiteralContext) SetFields(v []IMapFieldContext) { s.fields = v }

func (s *MapLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *MapLiteralContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *MapLiteralContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapLiteralContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapLiteral(s)
	}
}

func (s *MapLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapLiteral(s)
	}
}

func (s *MapLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ManuscriptRULE_mapLiteral)
	var _la int

	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(771)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(772)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(773)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(774)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
			{
				p.SetState(775)

				var _x = p.MapField()

				localctx.(*MapLiteralContext)._mapField = _x
			}
			localctx.(*MapLiteralContext).fields = append(localctx.(*MapLiteralContext).fields, localctx.(*MapLiteralContext)._mapField)
			p.SetState(780)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptCOMMA {
				{
					p.SetState(776)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(777)

					var _x = p.MapField()

					localctx.(*MapLiteralContext)._mapField = _x
				}
				localctx.(*MapLiteralContext).fields = append(localctx.(*MapLiteralContext).fields, localctx.(*MapLiteralContext)._mapField)

				p.SetState(782)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(785)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExprContext

	// GetValue returns the value rule contexts.
	GetValue() IExprContext

	// SetKey sets the key rule contexts.
	SetKey(IExprContext)

	// SetValue sets the value rule contexts.
	SetValue(IExprContext)

	// Getter signatures
	COLON() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExprContext
	value  IExprContext
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) GetKey() IExprContext { return s.key }

func (s *MapFieldContext) GetValue() IExprContext { return s.value }

func (s *MapFieldContext) SetKey(v IExprContext) { s.key = v }

func (s *MapFieldContext) SetValue(v IExprContext) { s.value = v }

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(788)

		var _x = p.Expr()

		localctx.(*MapFieldContext).key = _x
	}
	{
		p.SetState(789)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(790)

		var _x = p.Expr()

		localctx.(*MapFieldContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetElements returns the elements rule context list.
	GetElements() []IExprContext

	// SetElements sets the elements rule context list.
	SetElements([]IExprContext)

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	_expr    IExprContext
	elements []IExprContext
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) Get_expr() IExprContext { return s._expr }

func (s *SetLiteralContext) Set_expr(v IExprContext) { s._expr = v }

func (s *SetLiteralContext) GetElements() []IExprContext { return s.elements }

func (s *SetLiteralContext) SetElements(v []IExprContext) { s.elements = v }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ManuscriptRULE_setLiteral)
	var _la int

	p.SetState(806)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(792)
			p.Match(ManuscriptLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(793)
			p.Match(ManuscriptGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(794)
			p.Match(ManuscriptLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
			{
				p.SetState(795)

				var _x = p.Expr()

				localctx.(*SetLiteralContext)._expr = _x
			}
			localctx.(*SetLiteralContext).elements = append(localctx.(*SetLiteralContext).elements, localctx.(*SetLiteralContext)._expr)
			p.SetState(800)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptCOMMA {
				{
					p.SetState(796)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(797)

					var _x = p.Expr()

					localctx.(*SetLiteralContext)._expr = _x
				}
				localctx.(*SetLiteralContext).elements = append(localctx.(*SetLiteralContext).elements, localctx.(*SetLiteralContext)._expr)

				p.SetState(802)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(805)
			p.Match(ManuscriptGT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleLiteralContext is an interface to support dynamic dispatch.
type ITupleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetElements returns the elements rule context list.
	GetElements() []IExprContext

	// SetElements sets the elements rule context list.
	SetElements([]IExprContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTupleLiteralContext differentiates from other interfaces.
	IsTupleLiteralContext()
}

type TupleLiteralContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	_expr    IExprContext
	elements []IExprContext
}

func NewEmptyTupleLiteralContext() *TupleLiteralContext {
	var p = new(TupleLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleLiteral
	return p
}

func InitEmptyTupleLiteralContext(p *TupleLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleLiteral
}

func (*TupleLiteralContext) IsTupleLiteralContext() {}

func NewTupleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleLiteralContext {
	var p = new(TupleLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleLiteral

	return p
}

func (s *TupleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleLiteralContext) Get_expr() IExprContext { return s._expr }

func (s *TupleLiteralContext) Set_expr(v IExprContext) { s._expr = v }

func (s *TupleLiteralContext) GetElements() []IExprContext { return s.elements }

func (s *TupleLiteralContext) SetElements(v []IExprContext) { s.elements = v }

func (s *TupleLiteralContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleLiteralContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *TupleLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TupleLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TupleLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TupleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleLiteral(s)
	}
}

func (s *TupleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleLiteral(s)
	}
}

func (s *TupleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleLiteral() (localctx ITupleLiteralContext) {
	localctx = NewTupleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ManuscriptRULE_tupleLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&291611021016096800) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&127) != 0) {
		{
			p.SetState(809)

			var _x = p.Expr()

			localctx.(*TupleLiteralContext)._expr = _x
		}
		localctx.(*TupleLiteralContext).elements = append(localctx.(*TupleLiteralContext).elements, localctx.(*TupleLiteralContext)._expr)
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(810)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(811)

				var _x = p.Expr()

				localctx.(*TupleLiteralContext)._expr = _x
			}
			localctx.(*TupleLiteralContext).elements = append(localctx.(*TupleLiteralContext).elements, localctx.(*TupleLiteralContext)._expr)

			p.SetState(816)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(819)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStrContext is an interface to support dynamic dispatch.
type IImportStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPathSingle returns the pathSingle rule contexts.
	GetPathSingle() ISingleQuotedStringContext

	// GetPathMulti returns the pathMulti rule contexts.
	GetPathMulti() IMultiQuotedStringContext

	// SetPathSingle sets the pathSingle rule contexts.
	SetPathSingle(ISingleQuotedStringContext)

	// SetPathMulti sets the pathMulti rule contexts.
	SetPathMulti(IMultiQuotedStringContext)

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext
	MultiQuotedString() IMultiQuotedStringContext

	// IsImportStrContext differentiates from other interfaces.
	IsImportStrContext()
}

type ImportStrContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	pathSingle ISingleQuotedStringContext
	pathMulti  IMultiQuotedStringContext
}

func NewEmptyImportStrContext() *ImportStrContext {
	var p = new(ImportStrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
	return p
}

func InitEmptyImportStrContext(p *ImportStrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
}

func (*ImportStrContext) IsImportStrContext() {}

func NewImportStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStrContext {
	var p = new(ImportStrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importStr

	return p
}

func (s *ImportStrContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStrContext) GetPathSingle() ISingleQuotedStringContext { return s.pathSingle }

func (s *ImportStrContext) GetPathMulti() IMultiQuotedStringContext { return s.pathMulti }

func (s *ImportStrContext) SetPathSingle(v ISingleQuotedStringContext) { s.pathSingle = v }

func (s *ImportStrContext) SetPathMulti(v IMultiQuotedStringContext) { s.pathMulti = v }

func (s *ImportStrContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *ImportStrContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *ImportStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportStr(s)
	}
}

func (s *ImportStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportStr(s)
	}
}

func (s *ImportStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportStr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportStr() (localctx IImportStrContext) {
	localctx = NewImportStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ManuscriptRULE_importStr)
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)

			var _x = p.SingleQuotedString()

			localctx.(*ImportStrContext).pathSingle = _x
		}

	case ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)

			var _x = p.MultiQuotedString()

			localctx.(*ImportStrContext).pathMulti = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_typeAnnotation returns the _typeAnnotation rule contexts.
	Get_typeAnnotation() ITypeAnnotationContext

	// Set_typeAnnotation sets the _typeAnnotation rule contexts.
	Set_typeAnnotation(ITypeAnnotationContext)

	// GetTypes returns the types rule context list.
	GetTypes() []ITypeAnnotationContext

	// SetTypes sets the types rule context list.
	SetTypes([]ITypeAnnotationContext)

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	_typeAnnotation ITypeAnnotationContext
	types           []ITypeAnnotationContext
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) Get_typeAnnotation() ITypeAnnotationContext { return s._typeAnnotation }

func (s *TupleTypeContext) Set_typeAnnotation(v ITypeAnnotationContext) { s._typeAnnotation = v }

func (s *TupleTypeContext) GetTypes() []ITypeAnnotationContext { return s.types }

func (s *TupleTypeContext) SetTypes(v []ITypeAnnotationContext) { s.types = v }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TupleTypeContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TupleTypeContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptFN || _la == ManuscriptLPAREN || _la == ManuscriptID {
		{
			p.SetState(826)

			var _x = p.TypeAnnotation()

			localctx.(*TupleTypeContext)._typeAnnotation = _x
		}
		localctx.(*TupleTypeContext).types = append(localctx.(*TupleTypeContext).types, localctx.(*TupleTypeContext)._typeAnnotation)
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptCOMMA {
			{
				p.SetState(827)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(828)

				var _x = p.TypeAnnotation()

				localctx.(*TupleTypeContext)._typeAnnotation = _x
			}
			localctx.(*TupleTypeContext).types = append(localctx.(*TupleTypeContext).types, localctx.(*TupleTypeContext)._typeAnnotation)

			p.SetState(833)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(836)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
