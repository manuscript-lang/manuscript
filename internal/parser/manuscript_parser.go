// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "'\\n'", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'",
		"'interface'", "'import'", "'export'", "'extern'", "'void'", "'check'",
		"'try'", "'catch'", "'in'", "'as'", "'is'", "'extends'", "'from'", "'null'",
		"'if'", "'else'", "'for'", "'while'", "'true'", "'false'", "'match'",
		"'case'", "'async'", "'await'", "'methods'", "'break'", "'continue'",
		"'default'", "'defer'", "'go'", "", "", "'['", "']'", "'('", "')'",
		"'<'", "'>'", "'<='", "'>='", "':'", "';'", "','", "'='", "'=='", "'+'",
		"'-'", "'++'", "'--'", "'||'", "'&&'", "'*'", "'/'", "'%'", "'!'", "'?'",
		"'.'", "'!='", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'|'",
		"'&'", "'^'", "'<<'", "'>>'",
	}
	staticData.SymbolicNames = []string{
		"", "NEWLINE", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN",
		"YIELD", "TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID",
		"CHECK", "TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL",
		"IF", "ELSE", "FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC",
		"AWAIT", "METHODS", "BREAK", "CONTINUE", "DEFAULT", "DEFER", "GO", "LBRACE",
		"RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN", "LT", "GT", "LT_EQUALS",
		"GT_EQUALS", "COLON", "SEMICOLON", "COMMA", "EQUALS", "EQUALS_EQUALS",
		"PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS", "PIPE_PIPE", "AMP_AMP",
		"STAR", "SLASH", "MOD", "EXCLAMATION", "QUESTION", "DOT", "NEQ", "PLUS_EQUALS",
		"MINUS_EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "MOD_EQUALS", "CARET_EQUALS",
		"PIPE", "AMP", "CARET", "LSHIFT", "RSHIFT", "HEX_LITERAL", "BINARY_LITERAL",
		"OCTAL_LITERAL", "FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"DOUBLE_QUOTE_START", "MULTI_DOUBLE_QUOTE_START", "SINGLE_STR_INTERP_START",
		"SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START", "MULTI_STR_CONTENT",
		"MULTI_STR_END", "DOUBLE_STR_INTERP_START", "DOUBLE_STR_CONTENT", "DOUBLE_STR_END",
		"MULTI_DOUBLE_STR_INTERP_START", "MULTI_DOUBLE_STR_CONTENT", "MULTI_DOUBLE_STR_END",
		"INTERP_LBRACE", "INTERP_RBRACE", "INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "declaration", "importDecl", "exportDecl", "externDecl",
		"exportedItem", "moduleImport", "destructuredImport", "targetImport",
		"importItemList", "importItem", "letDecl", "letSingle", "letBlock",
		"letBlockItemList", "letBlockItemSep", "letBlockItem", "letDestructuredObj",
		"letDestructuredArray", "typedIDList", "typedID", "typeDecl", "typeDefBody",
		"typeAlias", "fieldList", "fieldDecl", "typeList", "interfaceDecl",
		"interfaceMethod", "fnDecl", "fnSignature", "parameters", "param", "methodsDecl",
		"methodImplList", "methodImpl", "stmt", "returnStmt", "yieldStmt", "deferStmt",
		"exprList", "ifStmt", "forStmt", "forLoopType", "forTrinity", "forInit",
		"forCond", "forPost", "whileStmt", "loopBody", "codeBlock", "breakStmt",
		"continueStmt", "checkStmt", "expr", "assignmentExpr", "assignmentOp",
		"ternaryExpr", "logicalOrExpr", "logicalAndExpr", "bitwiseOrExpr", "bitwiseXorExpr",
		"bitwiseAndExpr", "equalityExpr", "comparisonOp", "comparisonExpr",
		"shiftExpr", "additiveExpr", "multiplicativeExpr", "unaryExpr", "awaitExpr",
		"postfixExpr", "postfixOp", "primaryExpr", "fnExpr", "matchExpr", "caseClause",
		"defaultClause", "singleQuotedString", "multiQuotedString", "doubleQuotedString",
		"multiDoubleQuotedString", "stringPart", "interpolation", "literal",
		"stringLiteral", "numberLiteral", "booleanLiteral", "arrayLiteral",
		"objectLiteral", "objectFieldList", "objectField", "objectFieldName",
		"mapLiteral", "mapFieldList", "mapField", "setLiteral", "taggedBlockString",
		"structInitExpr", "structFieldList", "structField", "typeAnnotation",
		"tupleType", "arrayType", "fnType", "stmt_sep",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 103, 1236, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 1, 0, 5, 0, 214, 8, 0, 10, 0, 12, 0, 217,
		9, 0, 1, 0, 1, 0, 4, 0, 221, 8, 0, 11, 0, 12, 0, 222, 1, 0, 1, 0, 5, 0,
		227, 8, 0, 10, 0, 12, 0, 230, 9, 0, 3, 0, 232, 8, 0, 1, 0, 5, 0, 235, 8,
		0, 10, 0, 12, 0, 238, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 3, 1, 250, 8, 1, 1, 2, 1, 2, 1, 2, 3, 2, 255, 8, 2, 1, 3,
		1, 3, 1, 3, 3, 3, 260, 8, 3, 1, 4, 1, 4, 1, 4, 3, 4, 265, 8, 4, 1, 5, 1,
		5, 1, 5, 1, 5, 3, 5, 271, 8, 5, 1, 6, 1, 6, 3, 6, 275, 8, 6, 1, 7, 1, 7,
		3, 7, 279, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9,
		1, 9, 1, 9, 5, 9, 292, 8, 9, 10, 9, 12, 9, 295, 9, 9, 1, 9, 3, 9, 298,
		8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 303, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11,
		308, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 313, 8, 11, 1, 11, 1, 11, 1, 11,
		3, 11, 318, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 323, 8, 11, 3, 11, 325,
		8, 11, 1, 12, 1, 12, 1, 12, 3, 12, 330, 8, 12, 1, 13, 1, 13, 3, 13, 334,
		8, 13, 1, 13, 1, 13, 1, 14, 5, 14, 339, 8, 14, 10, 14, 12, 14, 342, 9,
		14, 1, 14, 1, 14, 4, 14, 346, 8, 14, 11, 14, 12, 14, 347, 1, 14, 1, 14,
		5, 14, 352, 8, 14, 10, 14, 12, 14, 355, 9, 14, 1, 14, 5, 14, 358, 8, 14,
		10, 14, 12, 14, 361, 9, 14, 1, 15, 1, 15, 3, 15, 365, 8, 15, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 383, 8, 16, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19,
		1, 19, 5, 19, 400, 8, 19, 10, 19, 12, 19, 403, 9, 19, 1, 19, 3, 19, 406,
		8, 19, 1, 20, 1, 20, 3, 20, 410, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3,
		21, 416, 8, 21, 1, 22, 1, 22, 3, 22, 420, 8, 22, 1, 22, 1, 22, 5, 22, 424,
		8, 22, 10, 22, 12, 22, 427, 9, 22, 1, 22, 1, 22, 5, 22, 431, 8, 22, 10,
		22, 12, 22, 434, 9, 22, 1, 22, 1, 22, 5, 22, 438, 8, 22, 10, 22, 12, 22,
		441, 9, 22, 1, 22, 5, 22, 444, 8, 22, 10, 22, 12, 22, 447, 9, 22, 1, 22,
		5, 22, 450, 8, 22, 10, 22, 12, 22, 453, 9, 22, 1, 22, 3, 22, 456, 8, 22,
		1, 22, 5, 22, 459, 8, 22, 10, 22, 12, 22, 462, 9, 22, 3, 22, 464, 8, 22,
		1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 472, 8, 23, 1, 24, 1,
		24, 1, 24, 5, 24, 477, 8, 24, 10, 24, 12, 24, 480, 9, 24, 1, 24, 3, 24,
		483, 8, 24, 1, 25, 1, 25, 3, 25, 487, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26,
		1, 26, 5, 26, 494, 8, 26, 10, 26, 12, 26, 497, 9, 26, 1, 26, 3, 26, 500,
		8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 506, 8, 27, 1, 27, 1, 27, 5,
		27, 510, 8, 27, 10, 27, 12, 27, 513, 9, 27, 1, 27, 1, 27, 5, 27, 517, 8,
		27, 10, 27, 12, 27, 520, 9, 27, 4, 27, 522, 8, 27, 11, 27, 12, 27, 523,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 531, 8, 28, 1, 28, 1, 28, 3,
		28, 535, 8, 28, 1, 28, 3, 28, 538, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 547, 8, 30, 1, 30, 1, 30, 3, 30, 551, 8, 30, 1,
		30, 3, 30, 554, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 559, 8, 31, 10, 31,
		12, 31, 562, 9, 31, 1, 31, 3, 31, 565, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		3, 32, 571, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 579,
		8, 33, 1, 33, 1, 33, 1, 34, 5, 34, 584, 8, 34, 10, 34, 12, 34, 587, 9,
		34, 1, 34, 1, 34, 4, 34, 591, 8, 34, 11, 34, 12, 34, 592, 1, 34, 1, 34,
		5, 34, 597, 8, 34, 10, 34, 12, 34, 600, 9, 34, 1, 34, 5, 34, 603, 8, 34,
		10, 34, 12, 34, 606, 9, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 3,
		36, 614, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 3, 36, 626, 8, 36, 1, 37, 1, 37, 3, 37, 630, 8, 37, 1, 37,
		3, 37, 633, 8, 37, 1, 38, 1, 38, 3, 38, 637, 8, 38, 1, 38, 3, 38, 640,
		8, 38, 1, 39, 1, 39, 1, 39, 3, 39, 645, 8, 39, 1, 40, 1, 40, 1, 40, 5,
		40, 650, 8, 40, 10, 40, 12, 40, 653, 9, 40, 1, 40, 3, 40, 656, 8, 40, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 663, 8, 41, 1, 42, 1, 42, 1, 42,
		1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 672, 8, 43, 1, 43, 1, 43, 1, 43, 1,
		43, 3, 43, 678, 8, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
		1, 45, 1, 45, 3, 45, 689, 8, 45, 1, 46, 1, 46, 3, 46, 693, 8, 46, 1, 47,
		1, 47, 3, 47, 697, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 5,
		49, 705, 8, 49, 10, 49, 12, 49, 708, 9, 49, 1, 49, 1, 49, 4, 49, 712, 8,
		49, 11, 49, 12, 49, 713, 1, 49, 1, 49, 5, 49, 718, 8, 49, 10, 49, 12, 49,
		721, 9, 49, 3, 49, 723, 8, 49, 1, 49, 5, 49, 726, 8, 49, 10, 49, 12, 49,
		729, 9, 49, 1, 49, 1, 49, 1, 50, 1, 50, 5, 50, 735, 8, 50, 10, 50, 12,
		50, 738, 9, 50, 1, 50, 1, 50, 4, 50, 742, 8, 50, 11, 50, 12, 50, 743, 1,
		50, 1, 50, 5, 50, 748, 8, 50, 10, 50, 12, 50, 751, 9, 50, 3, 50, 753, 8,
		50, 1, 50, 5, 50, 756, 8, 50, 10, 50, 12, 50, 759, 9, 50, 1, 50, 1, 50,
		1, 51, 1, 51, 3, 51, 765, 8, 51, 1, 52, 1, 52, 3, 52, 769, 8, 52, 1, 53,
		1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 776, 8, 53, 1, 54, 1, 54, 1, 55, 1,
		55, 1, 55, 1, 55, 1, 55, 3, 55, 785, 8, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 3, 56, 794, 8, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 1, 57, 3, 57, 803, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
		1, 58, 5, 58, 811, 8, 58, 10, 58, 12, 58, 814, 9, 58, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 59, 1, 59, 5, 59, 822, 8, 59, 10, 59, 12, 59, 825, 9, 59,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 833, 8, 60, 10, 60, 12,
		60, 836, 9, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 844, 8,
		61, 10, 61, 12, 61, 847, 9, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62,
		5, 62, 855, 8, 62, 10, 62, 12, 62, 858, 9, 62, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 63, 1, 63, 5, 63, 866, 8, 63, 10, 63, 12, 63, 869, 9, 63, 1, 64,
		1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 880, 8,
		65, 10, 65, 12, 65, 883, 9, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		5, 66, 891, 8, 66, 10, 66, 12, 66, 894, 9, 66, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 5, 67, 902, 8, 67, 10, 67, 12, 67, 905, 9, 67, 1, 68,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 913, 8, 68, 10, 68, 12, 68, 916,
		9, 68, 1, 69, 1, 69, 1, 69, 3, 69, 921, 8, 69, 1, 70, 3, 70, 924, 8, 70,
		1, 70, 3, 70, 927, 8, 70, 1, 70, 3, 70, 930, 8, 70, 1, 70, 1, 70, 1, 71,
		1, 71, 1, 71, 1, 71, 1, 71, 5, 71, 939, 8, 71, 10, 71, 12, 71, 942, 9,
		71, 1, 72, 1, 72, 3, 72, 946, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 3, 72, 955, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		3, 73, 973, 8, 73, 1, 74, 1, 74, 1, 74, 3, 74, 978, 8, 74, 1, 74, 1, 74,
		3, 74, 982, 8, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 75, 5, 75, 990,
		8, 75, 10, 75, 12, 75, 993, 9, 75, 1, 75, 1, 75, 4, 75, 997, 8, 75, 11,
		75, 12, 75, 998, 1, 75, 1, 75, 5, 75, 1003, 8, 75, 10, 75, 12, 75, 1006,
		9, 75, 1, 75, 5, 75, 1009, 8, 75, 10, 75, 12, 75, 1012, 9, 75, 1, 75, 3,
		75, 1015, 8, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1023,
		8, 76, 1, 76, 3, 76, 1026, 8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1032,
		8, 77, 1, 77, 3, 77, 1035, 8, 77, 1, 78, 1, 78, 5, 78, 1039, 8, 78, 10,
		78, 12, 78, 1042, 9, 78, 1, 78, 1, 78, 1, 79, 1, 79, 5, 79, 1048, 8, 79,
		10, 79, 12, 79, 1051, 9, 79, 1, 79, 1, 79, 1, 80, 1, 80, 5, 80, 1057, 8,
		80, 10, 80, 12, 80, 1060, 9, 80, 1, 80, 1, 80, 1, 81, 1, 81, 5, 81, 1066,
		8, 81, 10, 81, 12, 81, 1069, 9, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82,
		1, 82, 1, 82, 3, 82, 1078, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 3, 84, 1089, 8, 84, 1, 85, 1, 85, 1, 85, 1, 85,
		3, 85, 1095, 8, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1102, 8,
		86, 1, 87, 1, 87, 3, 87, 1106, 8, 87, 1, 88, 1, 88, 3, 88, 1110, 8, 88,
		1, 88, 1, 88, 1, 89, 1, 89, 3, 89, 1116, 8, 89, 1, 89, 1, 89, 1, 90, 1,
		90, 1, 90, 5, 90, 1123, 8, 90, 10, 90, 12, 90, 1126, 9, 90, 1, 90, 3, 90,
		1129, 8, 90, 1, 91, 1, 91, 1, 91, 3, 91, 1134, 8, 91, 1, 92, 1, 92, 3,
		92, 1138, 8, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 1145, 8, 93,
		1, 93, 3, 93, 1148, 8, 93, 1, 94, 1, 94, 1, 94, 5, 94, 1153, 8, 94, 10,
		94, 12, 94, 1156, 9, 94, 1, 94, 3, 94, 1159, 8, 94, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 5, 96, 1169, 8, 96, 10, 96, 12, 96,
		1172, 9, 96, 1, 96, 3, 96, 1175, 8, 96, 3, 96, 1177, 8, 96, 1, 96, 1, 96,
		1, 97, 1, 97, 1, 97, 3, 97, 1184, 8, 97, 1, 98, 1, 98, 1, 98, 3, 98, 1189,
		8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 5, 99, 1196, 8, 99, 10, 99, 12,
		99, 1199, 9, 99, 1, 99, 3, 99, 1202, 8, 99, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 1213, 8, 101, 1, 102,
		1, 102, 3, 102, 1217, 8, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1,
		103, 1, 104, 1, 104, 1, 104, 3, 104, 1228, 8, 104, 1, 104, 1, 104, 3, 104,
		1232, 8, 104, 1, 105, 1, 105, 1, 105, 0, 11, 116, 118, 120, 122, 124, 126,
		130, 132, 134, 136, 142, 106, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
		186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 0, 7,
		2, 0, 54, 54, 67, 67, 1, 0, 46, 49, 1, 0, 55, 56, 1, 0, 61, 63, 3, 0, 16,
		16, 55, 56, 64, 64, 4, 0, 89, 89, 92, 92, 95, 95, 98, 98, 2, 0, 1, 1, 51,
		51, 1336, 0, 215, 1, 0, 0, 0, 2, 249, 1, 0, 0, 0, 4, 251, 1, 0, 0, 0, 6,
		256, 1, 0, 0, 0, 8, 261, 1, 0, 0, 0, 10, 270, 1, 0, 0, 0, 12, 274, 1, 0,
		0, 0, 14, 276, 1, 0, 0, 0, 16, 284, 1, 0, 0, 0, 18, 288, 1, 0, 0, 0, 20,
		299, 1, 0, 0, 0, 22, 324, 1, 0, 0, 0, 24, 326, 1, 0, 0, 0, 26, 331, 1,
		0, 0, 0, 28, 340, 1, 0, 0, 0, 30, 364, 1, 0, 0, 0, 32, 382, 1, 0, 0, 0,
		34, 384, 1, 0, 0, 0, 36, 390, 1, 0, 0, 0, 38, 396, 1, 0, 0, 0, 40, 407,
		1, 0, 0, 0, 42, 411, 1, 0, 0, 0, 44, 419, 1, 0, 0, 0, 46, 467, 1, 0, 0,
		0, 48, 473, 1, 0, 0, 0, 50, 484, 1, 0, 0, 0, 52, 490, 1, 0, 0, 0, 54, 501,
		1, 0, 0, 0, 56, 527, 1, 0, 0, 0, 58, 539, 1, 0, 0, 0, 60, 542, 1, 0, 0,
		0, 62, 555, 1, 0, 0, 0, 64, 566, 1, 0, 0, 0, 66, 572, 1, 0, 0, 0, 68, 585,
		1, 0, 0, 0, 70, 607, 1, 0, 0, 0, 72, 625, 1, 0, 0, 0, 74, 627, 1, 0, 0,
		0, 76, 634, 1, 0, 0, 0, 78, 641, 1, 0, 0, 0, 80, 646, 1, 0, 0, 0, 82, 657,
		1, 0, 0, 0, 84, 664, 1, 0, 0, 0, 86, 677, 1, 0, 0, 0, 88, 679, 1, 0, 0,
		0, 90, 688, 1, 0, 0, 0, 92, 692, 1, 0, 0, 0, 94, 696, 1, 0, 0, 0, 96, 698,
		1, 0, 0, 0, 98, 702, 1, 0, 0, 0, 100, 732, 1, 0, 0, 0, 102, 762, 1, 0,
		0, 0, 104, 766, 1, 0, 0, 0, 106, 770, 1, 0, 0, 0, 108, 777, 1, 0, 0, 0,
		110, 784, 1, 0, 0, 0, 112, 793, 1, 0, 0, 0, 114, 802, 1, 0, 0, 0, 116,
		804, 1, 0, 0, 0, 118, 815, 1, 0, 0, 0, 120, 826, 1, 0, 0, 0, 122, 837,
		1, 0, 0, 0, 124, 848, 1, 0, 0, 0, 126, 859, 1, 0, 0, 0, 128, 870, 1, 0,
		0, 0, 130, 872, 1, 0, 0, 0, 132, 884, 1, 0, 0, 0, 134, 895, 1, 0, 0, 0,
		136, 906, 1, 0, 0, 0, 138, 920, 1, 0, 0, 0, 140, 923, 1, 0, 0, 0, 142,
		933, 1, 0, 0, 0, 144, 954, 1, 0, 0, 0, 146, 972, 1, 0, 0, 0, 148, 974,
		1, 0, 0, 0, 150, 985, 1, 0, 0, 0, 152, 1018, 1, 0, 0, 0, 154, 1027, 1,
		0, 0, 0, 156, 1036, 1, 0, 0, 0, 158, 1045, 1, 0, 0, 0, 160, 1054, 1, 0,
		0, 0, 162, 1063, 1, 0, 0, 0, 164, 1077, 1, 0, 0, 0, 166, 1079, 1, 0, 0,
		0, 168, 1088, 1, 0, 0, 0, 170, 1094, 1, 0, 0, 0, 172, 1101, 1, 0, 0, 0,
		174, 1105, 1, 0, 0, 0, 176, 1107, 1, 0, 0, 0, 178, 1113, 1, 0, 0, 0, 180,
		1119, 1, 0, 0, 0, 182, 1130, 1, 0, 0, 0, 184, 1137, 1, 0, 0, 0, 186, 1147,
		1, 0, 0, 0, 188, 1149, 1, 0, 0, 0, 190, 1160, 1, 0, 0, 0, 192, 1164, 1,
		0, 0, 0, 194, 1180, 1, 0, 0, 0, 196, 1185, 1, 0, 0, 0, 198, 1192, 1, 0,
		0, 0, 200, 1203, 1, 0, 0, 0, 202, 1212, 1, 0, 0, 0, 204, 1214, 1, 0, 0,
		0, 206, 1220, 1, 0, 0, 0, 208, 1224, 1, 0, 0, 0, 210, 1233, 1, 0, 0, 0,
		212, 214, 3, 210, 105, 0, 213, 212, 1, 0, 0, 0, 214, 217, 1, 0, 0, 0, 215,
		213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 231, 1, 0, 0, 0, 217, 215,
		1, 0, 0, 0, 218, 228, 3, 2, 1, 0, 219, 221, 3, 210, 105, 0, 220, 219, 1,
		0, 0, 0, 221, 222, 1, 0, 0, 0, 222, 220, 1, 0, 0, 0, 222, 223, 1, 0, 0,
		0, 223, 224, 1, 0, 0, 0, 224, 225, 3, 2, 1, 0, 225, 227, 1, 0, 0, 0, 226,
		220, 1, 0, 0, 0, 227, 230, 1, 0, 0, 0, 228, 226, 1, 0, 0, 0, 228, 229,
		1, 0, 0, 0, 229, 232, 1, 0, 0, 0, 230, 228, 1, 0, 0, 0, 231, 218, 1, 0,
		0, 0, 231, 232, 1, 0, 0, 0, 232, 236, 1, 0, 0, 0, 233, 235, 3, 210, 105,
		0, 234, 233, 1, 0, 0, 0, 235, 238, 1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 236,
		237, 1, 0, 0, 0, 237, 239, 1, 0, 0, 0, 238, 236, 1, 0, 0, 0, 239, 240,
		5, 0, 0, 1, 240, 1, 1, 0, 0, 0, 241, 250, 3, 4, 2, 0, 242, 250, 3, 6, 3,
		0, 243, 250, 3, 8, 4, 0, 244, 250, 3, 22, 11, 0, 245, 250, 3, 42, 21, 0,
		246, 250, 3, 54, 27, 0, 247, 250, 3, 58, 29, 0, 248, 250, 3, 66, 33, 0,
		249, 241, 1, 0, 0, 0, 249, 242, 1, 0, 0, 0, 249, 243, 1, 0, 0, 0, 249,
		244, 1, 0, 0, 0, 249, 245, 1, 0, 0, 0, 249, 246, 1, 0, 0, 0, 249, 247,
		1, 0, 0, 0, 249, 248, 1, 0, 0, 0, 250, 3, 1, 0, 0, 0, 251, 252, 5, 11,
		0, 0, 252, 254, 3, 12, 6, 0, 253, 255, 5, 51, 0, 0, 254, 253, 1, 0, 0,
		0, 254, 255, 1, 0, 0, 0, 255, 5, 1, 0, 0, 0, 256, 257, 5, 12, 0, 0, 257,
		259, 3, 10, 5, 0, 258, 260, 5, 51, 0, 0, 259, 258, 1, 0, 0, 0, 259, 260,
		1, 0, 0, 0, 260, 7, 1, 0, 0, 0, 261, 262, 5, 13, 0, 0, 262, 264, 3, 12,
		6, 0, 263, 265, 5, 51, 0, 0, 264, 263, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0,
		265, 9, 1, 0, 0, 0, 266, 271, 3, 58, 29, 0, 267, 271, 3, 22, 11, 0, 268,
		271, 3, 42, 21, 0, 269, 271, 3, 54, 27, 0, 270, 266, 1, 0, 0, 0, 270, 267,
		1, 0, 0, 0, 270, 268, 1, 0, 0, 0, 270, 269, 1, 0, 0, 0, 271, 11, 1, 0,
		0, 0, 272, 275, 3, 14, 7, 0, 273, 275, 3, 16, 8, 0, 274, 272, 1, 0, 0,
		0, 274, 273, 1, 0, 0, 0, 275, 13, 1, 0, 0, 0, 276, 278, 5, 40, 0, 0, 277,
		279, 3, 18, 9, 0, 278, 277, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 280,
		1, 0, 0, 0, 280, 281, 5, 41, 0, 0, 281, 282, 5, 22, 0, 0, 282, 283, 3,
		156, 78, 0, 283, 15, 1, 0, 0, 0, 284, 285, 5, 84, 0, 0, 285, 286, 5, 22,
		0, 0, 286, 287, 3, 156, 78, 0, 287, 17, 1, 0, 0, 0, 288, 293, 3, 20, 10,
		0, 289, 290, 5, 52, 0, 0, 290, 292, 3, 20, 10, 0, 291, 289, 1, 0, 0, 0,
		292, 295, 1, 0, 0, 0, 293, 291, 1, 0, 0, 0, 293, 294, 1, 0, 0, 0, 294,
		297, 1, 0, 0, 0, 295, 293, 1, 0, 0, 0, 296, 298, 5, 52, 0, 0, 297, 296,
		1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 19, 1, 0, 0, 0, 299, 302, 5, 84,
		0, 0, 300, 301, 5, 19, 0, 0, 301, 303, 5, 84, 0, 0, 302, 300, 1, 0, 0,
		0, 302, 303, 1, 0, 0, 0, 303, 21, 1, 0, 0, 0, 304, 305, 5, 5, 0, 0, 305,
		307, 3, 24, 12, 0, 306, 308, 5, 51, 0, 0, 307, 306, 1, 0, 0, 0, 307, 308,
		1, 0, 0, 0, 308, 325, 1, 0, 0, 0, 309, 310, 5, 5, 0, 0, 310, 312, 3, 26,
		13, 0, 311, 313, 5, 51, 0, 0, 312, 311, 1, 0, 0, 0, 312, 313, 1, 0, 0,
		0, 313, 325, 1, 0, 0, 0, 314, 315, 5, 5, 0, 0, 315, 317, 3, 34, 17, 0,
		316, 318, 5, 51, 0, 0, 317, 316, 1, 0, 0, 0, 317, 318, 1, 0, 0, 0, 318,
		325, 1, 0, 0, 0, 319, 320, 5, 5, 0, 0, 320, 322, 3, 36, 18, 0, 321, 323,
		5, 51, 0, 0, 322, 321, 1, 0, 0, 0, 322, 323, 1, 0, 0, 0, 323, 325, 1, 0,
		0, 0, 324, 304, 1, 0, 0, 0, 324, 309, 1, 0, 0, 0, 324, 314, 1, 0, 0, 0,
		324, 319, 1, 0, 0, 0, 325, 23, 1, 0, 0, 0, 326, 329, 3, 40, 20, 0, 327,
		328, 5, 53, 0, 0, 328, 330, 3, 108, 54, 0, 329, 327, 1, 0, 0, 0, 329, 330,
		1, 0, 0, 0, 330, 25, 1, 0, 0, 0, 331, 333, 5, 44, 0, 0, 332, 334, 3, 28,
		14, 0, 333, 332, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 335, 1, 0, 0, 0,
		335, 336, 5, 45, 0, 0, 336, 27, 1, 0, 0, 0, 337, 339, 3, 30, 15, 0, 338,
		337, 1, 0, 0, 0, 339, 342, 1, 0, 0, 0, 340, 338, 1, 0, 0, 0, 340, 341,
		1, 0, 0, 0, 341, 343, 1, 0, 0, 0, 342, 340, 1, 0, 0, 0, 343, 353, 3, 32,
		16, 0, 344, 346, 3, 30, 15, 0, 345, 344, 1, 0, 0, 0, 346, 347, 1, 0, 0,
		0, 347, 345, 1, 0, 0, 0, 347, 348, 1, 0, 0, 0, 348, 349, 1, 0, 0, 0, 349,
		350, 3, 32, 16, 0, 350, 352, 1, 0, 0, 0, 351, 345, 1, 0, 0, 0, 352, 355,
		1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 359, 1, 0,
		0, 0, 355, 353, 1, 0, 0, 0, 356, 358, 3, 30, 15, 0, 357, 356, 1, 0, 0,
		0, 358, 361, 1, 0, 0, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360,
		29, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 362, 365, 5, 52, 0, 0, 363, 365,
		3, 210, 105, 0, 364, 362, 1, 0, 0, 0, 364, 363, 1, 0, 0, 0, 365, 31, 1,
		0, 0, 0, 366, 367, 3, 40, 20, 0, 367, 368, 5, 53, 0, 0, 368, 369, 3, 108,
		54, 0, 369, 383, 1, 0, 0, 0, 370, 371, 5, 40, 0, 0, 371, 372, 3, 38, 19,
		0, 372, 373, 5, 41, 0, 0, 373, 374, 5, 53, 0, 0, 374, 375, 3, 108, 54,
		0, 375, 383, 1, 0, 0, 0, 376, 377, 5, 42, 0, 0, 377, 378, 3, 38, 19, 0,
		378, 379, 5, 43, 0, 0, 379, 380, 5, 53, 0, 0, 380, 381, 3, 108, 54, 0,
		381, 383, 1, 0, 0, 0, 382, 366, 1, 0, 0, 0, 382, 370, 1, 0, 0, 0, 382,
		376, 1, 0, 0, 0, 383, 33, 1, 0, 0, 0, 384, 385, 5, 40, 0, 0, 385, 386,
		3, 38, 19, 0, 386, 387, 5, 41, 0, 0, 387, 388, 5, 53, 0, 0, 388, 389, 3,
		108, 54, 0, 389, 35, 1, 0, 0, 0, 390, 391, 5, 42, 0, 0, 391, 392, 3, 38,
		19, 0, 392, 393, 5, 43, 0, 0, 393, 394, 5, 53, 0, 0, 394, 395, 3, 108,
		54, 0, 395, 37, 1, 0, 0, 0, 396, 401, 3, 40, 20, 0, 397, 398, 5, 52, 0,
		0, 398, 400, 3, 40, 20, 0, 399, 397, 1, 0, 0, 0, 400, 403, 1, 0, 0, 0,
		401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 405, 1, 0, 0, 0, 403,
		401, 1, 0, 0, 0, 404, 406, 5, 52, 0, 0, 405, 404, 1, 0, 0, 0, 405, 406,
		1, 0, 0, 0, 406, 39, 1, 0, 0, 0, 407, 409, 5, 84, 0, 0, 408, 410, 3, 202,
		101, 0, 409, 408, 1, 0, 0, 0, 409, 410, 1, 0, 0, 0, 410, 41, 1, 0, 0, 0,
		411, 412, 5, 9, 0, 0, 412, 415, 5, 84, 0, 0, 413, 416, 3, 44, 22, 0, 414,
		416, 3, 46, 23, 0, 415, 413, 1, 0, 0, 0, 415, 414, 1, 0, 0, 0, 416, 43,
		1, 0, 0, 0, 417, 418, 5, 21, 0, 0, 418, 420, 3, 52, 26, 0, 419, 417, 1,
		0, 0, 0, 419, 420, 1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 463, 5, 40, 0,
		0, 422, 424, 3, 210, 105, 0, 423, 422, 1, 0, 0, 0, 424, 427, 1, 0, 0, 0,
		425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 428, 1, 0, 0, 0, 427,
		425, 1, 0, 0, 0, 428, 445, 3, 50, 25, 0, 429, 431, 3, 210, 105, 0, 430,
		429, 1, 0, 0, 0, 431, 434, 1, 0, 0, 0, 432, 430, 1, 0, 0, 0, 432, 433,
		1, 0, 0, 0, 433, 435, 1, 0, 0, 0, 434, 432, 1, 0, 0, 0, 435, 439, 5, 52,
		0, 0, 436, 438, 3, 210, 105, 0, 437, 436, 1, 0, 0, 0, 438, 441, 1, 0, 0,
		0, 439, 437, 1, 0, 0, 0, 439, 440, 1, 0, 0, 0, 440, 442, 1, 0, 0, 0, 441,
		439, 1, 0, 0, 0, 442, 444, 3, 50, 25, 0, 443, 432, 1, 0, 0, 0, 444, 447,
		1, 0, 0, 0, 445, 443, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446, 455, 1, 0,
		0, 0, 447, 445, 1, 0, 0, 0, 448, 450, 3, 210, 105, 0, 449, 448, 1, 0, 0,
		0, 450, 453, 1, 0, 0, 0, 451, 449, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452,
		454, 1, 0, 0, 0, 453, 451, 1, 0, 0, 0, 454, 456, 5, 52, 0, 0, 455, 451,
		1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 460, 1, 0, 0, 0, 457, 459, 3, 210,
		105, 0, 458, 457, 1, 0, 0, 0, 459, 462, 1, 0, 0, 0, 460, 458, 1, 0, 0,
		0, 460, 461, 1, 0, 0, 0, 461, 464, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 463,
		425, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 466,
		5, 41, 0, 0, 466, 45, 1, 0, 0, 0, 467, 468, 5, 53, 0, 0, 468, 471, 3, 202,
		101, 0, 469, 470, 5, 21, 0, 0, 470, 472, 3, 52, 26, 0, 471, 469, 1, 0,
		0, 0, 471, 472, 1, 0, 0, 0, 472, 47, 1, 0, 0, 0, 473, 478, 3, 50, 25, 0,
		474, 475, 5, 52, 0, 0, 475, 477, 3, 50, 25, 0, 476, 474, 1, 0, 0, 0, 477,
		480, 1, 0, 0, 0, 478, 476, 1, 0, 0, 0, 478, 479, 1, 0, 0, 0, 479, 482,
		1, 0, 0, 0, 480, 478, 1, 0, 0, 0, 481, 483, 5, 52, 0, 0, 482, 481, 1, 0,
		0, 0, 482, 483, 1, 0, 0, 0, 483, 49, 1, 0, 0, 0, 484, 486, 5, 84, 0, 0,
		485, 487, 5, 65, 0, 0, 486, 485, 1, 0, 0, 0, 486, 487, 1, 0, 0, 0, 487,
		488, 1, 0, 0, 0, 488, 489, 3, 202, 101, 0, 489, 51, 1, 0, 0, 0, 490, 495,
		3, 202, 101, 0, 491, 492, 5, 52, 0, 0, 492, 494, 3, 202, 101, 0, 493, 491,
		1, 0, 0, 0, 494, 497, 1, 0, 0, 0, 495, 493, 1, 0, 0, 0, 495, 496, 1, 0,
		0, 0, 496, 499, 1, 0, 0, 0, 497, 495, 1, 0, 0, 0, 498, 500, 5, 52, 0, 0,
		499, 498, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 53, 1, 0, 0, 0, 501, 502,
		5, 10, 0, 0, 502, 505, 5, 84, 0, 0, 503, 504, 5, 21, 0, 0, 504, 506, 3,
		52, 26, 0, 505, 503, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 507, 1, 0,
		0, 0, 507, 521, 5, 40, 0, 0, 508, 510, 3, 210, 105, 0, 509, 508, 1, 0,
		0, 0, 510, 513, 1, 0, 0, 0, 511, 509, 1, 0, 0, 0, 511, 512, 1, 0, 0, 0,
		512, 514, 1, 0, 0, 0, 513, 511, 1, 0, 0, 0, 514, 518, 3, 56, 28, 0, 515,
		517, 3, 210, 105, 0, 516, 515, 1, 0, 0, 0, 517, 520, 1, 0, 0, 0, 518, 516,
		1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0,
		0, 0, 521, 511, 1, 0, 0, 0, 522, 523, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0,
		523, 524, 1, 0, 0, 0, 524, 525, 1, 0, 0, 0, 525, 526, 5, 41, 0, 0, 526,
		55, 1, 0, 0, 0, 527, 528, 5, 84, 0, 0, 528, 530, 5, 44, 0, 0, 529, 531,
		3, 62, 31, 0, 530, 529, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 532, 1,
		0, 0, 0, 532, 534, 5, 45, 0, 0, 533, 535, 3, 202, 101, 0, 534, 533, 1,
		0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 537, 1, 0, 0, 0, 536, 538, 5, 64, 0,
		0, 537, 536, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 57, 1, 0, 0, 0, 539,
		540, 3, 60, 30, 0, 540, 541, 3, 100, 50, 0, 541, 59, 1, 0, 0, 0, 542, 543,
		5, 6, 0, 0, 543, 544, 5, 84, 0, 0, 544, 546, 5, 44, 0, 0, 545, 547, 3,
		62, 31, 0, 546, 545, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 548, 1, 0,
		0, 0, 548, 550, 5, 45, 0, 0, 549, 551, 3, 202, 101, 0, 550, 549, 1, 0,
		0, 0, 550, 551, 1, 0, 0, 0, 551, 553, 1, 0, 0, 0, 552, 554, 5, 64, 0, 0,
		553, 552, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 61, 1, 0, 0, 0, 555, 560,
		3, 64, 32, 0, 556, 557, 5, 52, 0, 0, 557, 559, 3, 64, 32, 0, 558, 556,
		1, 0, 0, 0, 559, 562, 1, 0, 0, 0, 560, 558, 1, 0, 0, 0, 560, 561, 1, 0,
		0, 0, 561, 564, 1, 0, 0, 0, 562, 560, 1, 0, 0, 0, 563, 565, 5, 52, 0, 0,
		564, 563, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 63, 1, 0, 0, 0, 566, 567,
		5, 84, 0, 0, 567, 570, 3, 202, 101, 0, 568, 569, 5, 53, 0, 0, 569, 571,
		3, 108, 54, 0, 570, 568, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 65, 1,
		0, 0, 0, 572, 573, 5, 34, 0, 0, 573, 574, 5, 84, 0, 0, 574, 575, 5, 19,
		0, 0, 575, 576, 5, 84, 0, 0, 576, 578, 5, 40, 0, 0, 577, 579, 3, 68, 34,
		0, 578, 577, 1, 0, 0, 0, 578, 579, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580,
		581, 5, 41, 0, 0, 581, 67, 1, 0, 0, 0, 582, 584, 3, 210, 105, 0, 583, 582,
		1, 0, 0, 0, 584, 587, 1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 585, 586, 1, 0,
		0, 0, 586, 588, 1, 0, 0, 0, 587, 585, 1, 0, 0, 0, 588, 598, 3, 70, 35,
		0, 589, 591, 3, 210, 105, 0, 590, 589, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0,
		592, 590, 1, 0, 0, 0, 592, 593, 1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594,
		595, 3, 70, 35, 0, 595, 597, 1, 0, 0, 0, 596, 590, 1, 0, 0, 0, 597, 600,
		1, 0, 0, 0, 598, 596, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 604, 1, 0,
		0, 0, 600, 598, 1, 0, 0, 0, 601, 603, 3, 210, 105, 0, 602, 601, 1, 0, 0,
		0, 603, 606, 1, 0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 605, 1, 0, 0, 0, 605,
		69, 1, 0, 0, 0, 606, 604, 1, 0, 0, 0, 607, 608, 3, 56, 28, 0, 608, 609,
		3, 100, 50, 0, 609, 71, 1, 0, 0, 0, 610, 626, 3, 22, 11, 0, 611, 613, 3,
		108, 54, 0, 612, 614, 5, 51, 0, 0, 613, 612, 1, 0, 0, 0, 613, 614, 1, 0,
		0, 0, 614, 626, 1, 0, 0, 0, 615, 626, 3, 74, 37, 0, 616, 626, 3, 76, 38,
		0, 617, 626, 3, 82, 41, 0, 618, 626, 3, 84, 42, 0, 619, 626, 3, 96, 48,
		0, 620, 626, 3, 100, 50, 0, 621, 626, 3, 102, 51, 0, 622, 626, 3, 104,
		52, 0, 623, 626, 3, 106, 53, 0, 624, 626, 3, 78, 39, 0, 625, 610, 1, 0,
		0, 0, 625, 611, 1, 0, 0, 0, 625, 615, 1, 0, 0, 0, 625, 616, 1, 0, 0, 0,
		625, 617, 1, 0, 0, 0, 625, 618, 1, 0, 0, 0, 625, 619, 1, 0, 0, 0, 625,
		620, 1, 0, 0, 0, 625, 621, 1, 0, 0, 0, 625, 622, 1, 0, 0, 0, 625, 623,
		1, 0, 0, 0, 625, 624, 1, 0, 0, 0, 626, 73, 1, 0, 0, 0, 627, 629, 5, 7,
		0, 0, 628, 630, 3, 80, 40, 0, 629, 628, 1, 0, 0, 0, 629, 630, 1, 0, 0,
		0, 630, 632, 1, 0, 0, 0, 631, 633, 5, 51, 0, 0, 632, 631, 1, 0, 0, 0, 632,
		633, 1, 0, 0, 0, 633, 75, 1, 0, 0, 0, 634, 636, 5, 8, 0, 0, 635, 637, 3,
		80, 40, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0, 0, 637, 639, 1, 0,
		0, 0, 638, 640, 5, 51, 0, 0, 639, 638, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0,
		640, 77, 1, 0, 0, 0, 641, 642, 5, 38, 0, 0, 642, 644, 3, 108, 54, 0, 643,
		645, 5, 51, 0, 0, 644, 643, 1, 0, 0, 0, 644, 645, 1, 0, 0, 0, 645, 79,
		1, 0, 0, 0, 646, 651, 3, 108, 54, 0, 647, 648, 5, 52, 0, 0, 648, 650, 3,
		108, 54, 0, 649, 647, 1, 0, 0, 0, 650, 653, 1, 0, 0, 0, 651, 649, 1, 0,
		0, 0, 651, 652, 1, 0, 0, 0, 652, 655, 1, 0, 0, 0, 653, 651, 1, 0, 0, 0,
		654, 656, 5, 52, 0, 0, 655, 654, 1, 0, 0, 0, 655, 656, 1, 0, 0, 0, 656,
		81, 1, 0, 0, 0, 657, 658, 5, 24, 0, 0, 658, 659, 3, 108, 54, 0, 659, 662,
		3, 100, 50, 0, 660, 661, 5, 25, 0, 0, 661, 663, 3, 100, 50, 0, 662, 660,
		1, 0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 83, 1, 0, 0, 0, 664, 665, 5, 26,
		0, 0, 665, 666, 3, 86, 43, 0, 666, 85, 1, 0, 0, 0, 667, 678, 3, 88, 44,
		0, 668, 671, 5, 84, 0, 0, 669, 670, 5, 52, 0, 0, 670, 672, 5, 84, 0, 0,
		671, 669, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 1, 0, 0, 0, 673,
		674, 5, 18, 0, 0, 674, 675, 3, 108, 54, 0, 675, 676, 3, 98, 49, 0, 676,
		678, 1, 0, 0, 0, 677, 667, 1, 0, 0, 0, 677, 668, 1, 0, 0, 0, 678, 87, 1,
		0, 0, 0, 679, 680, 3, 90, 45, 0, 680, 681, 5, 51, 0, 0, 681, 682, 3, 92,
		46, 0, 682, 683, 5, 51, 0, 0, 683, 684, 3, 94, 47, 0, 684, 685, 3, 98,
		49, 0, 685, 89, 1, 0, 0, 0, 686, 689, 3, 24, 12, 0, 687, 689, 1, 0, 0,
		0, 688, 686, 1, 0, 0, 0, 688, 687, 1, 0, 0, 0, 689, 91, 1, 0, 0, 0, 690,
		693, 3, 108, 54, 0, 691, 693, 1, 0, 0, 0, 692, 690, 1, 0, 0, 0, 692, 691,
		1, 0, 0, 0, 693, 93, 1, 0, 0, 0, 694, 697, 3, 108, 54, 0, 695, 697, 1,
		0, 0, 0, 696, 694, 1, 0, 0, 0, 696, 695, 1, 0, 0, 0, 697, 95, 1, 0, 0,
		0, 698, 699, 5, 27, 0, 0, 699, 700, 3, 108, 54, 0, 700, 701, 3, 98, 49,
		0, 701, 97, 1, 0, 0, 0, 702, 706, 5, 40, 0, 0, 703, 705, 3, 210, 105, 0,
		704, 703, 1, 0, 0, 0, 705, 708, 1, 0, 0, 0, 706, 704, 1, 0, 0, 0, 706,
		707, 1, 0, 0, 0, 707, 722, 1, 0, 0, 0, 708, 706, 1, 0, 0, 0, 709, 719,
		3, 72, 36, 0, 710, 712, 3, 210, 105, 0, 711, 710, 1, 0, 0, 0, 712, 713,
		1, 0, 0, 0, 713, 711, 1, 0, 0, 0, 713, 714, 1, 0, 0, 0, 714, 715, 1, 0,
		0, 0, 715, 716, 3, 72, 36, 0, 716, 718, 1, 0, 0, 0, 717, 711, 1, 0, 0,
		0, 718, 721, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 719, 720, 1, 0, 0, 0, 720,
		723, 1, 0, 0, 0, 721, 719, 1, 0, 0, 0, 722, 709, 1, 0, 0, 0, 722, 723,
		1, 0, 0, 0, 723, 727, 1, 0, 0, 0, 724, 726, 3, 210, 105, 0, 725, 724, 1,
		0, 0, 0, 726, 729, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 727, 728, 1, 0, 0,
		0, 728, 730, 1, 0, 0, 0, 729, 727, 1, 0, 0, 0, 730, 731, 5, 41, 0, 0, 731,
		99, 1, 0, 0, 0, 732, 736, 5, 40, 0, 0, 733, 735, 3, 210, 105, 0, 734, 733,
		1, 0, 0, 0, 735, 738, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 736, 737, 1, 0,
		0, 0, 737, 752, 1, 0, 0, 0, 738, 736, 1, 0, 0, 0, 739, 749, 3, 72, 36,
		0, 740, 742, 3, 210, 105, 0, 741, 740, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0,
		743, 741, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745,
		746, 3, 72, 36, 0, 746, 748, 1, 0, 0, 0, 747, 741, 1, 0, 0, 0, 748, 751,
		1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 753, 1, 0,
		0, 0, 751, 749, 1, 0, 0, 0, 752, 739, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0,
		753, 757, 1, 0, 0, 0, 754, 756, 3, 210, 105, 0, 755, 754, 1, 0, 0, 0, 756,
		759, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 760,
		1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 760, 761, 5, 41, 0, 0, 761, 101, 1, 0,
		0, 0, 762, 764, 5, 35, 0, 0, 763, 765, 5, 51, 0, 0, 764, 763, 1, 0, 0,
		0, 764, 765, 1, 0, 0, 0, 765, 103, 1, 0, 0, 0, 766, 768, 5, 36, 0, 0, 767,
		769, 5, 51, 0, 0, 768, 767, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 105,
		1, 0, 0, 0, 770, 771, 5, 15, 0, 0, 771, 772, 3, 108, 54, 0, 772, 773, 5,
		52, 0, 0, 773, 775, 3, 170, 85, 0, 774, 776, 5, 51, 0, 0, 775, 774, 1,
		0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 107, 1, 0, 0, 0, 777, 778, 3, 110,
		55, 0, 778, 109, 1, 0, 0, 0, 779, 785, 3, 114, 57, 0, 780, 781, 3, 114,
		57, 0, 781, 782, 3, 112, 56, 0, 782, 783, 3, 110, 55, 0, 783, 785, 1, 0,
		0, 0, 784, 779, 1, 0, 0, 0, 784, 780, 1, 0, 0, 0, 785, 111, 1, 0, 0, 0,
		786, 794, 5, 53, 0, 0, 787, 794, 5, 68, 0, 0, 788, 794, 5, 69, 0, 0, 789,
		794, 5, 70, 0, 0, 790, 794, 5, 71, 0, 0, 791, 794, 5, 72, 0, 0, 792, 794,
		5, 73, 0, 0, 793, 786, 1, 0, 0, 0, 793, 787, 1, 0, 0, 0, 793, 788, 1, 0,
		0, 0, 793, 789, 1, 0, 0, 0, 793, 790, 1, 0, 0, 0, 793, 791, 1, 0, 0, 0,
		793, 792, 1, 0, 0, 0, 794, 113, 1, 0, 0, 0, 795, 803, 3, 116, 58, 0, 796,
		797, 3, 116, 58, 0, 797, 798, 5, 65, 0, 0, 798, 799, 3, 108, 54, 0, 799,
		800, 5, 50, 0, 0, 800, 801, 3, 114, 57, 0, 801, 803, 1, 0, 0, 0, 802, 795,
		1, 0, 0, 0, 802, 796, 1, 0, 0, 0, 803, 115, 1, 0, 0, 0, 804, 805, 6, 58,
		-1, 0, 805, 806, 3, 118, 59, 0, 806, 812, 1, 0, 0, 0, 807, 808, 10, 1,
		0, 0, 808, 809, 5, 59, 0, 0, 809, 811, 3, 118, 59, 0, 810, 807, 1, 0, 0,
		0, 811, 814, 1, 0, 0, 0, 812, 810, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813,
		117, 1, 0, 0, 0, 814, 812, 1, 0, 0, 0, 815, 816, 6, 59, -1, 0, 816, 817,
		3, 120, 60, 0, 817, 823, 1, 0, 0, 0, 818, 819, 10, 1, 0, 0, 819, 820, 5,
		60, 0, 0, 820, 822, 3, 120, 60, 0, 821, 818, 1, 0, 0, 0, 822, 825, 1, 0,
		0, 0, 823, 821, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824, 119, 1, 0, 0, 0,
		825, 823, 1, 0, 0, 0, 826, 827, 6, 60, -1, 0, 827, 828, 3, 122, 61, 0,
		828, 834, 1, 0, 0, 0, 829, 830, 10, 1, 0, 0, 830, 831, 5, 74, 0, 0, 831,
		833, 3, 122, 61, 0, 832, 829, 1, 0, 0, 0, 833, 836, 1, 0, 0, 0, 834, 832,
		1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 121, 1, 0, 0, 0, 836, 834, 1, 0,
		0, 0, 837, 838, 6, 61, -1, 0, 838, 839, 3, 124, 62, 0, 839, 845, 1, 0,
		0, 0, 840, 841, 10, 1, 0, 0, 841, 842, 5, 76, 0, 0, 842, 844, 3, 124, 62,
		0, 843, 840, 1, 0, 0, 0, 844, 847, 1, 0, 0, 0, 845, 843, 1, 0, 0, 0, 845,
		846, 1, 0, 0, 0, 846, 123, 1, 0, 0, 0, 847, 845, 1, 0, 0, 0, 848, 849,
		6, 62, -1, 0, 849, 850, 3, 126, 63, 0, 850, 856, 1, 0, 0, 0, 851, 852,
		10, 1, 0, 0, 852, 853, 5, 75, 0, 0, 853, 855, 3, 126, 63, 0, 854, 851,
		1, 0, 0, 0, 855, 858, 1, 0, 0, 0, 856, 854, 1, 0, 0, 0, 856, 857, 1, 0,
		0, 0, 857, 125, 1, 0, 0, 0, 858, 856, 1, 0, 0, 0, 859, 860, 6, 63, -1,
		0, 860, 861, 3, 130, 65, 0, 861, 867, 1, 0, 0, 0, 862, 863, 10, 1, 0, 0,
		863, 864, 7, 0, 0, 0, 864, 866, 3, 130, 65, 0, 865, 862, 1, 0, 0, 0, 866,
		869, 1, 0, 0, 0, 867, 865, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 127,
		1, 0, 0, 0, 869, 867, 1, 0, 0, 0, 870, 871, 7, 1, 0, 0, 871, 129, 1, 0,
		0, 0, 872, 873, 6, 65, -1, 0, 873, 874, 3, 132, 66, 0, 874, 881, 1, 0,
		0, 0, 875, 876, 10, 1, 0, 0, 876, 877, 3, 128, 64, 0, 877, 878, 3, 132,
		66, 0, 878, 880, 1, 0, 0, 0, 879, 875, 1, 0, 0, 0, 880, 883, 1, 0, 0, 0,
		881, 879, 1, 0, 0, 0, 881, 882, 1, 0, 0, 0, 882, 131, 1, 0, 0, 0, 883,
		881, 1, 0, 0, 0, 884, 885, 6, 66, -1, 0, 885, 886, 3, 134, 67, 0, 886,
		892, 1, 0, 0, 0, 887, 888, 10, 1, 0, 0, 888, 889, 7, 2, 0, 0, 889, 891,
		3, 134, 67, 0, 890, 887, 1, 0, 0, 0, 891, 894, 1, 0, 0, 0, 892, 890, 1,
		0, 0, 0, 892, 893, 1, 0, 0, 0, 893, 133, 1, 0, 0, 0, 894, 892, 1, 0, 0,
		0, 895, 896, 6, 67, -1, 0, 896, 897, 3, 136, 68, 0, 897, 903, 1, 0, 0,
		0, 898, 899, 10, 1, 0, 0, 899, 900, 7, 2, 0, 0, 900, 902, 3, 136, 68, 0,
		901, 898, 1, 0, 0, 0, 902, 905, 1, 0, 0, 0, 903, 901, 1, 0, 0, 0, 903,
		904, 1, 0, 0, 0, 904, 135, 1, 0, 0, 0, 905, 903, 1, 0, 0, 0, 906, 907,
		6, 68, -1, 0, 907, 908, 3, 138, 69, 0, 908, 914, 1, 0, 0, 0, 909, 910,
		10, 1, 0, 0, 910, 911, 7, 3, 0, 0, 911, 913, 3, 138, 69, 0, 912, 909, 1,
		0, 0, 0, 913, 916, 1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 914, 915, 1, 0, 0,
		0, 915, 137, 1, 0, 0, 0, 916, 914, 1, 0, 0, 0, 917, 918, 7, 4, 0, 0, 918,
		921, 3, 138, 69, 0, 919, 921, 3, 140, 70, 0, 920, 917, 1, 0, 0, 0, 920,
		919, 1, 0, 0, 0, 921, 139, 1, 0, 0, 0, 922, 924, 5, 16, 0, 0, 923, 922,
		1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 926, 1, 0, 0, 0, 925, 927, 5, 33,
		0, 0, 926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 929, 1, 0, 0, 0,
		928, 930, 5, 32, 0, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930,
		931, 1, 0, 0, 0, 931, 932, 3, 142, 71, 0, 932, 141, 1, 0, 0, 0, 933, 934,
		6, 71, -1, 0, 934, 935, 3, 146, 73, 0, 935, 940, 1, 0, 0, 0, 936, 937,
		10, 1, 0, 0, 937, 939, 3, 144, 72, 0, 938, 936, 1, 0, 0, 0, 939, 942, 1,
		0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 143, 1, 0, 0,
		0, 942, 940, 1, 0, 0, 0, 943, 945, 5, 44, 0, 0, 944, 946, 3, 80, 40, 0,
		945, 944, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947,
		955, 5, 45, 0, 0, 948, 949, 5, 66, 0, 0, 949, 955, 5, 84, 0, 0, 950, 951,
		5, 42, 0, 0, 951, 952, 3, 108, 54, 0, 952, 953, 5, 43, 0, 0, 953, 955,
		1, 0, 0, 0, 954, 943, 1, 0, 0, 0, 954, 948, 1, 0, 0, 0, 954, 950, 1, 0,
		0, 0, 955, 145, 1, 0, 0, 0, 956, 973, 3, 168, 84, 0, 957, 973, 5, 84, 0,
		0, 958, 959, 5, 44, 0, 0, 959, 960, 3, 108, 54, 0, 960, 961, 5, 45, 0,
		0, 961, 973, 1, 0, 0, 0, 962, 973, 3, 176, 88, 0, 963, 973, 3, 178, 89,
		0, 964, 973, 3, 186, 93, 0, 965, 973, 3, 192, 96, 0, 966, 973, 3, 148,
		74, 0, 967, 973, 3, 150, 75, 0, 968, 973, 5, 14, 0, 0, 969, 973, 5, 23,
		0, 0, 970, 973, 3, 194, 97, 0, 971, 973, 3, 196, 98, 0, 972, 956, 1, 0,
		0, 0, 972, 957, 1, 0, 0, 0, 972, 958, 1, 0, 0, 0, 972, 962, 1, 0, 0, 0,
		972, 963, 1, 0, 0, 0, 972, 964, 1, 0, 0, 0, 972, 965, 1, 0, 0, 0, 972,
		966, 1, 0, 0, 0, 972, 967, 1, 0, 0, 0, 972, 968, 1, 0, 0, 0, 972, 969,
		1, 0, 0, 0, 972, 970, 1, 0, 0, 0, 972, 971, 1, 0, 0, 0, 973, 147, 1, 0,
		0, 0, 974, 975, 5, 6, 0, 0, 975, 977, 5, 44, 0, 0, 976, 978, 3, 62, 31,
		0, 977, 976, 1, 0, 0, 0, 977, 978, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979,
		981, 5, 45, 0, 0, 980, 982, 3, 202, 101, 0, 981, 980, 1, 0, 0, 0, 981,
		982, 1, 0, 0, 0, 982, 983, 1, 0, 0, 0, 983, 984, 3, 100, 50, 0, 984, 149,
		1, 0, 0, 0, 985, 986, 5, 30, 0, 0, 986, 987, 3, 108, 54, 0, 987, 991, 5,
		40, 0, 0, 988, 990, 3, 210, 105, 0, 989, 988, 1, 0, 0, 0, 990, 993, 1,
		0, 0, 0, 991, 989, 1, 0, 0, 0, 991, 992, 1, 0, 0, 0, 992, 994, 1, 0, 0,
		0, 993, 991, 1, 0, 0, 0, 994, 1004, 3, 152, 76, 0, 995, 997, 3, 210, 105,
		0, 996, 995, 1, 0, 0, 0, 997, 998, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0, 998,
		999, 1, 0, 0, 0, 999, 1000, 1, 0, 0, 0, 1000, 1001, 3, 152, 76, 0, 1001,
		1003, 1, 0, 0, 0, 1002, 996, 1, 0, 0, 0, 1003, 1006, 1, 0, 0, 0, 1004,
		1002, 1, 0, 0, 0, 1004, 1005, 1, 0, 0, 0, 1005, 1010, 1, 0, 0, 0, 1006,
		1004, 1, 0, 0, 0, 1007, 1009, 3, 210, 105, 0, 1008, 1007, 1, 0, 0, 0, 1009,
		1012, 1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1010, 1011, 1, 0, 0, 0, 1011,
		1014, 1, 0, 0, 0, 1012, 1010, 1, 0, 0, 0, 1013, 1015, 3, 154, 77, 0, 1014,
		1013, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1016, 1, 0, 0, 0, 1016,
		1017, 5, 41, 0, 0, 1017, 151, 1, 0, 0, 0, 1018, 1022, 3, 108, 54, 0, 1019,
		1020, 5, 50, 0, 0, 1020, 1023, 3, 108, 54, 0, 1021, 1023, 3, 100, 50, 0,
		1022, 1019, 1, 0, 0, 0, 1022, 1021, 1, 0, 0, 0, 1023, 1025, 1, 0, 0, 0,
		1024, 1026, 5, 51, 0, 0, 1025, 1024, 1, 0, 0, 0, 1025, 1026, 1, 0, 0, 0,
		1026, 153, 1, 0, 0, 0, 1027, 1031, 5, 37, 0, 0, 1028, 1029, 5, 50, 0, 0,
		1029, 1032, 3, 108, 54, 0, 1030, 1032, 3, 100, 50, 0, 1031, 1028, 1, 0,
		0, 0, 1031, 1030, 1, 0, 0, 0, 1032, 1034, 1, 0, 0, 0, 1033, 1035, 5, 51,
		0, 0, 1034, 1033, 1, 0, 0, 0, 1034, 1035, 1, 0, 0, 0, 1035, 155, 1, 0,
		0, 0, 1036, 1040, 5, 85, 0, 0, 1037, 1039, 3, 164, 82, 0, 1038, 1037, 1,
		0, 0, 0, 1039, 1042, 1, 0, 0, 0, 1040, 1038, 1, 0, 0, 0, 1040, 1041, 1,
		0, 0, 0, 1041, 1043, 1, 0, 0, 0, 1042, 1040, 1, 0, 0, 0, 1043, 1044, 5,
		91, 0, 0, 1044, 157, 1, 0, 0, 0, 1045, 1049, 5, 86, 0, 0, 1046, 1048, 3,
		164, 82, 0, 1047, 1046, 1, 0, 0, 0, 1048, 1051, 1, 0, 0, 0, 1049, 1047,
		1, 0, 0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1052, 1, 0, 0, 0, 1051, 1049,
		1, 0, 0, 0, 1052, 1053, 5, 94, 0, 0, 1053, 159, 1, 0, 0, 0, 1054, 1058,
		5, 87, 0, 0, 1055, 1057, 3, 164, 82, 0, 1056, 1055, 1, 0, 0, 0, 1057, 1060,
		1, 0, 0, 0, 1058, 1056, 1, 0, 0, 0, 1058, 1059, 1, 0, 0, 0, 1059, 1061,
		1, 0, 0, 0, 1060, 1058, 1, 0, 0, 0, 1061, 1062, 5, 97, 0, 0, 1062, 161,
		1, 0, 0, 0, 1063, 1067, 5, 88, 0, 0, 1064, 1066, 3, 164, 82, 0, 1065, 1064,
		1, 0, 0, 0, 1066, 1069, 1, 0, 0, 0, 1067, 1065, 1, 0, 0, 0, 1067, 1068,
		1, 0, 0, 0, 1068, 1070, 1, 0, 0, 0, 1069, 1067, 1, 0, 0, 0, 1070, 1071,
		5, 100, 0, 0, 1071, 163, 1, 0, 0, 0, 1072, 1078, 5, 90, 0, 0, 1073, 1078,
		5, 93, 0, 0, 1074, 1078, 5, 96, 0, 0, 1075, 1078, 5, 99, 0, 0, 1076, 1078,
		3, 166, 83, 0, 1077, 1072, 1, 0, 0, 0, 1077, 1073, 1, 0, 0, 0, 1077, 1074,
		1, 0, 0, 0, 1077, 1075, 1, 0, 0, 0, 1077, 1076, 1, 0, 0, 0, 1078, 165,
		1, 0, 0, 0, 1079, 1080, 7, 5, 0, 0, 1080, 1081, 3, 108, 54, 0, 1081, 1082,
		5, 102, 0, 0, 1082, 167, 1, 0, 0, 0, 1083, 1089, 3, 170, 85, 0, 1084, 1089,
		3, 172, 86, 0, 1085, 1089, 3, 174, 87, 0, 1086, 1089, 5, 23, 0, 0, 1087,
		1089, 5, 14, 0, 0, 1088, 1083, 1, 0, 0, 0, 1088, 1084, 1, 0, 0, 0, 1088,
		1085, 1, 0, 0, 0, 1088, 1086, 1, 0, 0, 0, 1088, 1087, 1, 0, 0, 0, 1089,
		169, 1, 0, 0, 0, 1090, 1095, 3, 156, 78, 0, 1091, 1095, 3, 158, 79, 0,
		1092, 1095, 3, 160, 80, 0, 1093, 1095, 3, 162, 81, 0, 1094, 1090, 1, 0,
		0, 0, 1094, 1091, 1, 0, 0, 0, 1094, 1092, 1, 0, 0, 0, 1094, 1093, 1, 0,
		0, 0, 1095, 171, 1, 0, 0, 0, 1096, 1102, 5, 83, 0, 0, 1097, 1102, 5, 82,
		0, 0, 1098, 1102, 5, 79, 0, 0, 1099, 1102, 5, 80, 0, 0, 1100, 1102, 5,
		81, 0, 0, 1101, 1096, 1, 0, 0, 0, 1101, 1097, 1, 0, 0, 0, 1101, 1098, 1,
		0, 0, 0, 1101, 1099, 1, 0, 0, 0, 1101, 1100, 1, 0, 0, 0, 1102, 173, 1,
		0, 0, 0, 1103, 1106, 5, 28, 0, 0, 1104, 1106, 5, 29, 0, 0, 1105, 1103,
		1, 0, 0, 0, 1105, 1104, 1, 0, 0, 0, 1106, 175, 1, 0, 0, 0, 1107, 1109,
		5, 42, 0, 0, 1108, 1110, 3, 80, 40, 0, 1109, 1108, 1, 0, 0, 0, 1109, 1110,
		1, 0, 0, 0, 1110, 1111, 1, 0, 0, 0, 1111, 1112, 5, 43, 0, 0, 1112, 177,
		1, 0, 0, 0, 1113, 1115, 5, 40, 0, 0, 1114, 1116, 3, 180, 90, 0, 1115, 1114,
		1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1118,
		5, 41, 0, 0, 1118, 179, 1, 0, 0, 0, 1119, 1124, 3, 182, 91, 0, 1120, 1121,
		5, 52, 0, 0, 1121, 1123, 3, 182, 91, 0, 1122, 1120, 1, 0, 0, 0, 1123, 1126,
		1, 0, 0, 0, 1124, 1122, 1, 0, 0, 0, 1124, 1125, 1, 0, 0, 0, 1125, 1128,
		1, 0, 0, 0, 1126, 1124, 1, 0, 0, 0, 1127, 1129, 5, 52, 0, 0, 1128, 1127,
		1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 181, 1, 0, 0, 0, 1130, 1133,
		3, 184, 92, 0, 1131, 1132, 5, 50, 0, 0, 1132, 1134, 3, 108, 54, 0, 1133,
		1131, 1, 0, 0, 0, 1133, 1134, 1, 0, 0, 0, 1134, 183, 1, 0, 0, 0, 1135,
		1138, 5, 84, 0, 0, 1136, 1138, 3, 170, 85, 0, 1137, 1135, 1, 0, 0, 0, 1137,
		1136, 1, 0, 0, 0, 1138, 185, 1, 0, 0, 0, 1139, 1140, 5, 42, 0, 0, 1140,
		1141, 5, 50, 0, 0, 1141, 1148, 5, 43, 0, 0, 1142, 1144, 5, 42, 0, 0, 1143,
		1145, 3, 188, 94, 0, 1144, 1143, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145,
		1146, 1, 0, 0, 0, 1146, 1148, 5, 43, 0, 0, 1147, 1139, 1, 0, 0, 0, 1147,
		1142, 1, 0, 0, 0, 1148, 187, 1, 0, 0, 0, 1149, 1154, 3, 190, 95, 0, 1150,
		1151, 5, 52, 0, 0, 1151, 1153, 3, 190, 95, 0, 1152, 1150, 1, 0, 0, 0, 1153,
		1156, 1, 0, 0, 0, 1154, 1152, 1, 0, 0, 0, 1154, 1155, 1, 0, 0, 0, 1155,
		1158, 1, 0, 0, 0, 1156, 1154, 1, 0, 0, 0, 1157, 1159, 5, 52, 0, 0, 1158,
		1157, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 189, 1, 0, 0, 0, 1160,
		1161, 3, 108, 54, 0, 1161, 1162, 5, 50, 0, 0, 1162, 1163, 3, 108, 54, 0,
		1163, 191, 1, 0, 0, 0, 1164, 1176, 5, 46, 0, 0, 1165, 1170, 3, 108, 54,
		0, 1166, 1167, 5, 52, 0, 0, 1167, 1169, 3, 108, 54, 0, 1168, 1166, 1, 0,
		0, 0, 1169, 1172, 1, 0, 0, 0, 1170, 1168, 1, 0, 0, 0, 1170, 1171, 1, 0,
		0, 0, 1171, 1174, 1, 0, 0, 0, 1172, 1170, 1, 0, 0, 0, 1173, 1175, 5, 52,
		0, 0, 1174, 1173, 1, 0, 0, 0, 1174, 1175, 1, 0, 0, 0, 1175, 1177, 1, 0,
		0, 0, 1176, 1165, 1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 1178, 1, 0,
		0, 0, 1178, 1179, 5, 47, 0, 0, 1179, 193, 1, 0, 0, 0, 1180, 1183, 5, 84,
		0, 0, 1181, 1184, 3, 158, 79, 0, 1182, 1184, 3, 162, 81, 0, 1183, 1181,
		1, 0, 0, 0, 1183, 1182, 1, 0, 0, 0, 1184, 195, 1, 0, 0, 0, 1185, 1186,
		5, 84, 0, 0, 1186, 1188, 5, 44, 0, 0, 1187, 1189, 3, 198, 99, 0, 1188,
		1187, 1, 0, 0, 0, 1188, 1189, 1, 0, 0, 0, 1189, 1190, 1, 0, 0, 0, 1190,
		1191, 5, 45, 0, 0, 1191, 197, 1, 0, 0, 0, 1192, 1197, 3, 200, 100, 0, 1193,
		1194, 5, 52, 0, 0, 1194, 1196, 3, 200, 100, 0, 1195, 1193, 1, 0, 0, 0,
		1196, 1199, 1, 0, 0, 0, 1197, 1195, 1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0,
		1198, 1201, 1, 0, 0, 0, 1199, 1197, 1, 0, 0, 0, 1200, 1202, 5, 52, 0, 0,
		1201, 1200, 1, 0, 0, 0, 1201, 1202, 1, 0, 0, 0, 1202, 199, 1, 0, 0, 0,
		1203, 1204, 5, 84, 0, 0, 1204, 1205, 5, 50, 0, 0, 1205, 1206, 3, 108, 54,
		0, 1206, 201, 1, 0, 0, 0, 1207, 1213, 5, 84, 0, 0, 1208, 1213, 3, 206,
		103, 0, 1209, 1213, 3, 204, 102, 0, 1210, 1213, 3, 208, 104, 0, 1211, 1213,
		5, 14, 0, 0, 1212, 1207, 1, 0, 0, 0, 1212, 1208, 1, 0, 0, 0, 1212, 1209,
		1, 0, 0, 0, 1212, 1210, 1, 0, 0, 0, 1212, 1211, 1, 0, 0, 0, 1213, 203,
		1, 0, 0, 0, 1214, 1216, 5, 44, 0, 0, 1215, 1217, 3, 52, 26, 0, 1216, 1215,
		1, 0, 0, 0, 1216, 1217, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219,
		5, 45, 0, 0, 1219, 205, 1, 0, 0, 0, 1220, 1221, 5, 84, 0, 0, 1221, 1222,
		5, 42, 0, 0, 1222, 1223, 5, 43, 0, 0, 1223, 207, 1, 0, 0, 0, 1224, 1225,
		5, 6, 0, 0, 1225, 1227, 5, 44, 0, 0, 1226, 1228, 3, 62, 31, 0, 1227, 1226,
		1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229, 1231,
		5, 45, 0, 0, 1230, 1232, 3, 202, 101, 0, 1231, 1230, 1, 0, 0, 0, 1231,
		1232, 1, 0, 0, 0, 1232, 209, 1, 0, 0, 0, 1233, 1234, 7, 6, 0, 0, 1234,
		211, 1, 0, 0, 0, 155, 215, 222, 228, 231, 236, 249, 254, 259, 264, 270,
		274, 278, 293, 297, 302, 307, 312, 317, 322, 324, 329, 333, 340, 347, 353,
		359, 364, 382, 401, 405, 409, 415, 419, 425, 432, 439, 445, 451, 455, 460,
		463, 471, 478, 482, 486, 495, 499, 505, 511, 518, 523, 530, 534, 537, 546,
		550, 553, 560, 564, 570, 578, 585, 592, 598, 604, 613, 625, 629, 632, 636,
		639, 644, 651, 655, 662, 671, 677, 688, 692, 696, 706, 713, 719, 722, 727,
		736, 743, 749, 752, 757, 764, 768, 775, 784, 793, 802, 812, 823, 834, 845,
		856, 867, 881, 892, 903, 914, 920, 923, 926, 929, 940, 945, 954, 972, 977,
		981, 991, 998, 1004, 1010, 1014, 1022, 1025, 1031, 1034, 1040, 1049, 1058,
		1067, 1077, 1088, 1094, 1101, 1105, 1109, 1115, 1124, 1128, 1133, 1137,
		1144, 1147, 1154, 1158, 1170, 1174, 1176, 1183, 1188, 1197, 1201, 1212,
		1216, 1227, 1231,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                           = antlr.TokenEOF
	ManuscriptNEWLINE                       = 1
	ManuscriptWS                            = 2
	ManuscriptCOMMENT                       = 3
	ManuscriptMULTI_LINE_COMMENT            = 4
	ManuscriptLET                           = 5
	ManuscriptFN                            = 6
	ManuscriptRETURN                        = 7
	ManuscriptYIELD                         = 8
	ManuscriptTYPE                          = 9
	ManuscriptINTERFACE                     = 10
	ManuscriptIMPORT                        = 11
	ManuscriptEXPORT                        = 12
	ManuscriptEXTERN                        = 13
	ManuscriptVOID                          = 14
	ManuscriptCHECK                         = 15
	ManuscriptTRY                           = 16
	ManuscriptCATCH                         = 17
	ManuscriptIN                            = 18
	ManuscriptAS                            = 19
	ManuscriptIS                            = 20
	ManuscriptEXTENDS                       = 21
	ManuscriptFROM                          = 22
	ManuscriptNULL                          = 23
	ManuscriptIF                            = 24
	ManuscriptELSE                          = 25
	ManuscriptFOR                           = 26
	ManuscriptWHILE                         = 27
	ManuscriptTRUE                          = 28
	ManuscriptFALSE                         = 29
	ManuscriptMATCH                         = 30
	ManuscriptCASE                          = 31
	ManuscriptASYNC                         = 32
	ManuscriptAWAIT                         = 33
	ManuscriptMETHODS                       = 34
	ManuscriptBREAK                         = 35
	ManuscriptCONTINUE                      = 36
	ManuscriptDEFAULT                       = 37
	ManuscriptDEFER                         = 38
	ManuscriptGO                            = 39
	ManuscriptLBRACE                        = 40
	ManuscriptRBRACE                        = 41
	ManuscriptLSQBR                         = 42
	ManuscriptRSQBR                         = 43
	ManuscriptLPAREN                        = 44
	ManuscriptRPAREN                        = 45
	ManuscriptLT                            = 46
	ManuscriptGT                            = 47
	ManuscriptLT_EQUALS                     = 48
	ManuscriptGT_EQUALS                     = 49
	ManuscriptCOLON                         = 50
	ManuscriptSEMICOLON                     = 51
	ManuscriptCOMMA                         = 52
	ManuscriptEQUALS                        = 53
	ManuscriptEQUALS_EQUALS                 = 54
	ManuscriptPLUS                          = 55
	ManuscriptMINUS                         = 56
	ManuscriptPLUS_PLUS                     = 57
	ManuscriptMINUS_MINUS                   = 58
	ManuscriptPIPE_PIPE                     = 59
	ManuscriptAMP_AMP                       = 60
	ManuscriptSTAR                          = 61
	ManuscriptSLASH                         = 62
	ManuscriptMOD                           = 63
	ManuscriptEXCLAMATION                   = 64
	ManuscriptQUESTION                      = 65
	ManuscriptDOT                           = 66
	ManuscriptNEQ                           = 67
	ManuscriptPLUS_EQUALS                   = 68
	ManuscriptMINUS_EQUALS                  = 69
	ManuscriptSTAR_EQUALS                   = 70
	ManuscriptSLASH_EQUALS                  = 71
	ManuscriptMOD_EQUALS                    = 72
	ManuscriptCARET_EQUALS                  = 73
	ManuscriptPIPE                          = 74
	ManuscriptAMP                           = 75
	ManuscriptCARET                         = 76
	ManuscriptLSHIFT                        = 77
	ManuscriptRSHIFT                        = 78
	ManuscriptHEX_LITERAL                   = 79
	ManuscriptBINARY_LITERAL                = 80
	ManuscriptOCTAL_LITERAL                 = 81
	ManuscriptFLOAT                         = 82
	ManuscriptINTEGER                       = 83
	ManuscriptID                            = 84
	ManuscriptSINGLE_QUOTE_START            = 85
	ManuscriptMULTI_QUOTE_START             = 86
	ManuscriptDOUBLE_QUOTE_START            = 87
	ManuscriptMULTI_DOUBLE_QUOTE_START      = 88
	ManuscriptSINGLE_STR_INTERP_START       = 89
	ManuscriptSINGLE_STR_CONTENT            = 90
	ManuscriptSINGLE_STR_END                = 91
	ManuscriptMULTI_STR_INTERP_START        = 92
	ManuscriptMULTI_STR_CONTENT             = 93
	ManuscriptMULTI_STR_END                 = 94
	ManuscriptDOUBLE_STR_INTERP_START       = 95
	ManuscriptDOUBLE_STR_CONTENT            = 96
	ManuscriptDOUBLE_STR_END                = 97
	ManuscriptMULTI_DOUBLE_STR_INTERP_START = 98
	ManuscriptMULTI_DOUBLE_STR_CONTENT      = 99
	ManuscriptMULTI_DOUBLE_STR_END          = 100
	ManuscriptINTERP_LBRACE                 = 101
	ManuscriptINTERP_RBRACE                 = 102
	ManuscriptINTERP_WS                     = 103
)

// Manuscript rules.
const (
	ManuscriptRULE_program                 = 0
	ManuscriptRULE_declaration             = 1
	ManuscriptRULE_importDecl              = 2
	ManuscriptRULE_exportDecl              = 3
	ManuscriptRULE_externDecl              = 4
	ManuscriptRULE_exportedItem            = 5
	ManuscriptRULE_moduleImport            = 6
	ManuscriptRULE_destructuredImport      = 7
	ManuscriptRULE_targetImport            = 8
	ManuscriptRULE_importItemList          = 9
	ManuscriptRULE_importItem              = 10
	ManuscriptRULE_letDecl                 = 11
	ManuscriptRULE_letSingle               = 12
	ManuscriptRULE_letBlock                = 13
	ManuscriptRULE_letBlockItemList        = 14
	ManuscriptRULE_letBlockItemSep         = 15
	ManuscriptRULE_letBlockItem            = 16
	ManuscriptRULE_letDestructuredObj      = 17
	ManuscriptRULE_letDestructuredArray    = 18
	ManuscriptRULE_typedIDList             = 19
	ManuscriptRULE_typedID                 = 20
	ManuscriptRULE_typeDecl                = 21
	ManuscriptRULE_typeDefBody             = 22
	ManuscriptRULE_typeAlias               = 23
	ManuscriptRULE_fieldList               = 24
	ManuscriptRULE_fieldDecl               = 25
	ManuscriptRULE_typeList                = 26
	ManuscriptRULE_interfaceDecl           = 27
	ManuscriptRULE_interfaceMethod         = 28
	ManuscriptRULE_fnDecl                  = 29
	ManuscriptRULE_fnSignature             = 30
	ManuscriptRULE_parameters              = 31
	ManuscriptRULE_param                   = 32
	ManuscriptRULE_methodsDecl             = 33
	ManuscriptRULE_methodImplList          = 34
	ManuscriptRULE_methodImpl              = 35
	ManuscriptRULE_stmt                    = 36
	ManuscriptRULE_returnStmt              = 37
	ManuscriptRULE_yieldStmt               = 38
	ManuscriptRULE_deferStmt               = 39
	ManuscriptRULE_exprList                = 40
	ManuscriptRULE_ifStmt                  = 41
	ManuscriptRULE_forStmt                 = 42
	ManuscriptRULE_forLoopType             = 43
	ManuscriptRULE_forTrinity              = 44
	ManuscriptRULE_forInit                 = 45
	ManuscriptRULE_forCond                 = 46
	ManuscriptRULE_forPost                 = 47
	ManuscriptRULE_whileStmt               = 48
	ManuscriptRULE_loopBody                = 49
	ManuscriptRULE_codeBlock               = 50
	ManuscriptRULE_breakStmt               = 51
	ManuscriptRULE_continueStmt            = 52
	ManuscriptRULE_checkStmt               = 53
	ManuscriptRULE_expr                    = 54
	ManuscriptRULE_assignmentExpr          = 55
	ManuscriptRULE_assignmentOp            = 56
	ManuscriptRULE_ternaryExpr             = 57
	ManuscriptRULE_logicalOrExpr           = 58
	ManuscriptRULE_logicalAndExpr          = 59
	ManuscriptRULE_bitwiseOrExpr           = 60
	ManuscriptRULE_bitwiseXorExpr          = 61
	ManuscriptRULE_bitwiseAndExpr          = 62
	ManuscriptRULE_equalityExpr            = 63
	ManuscriptRULE_comparisonOp            = 64
	ManuscriptRULE_comparisonExpr          = 65
	ManuscriptRULE_shiftExpr               = 66
	ManuscriptRULE_additiveExpr            = 67
	ManuscriptRULE_multiplicativeExpr      = 68
	ManuscriptRULE_unaryExpr               = 69
	ManuscriptRULE_awaitExpr               = 70
	ManuscriptRULE_postfixExpr             = 71
	ManuscriptRULE_postfixOp               = 72
	ManuscriptRULE_primaryExpr             = 73
	ManuscriptRULE_fnExpr                  = 74
	ManuscriptRULE_matchExpr               = 75
	ManuscriptRULE_caseClause              = 76
	ManuscriptRULE_defaultClause           = 77
	ManuscriptRULE_singleQuotedString      = 78
	ManuscriptRULE_multiQuotedString       = 79
	ManuscriptRULE_doubleQuotedString      = 80
	ManuscriptRULE_multiDoubleQuotedString = 81
	ManuscriptRULE_stringPart              = 82
	ManuscriptRULE_interpolation           = 83
	ManuscriptRULE_literal                 = 84
	ManuscriptRULE_stringLiteral           = 85
	ManuscriptRULE_numberLiteral           = 86
	ManuscriptRULE_booleanLiteral          = 87
	ManuscriptRULE_arrayLiteral            = 88
	ManuscriptRULE_objectLiteral           = 89
	ManuscriptRULE_objectFieldList         = 90
	ManuscriptRULE_objectField             = 91
	ManuscriptRULE_objectFieldName         = 92
	ManuscriptRULE_mapLiteral              = 93
	ManuscriptRULE_mapFieldList            = 94
	ManuscriptRULE_mapField                = 95
	ManuscriptRULE_setLiteral              = 96
	ManuscriptRULE_taggedBlockString       = 97
	ManuscriptRULE_structInitExpr          = 98
	ManuscriptRULE_structFieldList         = 99
	ManuscriptRULE_structField             = 100
	ManuscriptRULE_typeAnnotation          = 101
	ManuscriptRULE_tupleType               = 102
	ManuscriptRULE_arrayType               = 103
	ManuscriptRULE_fnType                  = 104
	ManuscriptRULE_stmt_sep                = 105
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *ProgramContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(212)
				p.Stmt_sep()
			}

		}
		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179885152) != 0 {
		{
			p.SetState(218)
			p.Declaration()
		}
		p.SetState(228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(220)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(219)
						p.Stmt_sep()
					}

					p.SetState(222)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(224)
					p.Declaration()
				}

			}
			p.SetState(230)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(233)
			p.Stmt_sep()
		}

		p.SetState(238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(239)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportDecl() IImportDeclContext
	ExportDecl() IExportDeclContext
	ExternDecl() IExternDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext
	FnDecl() IFnDeclContext
	MethodsDecl() IMethodsDeclContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ImportDecl() IImportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *DeclarationContext) ExportDecl() IExportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportDeclContext)
}

func (s *DeclarationContext) ExternDecl() IExternDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternDeclContext)
}

func (s *DeclarationContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *DeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclarationContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *DeclarationContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *DeclarationContext) MethodsDecl() IMethodsDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodsDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodsDeclContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_declaration)
	p.SetState(249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(241)
			p.ImportDecl()
		}

	case ManuscriptEXPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(242)
			p.ExportDecl()
		}

	case ManuscriptEXTERN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(243)
			p.ExternDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(244)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(245)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(246)
			p.InterfaceDecl()
		}

	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(247)
			p.FnDecl()
		}

	case ManuscriptMETHODS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(248)
			p.MethodsDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ImportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(252)
		p.ModuleImport()
	}
	p.SetState(254)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(253)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportDeclContext is an interface to support dynamic dispatch.
type IExportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	ExportedItem() IExportedItemContext
	SEMICOLON() antlr.TerminalNode

	// IsExportDeclContext differentiates from other interfaces.
	IsExportDeclContext()
}

type ExportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportDeclContext() *ExportDeclContext {
	var p = new(ExportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
	return p
}

func InitEmptyExportDeclContext(p *ExportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
}

func (*ExportDeclContext) IsExportDeclContext() {}

func NewExportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportDeclContext {
	var p = new(ExportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportDecl

	return p
}

func (s *ExportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportDeclContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportDeclContext) ExportedItem() IExportedItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedItemContext)
}

func (s *ExportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportDecl(s)
	}
}

func (s *ExportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportDecl(s)
	}
}

func (s *ExportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportDecl() (localctx IExportDeclContext) {
	localctx = NewExportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_exportDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(257)
		p.ExportedItem()
	}
	p.SetState(259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(258)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternDeclContext is an interface to support dynamic dispatch.
type IExternDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsExternDeclContext differentiates from other interfaces.
	IsExternDeclContext()
}

type ExternDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternDeclContext() *ExternDeclContext {
	var p = new(ExternDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
	return p
}

func InitEmptyExternDeclContext(p *ExternDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
}

func (*ExternDeclContext) IsExternDeclContext() {}

func NewExternDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternDeclContext {
	var p = new(ExternDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externDecl

	return p
}

func (s *ExternDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternDeclContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ExternDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExternDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternDecl(s)
	}
}

func (s *ExternDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternDecl(s)
	}
}

func (s *ExternDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternDecl() (localctx IExternDeclContext) {
	localctx = NewExternDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_externDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(261)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(262)
		p.ModuleImport()
	}
	p.SetState(264)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(263)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportedItemContext is an interface to support dynamic dispatch.
type IExportedItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnDecl() IFnDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext

	// IsExportedItemContext differentiates from other interfaces.
	IsExportedItemContext()
}

type ExportedItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportedItemContext() *ExportedItemContext {
	var p = new(ExportedItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
	return p
}

func InitEmptyExportedItemContext(p *ExportedItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
}

func (*ExportedItemContext) IsExportedItemContext() {}

func NewExportedItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportedItemContext {
	var p = new(ExportedItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportedItem

	return p
}

func (s *ExportedItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportedItemContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportedItemContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportedItemContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportedItemContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ExportedItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportedItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedItem(s)
	}
}

func (s *ExportedItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedItem(s)
	}
}

func (s *ExportedItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportedItem() (localctx IExportedItemContext) {
	localctx = NewExportedItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_exportedItem)
	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(266)
			p.FnDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(267)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(268)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(269)
			p.InterfaceDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleImportContext is an interface to support dynamic dispatch.
type IModuleImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DestructuredImport() IDestructuredImportContext
	TargetImport() ITargetImportContext

	// IsModuleImportContext differentiates from other interfaces.
	IsModuleImportContext()
}

type ModuleImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleImportContext() *ModuleImportContext {
	var p = new(ModuleImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
	return p
}

func InitEmptyModuleImportContext(p *ModuleImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
}

func (*ModuleImportContext) IsModuleImportContext() {}

func NewModuleImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleImportContext {
	var p = new(ModuleImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_moduleImport

	return p
}

func (s *ModuleImportContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleImportContext) DestructuredImport() IDestructuredImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestructuredImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestructuredImportContext)
}

func (s *ModuleImportContext) TargetImport() ITargetImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetImportContext)
}

func (s *ModuleImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterModuleImport(s)
	}
}

func (s *ModuleImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitModuleImport(s)
	}
}

func (s *ModuleImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitModuleImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ModuleImport() (localctx IModuleImportContext) {
	localctx = NewModuleImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_moduleImport)
	p.SetState(274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.DestructuredImport()
		}

	case ManuscriptID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.TargetImport()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestructuredImportContext is an interface to support dynamic dispatch.
type IDestructuredImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext
	ImportItemList() IImportItemListContext

	// IsDestructuredImportContext differentiates from other interfaces.
	IsDestructuredImportContext()
}

type DestructuredImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestructuredImportContext() *DestructuredImportContext {
	var p = new(DestructuredImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
	return p
}

func InitEmptyDestructuredImportContext(p *DestructuredImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
}

func (*DestructuredImportContext) IsDestructuredImportContext() {}

func NewDestructuredImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestructuredImportContext {
	var p = new(DestructuredImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_destructuredImport

	return p
}

func (s *DestructuredImportContext) GetParser() antlr.Parser { return s.parser }

func (s *DestructuredImportContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *DestructuredImportContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *DestructuredImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *DestructuredImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *DestructuredImportContext) ImportItemList() IImportItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemListContext)
}

func (s *DestructuredImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestructuredImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestructuredImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDestructuredImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DestructuredImport() (localctx IDestructuredImportContext) {
	localctx = NewDestructuredImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_destructuredImport)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(277)
			p.ImportItemList()
		}

	}
	{
		p.SetState(280)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(282)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetImportContext is an interface to support dynamic dispatch.
type ITargetImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext

	// IsTargetImportContext differentiates from other interfaces.
	IsTargetImportContext()
}

type TargetImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetImportContext() *TargetImportContext {
	var p = new(TargetImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
	return p
}

func InitEmptyTargetImportContext(p *TargetImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
}

func (*TargetImportContext) IsTargetImportContext() {}

func NewTargetImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetImportContext {
	var p = new(TargetImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_targetImport

	return p
}

func (s *TargetImportContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetImportContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TargetImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *TargetImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *TargetImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTargetImport(s)
	}
}

func (s *TargetImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTargetImport(s)
	}
}

func (s *TargetImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTargetImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TargetImport() (localctx ITargetImportContext) {
	localctx = NewTargetImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_targetImport)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(285)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(286)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemListContext is an interface to support dynamic dispatch.
type IImportItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportItem() []IImportItemContext
	ImportItem(i int) IImportItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportItemListContext differentiates from other interfaces.
	IsImportItemListContext()
}

type ImportItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemListContext() *ImportItemListContext {
	var p = new(ImportItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
	return p
}

func InitEmptyImportItemListContext(p *ImportItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
}

func (*ImportItemListContext) IsImportItemListContext() {}

func NewImportItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemListContext {
	var p = new(ImportItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItemList

	return p
}

func (s *ImportItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemListContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *ImportItemListContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *ImportItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ImportItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ImportItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItemList(s)
	}
}

func (s *ImportItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItemList(s)
	}
}

func (s *ImportItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItemList() (localctx IImportItemListContext) {
	localctx = NewImportItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_importItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.ImportItem()
	}
	p.SetState(293)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(289)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(290)
				p.ImportItem()
			}

		}
		p.SetState(295)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(296)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(300)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(301)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) CopyAll(ctx *LetDeclContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLetDeclDestructuredObjContext struct {
	LetDeclContext
}

func NewLabelLetDeclDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetDeclDestructuredObjContext {
	var p = new(LabelLetDeclDestructuredObjContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LabelLetDeclDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetDeclDestructuredObjContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LabelLetDeclDestructuredObjContext) LetDestructuredObj() ILetDestructuredObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredObjContext)
}

func (s *LabelLetDeclDestructuredObjContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelLetDeclDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetDeclDestructuredObj(s)
	}
}

func (s *LabelLetDeclDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetDeclDestructuredObj(s)
	}
}

func (s *LabelLetDeclDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetDeclDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetDeclBlockContext struct {
	LetDeclContext
}

func NewLabelLetDeclBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetDeclBlockContext {
	var p = new(LabelLetDeclBlockContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LabelLetDeclBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetDeclBlockContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LabelLetDeclBlockContext) LetBlock() ILetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockContext)
}

func (s *LabelLetDeclBlockContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelLetDeclBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetDeclBlock(s)
	}
}

func (s *LabelLetDeclBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetDeclBlock(s)
	}
}

func (s *LabelLetDeclBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetDeclBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetDeclDestructuredArrayContext struct {
	LetDeclContext
}

func NewLabelLetDeclDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetDeclDestructuredArrayContext {
	var p = new(LabelLetDeclDestructuredArrayContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LabelLetDeclDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetDeclDestructuredArrayContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LabelLetDeclDestructuredArrayContext) LetDestructuredArray() ILetDestructuredArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredArrayContext)
}

func (s *LabelLetDeclDestructuredArrayContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelLetDeclDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetDeclDestructuredArray(s)
	}
}

func (s *LabelLetDeclDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetDeclDestructuredArray(s)
	}
}

func (s *LabelLetDeclDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetDeclDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetDeclSingleContext struct {
	LetDeclContext
}

func NewLabelLetDeclSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetDeclSingleContext {
	var p = new(LabelLetDeclSingleContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LabelLetDeclSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetDeclSingleContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LabelLetDeclSingleContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LabelLetDeclSingleContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelLetDeclSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetDeclSingle(s)
	}
}

func (s *LabelLetDeclSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetDeclSingle(s)
	}
}

func (s *LabelLetDeclSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetDeclSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_letDecl)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelLetDeclSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(304)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(305)
			p.LetSingle()
		}
		p.SetState(307)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(306)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewLabelLetDeclBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(309)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(310)
			p.LetBlock()
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(311)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewLabelLetDeclDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(314)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(315)
			p.LetDestructuredObj()
		}
		p.SetState(317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(316)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewLabelLetDeclDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(319)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(320)
			p.LetDestructuredArray()
		}
		p.SetState(322)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(321)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetSingleContext is an interface to support dynamic dispatch.
type ILetSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedID() ITypedIDContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetSingleContext differentiates from other interfaces.
	IsLetSingleContext()
}

type LetSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetSingleContext() *LetSingleContext {
	var p = new(LetSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
	return p
}

func InitEmptyLetSingleContext(p *LetSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
}

func (*LetSingleContext) IsLetSingleContext() {}

func NewLetSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetSingleContext {
	var p = new(LetSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letSingle

	return p
}

func (s *LetSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LetSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetSingle(s)
	}
}

func (s *LetSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetSingle(s)
	}
}

func (s *LetSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetSingle() (localctx ILetSingleContext) {
	localctx = NewLetSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_letSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(326)
		p.TypedID()
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(327)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(328)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockContext is an interface to support dynamic dispatch.
type ILetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LetBlockItemList() ILetBlockItemListContext

	// IsLetBlockContext differentiates from other interfaces.
	IsLetBlockContext()
}

type LetBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockContext() *LetBlockContext {
	var p = new(LetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
	return p
}

func InitEmptyLetBlockContext(p *LetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
}

func (*LetBlockContext) IsLetBlockContext() {}

func NewLetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockContext {
	var p = new(LetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlock

	return p
}

func (s *LetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LetBlockContext) LetBlockItemList() ILetBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemListContext)
}

func (s *LetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlock(s)
	}
}

func (s *LetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlock(s)
	}
}

func (s *LetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlock() (localctx ILetBlockContext) {
	localctx = NewLetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_letBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6760896999194626) != 0) || _la == ManuscriptID {
		{
			p.SetState(332)
			p.LetBlockItemList()
		}

	}
	{
		p.SetState(335)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemListContext is an interface to support dynamic dispatch.
type ILetBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetBlockItem() []ILetBlockItemContext
	LetBlockItem(i int) ILetBlockItemContext
	AllLetBlockItemSep() []ILetBlockItemSepContext
	LetBlockItemSep(i int) ILetBlockItemSepContext

	// IsLetBlockItemListContext differentiates from other interfaces.
	IsLetBlockItemListContext()
}

type LetBlockItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemListContext() *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
	return p
}

func InitEmptyLetBlockItemListContext(p *LetBlockItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
}

func (*LetBlockItemListContext) IsLetBlockItemListContext() {}

func NewLetBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemList

	return p
}

func (s *LetBlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemListContext) AllLetBlockItem() []ILetBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemContext); ok {
			tst[i] = t.(ILetBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItem(i int) ILetBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemContext)
}

func (s *LetBlockItemListContext) AllLetBlockItemSep() []ILetBlockItemSepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemSepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemSepContext); ok {
			tst[i] = t.(ILetBlockItemSepContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItemSep(i int) ILetBlockItemSepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemSepContext)
}

func (s *LetBlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemList() (localctx ILetBlockItemListContext) {
	localctx = NewLetBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_letBlockItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(337)
			p.LetBlockItemSep()
		}

		p.SetState(342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(343)
		p.LetBlockItem()
	}
	p.SetState(353)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(345)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0) {
				{
					p.SetState(344)
					p.LetBlockItemSep()
				}

				p.SetState(347)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(349)
				p.LetBlockItem()
			}

		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(356)
			p.LetBlockItemSep()
		}

		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemSepContext is an interface to support dynamic dispatch.
type ILetBlockItemSepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	Stmt_sep() IStmt_sepContext

	// IsLetBlockItemSepContext differentiates from other interfaces.
	IsLetBlockItemSepContext()
}

type LetBlockItemSepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemSepContext() *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
	return p
}

func InitEmptyLetBlockItemSepContext(p *LetBlockItemSepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
}

func (*LetBlockItemSepContext) IsLetBlockItemSepContext() {}

func NewLetBlockItemSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemSep

	return p
}

func (s *LetBlockItemSepContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemSepContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LetBlockItemSepContext) Stmt_sep() IStmt_sepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LetBlockItemSepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemSepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemSep() (localctx ILetBlockItemSepContext) {
	localctx = NewLetBlockItemSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_letBlockItemSep)
	p.SetState(364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(362)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptNEWLINE, ManuscriptSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(363)
			p.Stmt_sep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemContext is an interface to support dynamic dispatch.
type ILetBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetBlockItemContext differentiates from other interfaces.
	IsLetBlockItemContext()
}

type LetBlockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemContext() *LetBlockItemContext {
	var p = new(LetBlockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
	return p
}

func InitEmptyLetBlockItemContext(p *LetBlockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
}

func (*LetBlockItemContext) IsLetBlockItemContext() {}

func NewLetBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemContext {
	var p = new(LetBlockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItem

	return p
}

func (s *LetBlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemContext) CopyAll(ctx *LetBlockItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetBlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLetBlockItemDestructuredObjContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemDestructuredObjContext {
	var p = new(LabelLetBlockItemDestructuredObjContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LabelLetBlockItemDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemDestructuredObj(s)
	}
}

func (s *LabelLetBlockItemDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemDestructuredObj(s)
	}
}

func (s *LabelLetBlockItemDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetBlockItemDestructuredArrayContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemDestructuredArrayContext {
	var p = new(LabelLetBlockItemDestructuredArrayContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LabelLetBlockItemDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemDestructuredArray(s)
	}
}

func (s *LabelLetBlockItemDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemDestructuredArray(s)
	}
}

func (s *LabelLetBlockItemDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetBlockItemSingleContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemSingleContext {
	var p = new(LabelLetBlockItemSingleContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LabelLetBlockItemSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItem() (localctx ILetBlockItemContext) {
	localctx = NewLetBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_letBlockItem)
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelLetBlockItemSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(366)
			p.TypedID()
		}
		{
			p.SetState(367)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(368)
			p.Expr()
		}

	case ManuscriptLBRACE:
		localctx = NewLabelLetBlockItemDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(370)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.TypedIDList()
		}
		{
			p.SetState(372)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(373)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.Expr()
		}

	case ManuscriptLSQBR:
		localctx = NewLabelLetBlockItemDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(376)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.TypedIDList()
		}
		{
			p.SetState(378)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(379)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.Expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredObjContext is an interface to support dynamic dispatch.
type ILetDestructuredObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RBRACE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredObjContext differentiates from other interfaces.
	IsLetDestructuredObjContext()
}

type LetDestructuredObjContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredObjContext() *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
	return p
}

func InitEmptyLetDestructuredObjContext(p *LetDestructuredObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
}

func (*LetDestructuredObjContext) IsLetDestructuredObjContext() {}

func NewLetDestructuredObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredObj

	return p
}

func (s *LetDestructuredObjContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredObj() (localctx ILetDestructuredObjContext) {
	localctx = NewLetDestructuredObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_letDestructuredObj)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(385)
		p.TypedIDList()
	}
	{
		p.SetState(386)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredArrayContext is an interface to support dynamic dispatch.
type ILetDestructuredArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RSQBR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredArrayContext differentiates from other interfaces.
	IsLetDestructuredArrayContext()
}

type LetDestructuredArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredArrayContext() *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
	return p
}

func InitEmptyLetDestructuredArrayContext(p *LetDestructuredArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
}

func (*LetDestructuredArrayContext) IsLetDestructuredArrayContext() {}

func NewLetDestructuredArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredArray

	return p
}

func (s *LetDestructuredArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredArray() (localctx ILetDestructuredArrayContext) {
	localctx = NewLetDestructuredArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_letDestructuredArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(390)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(391)
		p.TypedIDList()
	}
	{
		p.SetState(392)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(393)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDListContext is an interface to support dynamic dispatch.
type ITypedIDListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedID() []ITypedIDContext
	TypedID(i int) ITypedIDContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedIDListContext differentiates from other interfaces.
	IsTypedIDListContext()
}

type TypedIDListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDListContext() *TypedIDListContext {
	var p = new(TypedIDListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
	return p
}

func InitEmptyTypedIDListContext(p *TypedIDListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
}

func (*TypedIDListContext) IsTypedIDListContext() {}

func NewTypedIDListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDListContext {
	var p = new(TypedIDListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedIDList

	return p
}

func (s *TypedIDListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDListContext) AllTypedID() []ITypedIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIDContext); ok {
			len++
		}
	}

	tst := make([]ITypedIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIDContext); ok {
			tst[i] = t.(ITypedIDContext)
			i++
		}
	}

	return tst
}

func (s *TypedIDListContext) TypedID(i int) ITypedIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *TypedIDListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypedIDListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypedIDListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedIDList(s)
	}
}

func (s *TypedIDListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedIDList(s)
	}
}

func (s *TypedIDListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedIDList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedIDList() (localctx ITypedIDListContext) {
	localctx = NewTypedIDListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_typedIDList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.TypedID()
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(397)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(398)
				p.TypedID()
			}

		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(404)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDContext is an interface to support dynamic dispatch.
type ITypedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsTypedIDContext differentiates from other interfaces.
	IsTypedIDContext()
}

type TypedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDContext() *TypedIDContext {
	var p = new(TypedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
	return p
}

func InitEmptyTypedIDContext(p *TypedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
}

func (*TypedIDContext) IsTypedIDContext() {}

func NewTypedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDContext {
	var p = new(TypedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedID

	return p
}

func (s *TypedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypedIDContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedID(s)
	}
}

func (s *TypedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedID(s)
	}
}

func (s *TypedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedID() (localctx ITypedIDContext) {
	localctx = NewTypedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_typedID)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(407)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(408)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	ID() antlr.TerminalNode
	TypeDefBody() ITypeDefBodyContext
	TypeAlias() ITypeAliasContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeDeclContext) TypeDefBody() ITypeDefBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefBodyContext)
}

func (s *TypeDeclContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_typeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(411)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(412)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEXTENDS, ManuscriptLBRACE:
		{
			p.SetState(413)
			p.TypeDefBody()
		}

	case ManuscriptEQUALS:
		{
			p.SetState(414)
			p.TypeAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefBodyContext is an interface to support dynamic dispatch.
type ITypeDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDefBodyContext differentiates from other interfaces.
	IsTypeDefBodyContext()
}

type TypeDefBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefBodyContext() *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
	return p
}

func InitEmptyTypeDefBodyContext(p *TypeDefBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
}

func (*TypeDefBodyContext) IsTypeDefBodyContext() {}

func NewTypeDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDefBody

	return p
}

func (s *TypeDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDefBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDefBodyContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDefBodyContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeDefBodyContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDefBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *TypeDefBodyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDefBodyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDefBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDefBody() (localctx ITypeDefBodyContext) {
	localctx = NewTypeDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_typeDefBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(417)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(418)
			p.TypeList()
		}

	}
	{
		p.SetState(421)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(422)
				p.Stmt_sep()
			}

			p.SetState(427)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(428)
			p.FieldDecl()
		}
		p.SetState(445)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(432)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(429)
						p.Stmt_sep()
					}

					p.SetState(434)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(435)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(439)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(436)
						p.Stmt_sep()
					}

					p.SetState(441)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(442)
					p.FieldDecl()
				}

			}
			p.SetState(447)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			p.SetState(451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(448)
					p.Stmt_sep()
				}

				p.SetState(453)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(454)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(460)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(457)
				p.Stmt_sep()
			}

			p.SetState(462)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(465)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *TypeAliasContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAliasContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeAliasContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(468)
		p.TypeAnnotation()
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(469)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(470)
			p.TypeList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(473)
		p.FieldDecl()
	}
	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(474)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(475)
				p.FieldDecl()
			}

		}
		p.SetState(480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(482)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(481)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(485)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(488)
		p.TypeAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(490)
		p.TypeAnnotation()
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(491)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(492)
				p.TypeAnnotation()
			}

		}
		p.SetState(497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(498)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *InterfaceDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *InterfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *InterfaceDeclContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceDeclContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_interfaceDecl)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(501)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(502)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(503)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)
			p.TypeList()
		}

	}
	{
		p.SetState(507)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(511)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(508)
				p.Stmt_sep()
			}

			p.SetState(513)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(514)
			p.InterfaceMethod()
		}
		p.SetState(518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(515)
					p.Stmt_sep()
				}

			}
			p.SetState(520)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 49, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(523)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(525)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *InterfaceMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *InterfaceMethodContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *InterfaceMethodContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *InterfaceMethodContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(527)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(528)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(529)
			p.Parameters()
		}

	}
	{
		p.SetState(532)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(533)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(536)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnSignature() IFnSignatureContext
	CodeBlock() ICodeBlockContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_fnDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.FnSignature()
	}
	{
		p.SetState(540)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnSignatureContext is an interface to support dynamic dispatch.
type IFnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsFnSignatureContext differentiates from other interfaces.
	IsFnSignatureContext()
}

type FnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnSignatureContext() *FnSignatureContext {
	var p = new(FnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
	return p
}

func InitEmptyFnSignatureContext(p *FnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
}

func (*FnSignatureContext) IsFnSignatureContext() {}

func NewFnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnSignatureContext {
	var p = new(FnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnSignature

	return p
}

func (s *FnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FnSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnSignatureContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FnSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnSignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnSignatureContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnSignature(s)
	}
}

func (s *FnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnSignature(s)
	}
}

func (s *FnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnSignature() (localctx IFnSignatureContext) {
	localctx = NewFnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_fnSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(542)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(543)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(544)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(545)
			p.Parameters()
		}

	}
	{
		p.SetState(548)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(549)
			p.TypeAnnotation()
		}

	}
	p.SetState(553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(552)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(555)
		p.Param()
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(556)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(557)
				p.Param()
			}

		}
		p.SetState(562)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(563)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(567)
		p.TypeAnnotation()
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(568)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(569)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodsDeclContext is an interface to support dynamic dispatch.
type IMethodsDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	METHODS() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MethodImplList() IMethodImplListContext

	// IsMethodsDeclContext differentiates from other interfaces.
	IsMethodsDeclContext()
}

type MethodsDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodsDeclContext() *MethodsDeclContext {
	var p = new(MethodsDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
	return p
}

func InitEmptyMethodsDeclContext(p *MethodsDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
}

func (*MethodsDeclContext) IsMethodsDeclContext() {}

func NewMethodsDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodsDeclContext {
	var p = new(MethodsDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodsDecl

	return p
}

func (s *MethodsDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodsDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodsDeclContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *MethodsDeclContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *MethodsDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *MethodsDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodsDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodsDeclContext) MethodImplList() IMethodImplListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplListContext)
}

func (s *MethodsDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodsDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodsDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodsDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodsDecl() (localctx IMethodsDeclContext) {
	localctx = NewMethodsDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_methodsDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(572)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(574)
		p.Match(ManuscriptAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(575)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(576)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		{
			p.SetState(577)
			p.MethodImplList()
		}

	}
	{
		p.SetState(580)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplListContext is an interface to support dynamic dispatch.
type IMethodImplListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsMethodImplListContext differentiates from other interfaces.
	IsMethodImplListContext()
}

type MethodImplListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplListContext() *MethodImplListContext {
	var p = new(MethodImplListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
	return p
}

func InitEmptyMethodImplListContext(p *MethodImplListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
}

func (*MethodImplListContext) IsMethodImplListContext() {}

func NewMethodImplListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplListContext {
	var p = new(MethodImplListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImplList

	return p
}

func (s *MethodImplListContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplListContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodImplListContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MethodImplListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImplList(s)
	}
}

func (s *MethodImplListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImplList(s)
	}
}

func (s *MethodImplListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImplList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImplList() (localctx IMethodImplListContext) {
	localctx = NewMethodImplListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_methodImplList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(582)
			p.Stmt_sep()
		}

		p.SetState(587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(588)
		p.MethodImpl()
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(590)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(589)
					p.Stmt_sep()
				}

				p.SetState(592)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(594)
				p.MethodImpl()
			}

		}
		p.SetState(600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(601)
			p.Stmt_sep()
		}

		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceMethod() IInterfaceMethodContext
	CodeBlock() ICodeBlockContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) InterfaceMethod() IInterfaceMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_methodImpl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.InterfaceMethod()
	}
	{
		p.SetState(608)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyAll(ctx *StmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelStmtLetContext struct {
	StmtContext
}

func NewLabelStmtLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtLetContext {
	var p = new(LabelStmtLetContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *LabelStmtLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtIfContext struct {
	StmtContext
}

func NewLabelStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtIfContext {
	var p = new(LabelStmtIfContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtIfContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *LabelStmtIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtDeferContext struct {
	StmtContext
}

func NewLabelStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtDeferContext {
	var p = new(LabelStmtDeferContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtDeferContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *LabelStmtDeferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtExprContext struct {
	StmtContext
}

func NewLabelStmtExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtExprContext {
	var p = new(LabelStmtExprContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelStmtExprContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelStmtExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtReturnContext struct {
	StmtContext
}

func NewLabelStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtReturnContext {
	var p = new(LabelStmtReturnContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtReturnContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *LabelStmtReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtForContext struct {
	StmtContext
}

func NewLabelStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtForContext {
	var p = new(LabelStmtForContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtForContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *LabelStmtForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtWhileContext struct {
	StmtContext
}

func NewLabelStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtWhileContext {
	var p = new(LabelStmtWhileContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtWhileContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *LabelStmtWhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtContinueContext struct {
	StmtContext
}

func NewLabelStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtContinueContext {
	var p = new(LabelStmtContinueContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtContinueContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *LabelStmtContinueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBlockContext struct {
	StmtContext
}

func NewLabelStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBlockContext {
	var p = new(LabelStmtBlockContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LabelStmtBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtCheckContext struct {
	StmtContext
}

func NewLabelStmtCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtCheckContext {
	var p = new(LabelStmtCheckContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtCheckContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *LabelStmtCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBreakContext struct {
	StmtContext
}

func NewLabelStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBreakContext {
	var p = new(LabelStmtBreakContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBreakContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *LabelStmtBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtYieldContext struct {
	StmtContext
}

func NewLabelStmtYieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtYieldContext {
	var p = new(LabelStmtYieldContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtYieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtYieldContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *LabelStmtYieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtYield(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_stmt)
	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelStmtLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(610)
			p.LetDecl()
		}

	case 2:
		localctx = NewLabelStmtExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(611)
			p.Expr()
		}
		p.SetState(613)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(612)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewLabelStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(615)
			p.ReturnStmt()
		}

	case 4:
		localctx = NewLabelStmtYieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(616)
			p.YieldStmt()
		}

	case 5:
		localctx = NewLabelStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(617)
			p.IfStmt()
		}

	case 6:
		localctx = NewLabelStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(618)
			p.ForStmt()
		}

	case 7:
		localctx = NewLabelStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(619)
			p.WhileStmt()
		}

	case 8:
		localctx = NewLabelStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(620)
			p.CodeBlock()
		}

	case 9:
		localctx = NewLabelStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(621)
			p.BreakStmt()
		}

	case 10:
		localctx = NewLabelStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(622)
			p.ContinueStmt()
		}

	case 11:
		localctx = NewLabelStmtCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(623)
			p.CheckStmt()
		}

	case 12:
		localctx = NewLabelStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(624)
			p.DeferStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ReturnStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_returnStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(627)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(628)
			p.ExprList()
		}

	}
	p.SetState(632)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(631)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *YieldStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_yieldStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(634)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(636)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(635)
			p.ExprList()
		}

	}
	p.SetState(639)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(638)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFER, 0)
}

func (s *DeferStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeferStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(ManuscriptDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(642)
		p.Expr()
	}
	p.SetState(644)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(643)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.Expr()
	}
	p.SetState(651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(647)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(648)
				p.Expr()
			}

		}
		p.SetState(653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(654)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(658)
		p.Expr()
	}
	{
		p.SetState(659)
		p.CodeBlock()
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(660)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)
			p.CodeBlock()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	ForLoopType() IForLoopTypeContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) ForLoopType() IForLoopTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForLoopTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForLoopTypeContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(665)
		p.ForLoopType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForLoopTypeContext is an interface to support dynamic dispatch.
type IForLoopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForLoopTypeContext differentiates from other interfaces.
	IsForLoopTypeContext()
}

type ForLoopTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopTypeContext() *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
	return p
}

func InitEmptyForLoopTypeContext(p *ForLoopTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
}

func (*ForLoopTypeContext) IsForLoopTypeContext() {}

func NewForLoopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forLoopType

	return p
}

func (s *ForLoopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopTypeContext) CopyAll(ctx *ForLoopTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForLoopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForLoopContext {
	var p = new(LabelForLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForLoopContext) ForTrinity() IForTrinityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForTrinityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForTrinityContext)
}

func (s *LabelForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForInLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInLoopContext {
	var p = new(LabelForInLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForInLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInLoopContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *LabelForInLoopContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForInLoopContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *LabelForInLoopContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *LabelForInLoopContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *LabelForInLoopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LabelForInLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForLoopType() (localctx IForLoopTypeContext) {
	localctx = NewForLoopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_forLoopType)
	var _la int

	p.SetState(677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.ForTrinity()
		}

	case 2:
		localctx = NewLabelForInLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(668)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(669)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(670)
				p.Match(ManuscriptID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(673)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(674)
			p.Expr()
		}
		{
			p.SetState(675)
			p.LoopBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForTrinityContext is an interface to support dynamic dispatch.
type IForTrinityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForInit() IForInitContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	ForCond() IForCondContext
	ForPost() IForPostContext
	LoopBody() ILoopBodyContext

	// IsForTrinityContext differentiates from other interfaces.
	IsForTrinityContext()
}

type ForTrinityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForTrinityContext() *ForTrinityContext {
	var p = new(ForTrinityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
	return p
}

func InitEmptyForTrinityContext(p *ForTrinityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
}

func (*ForTrinityContext) IsForTrinityContext() {}

func NewForTrinityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForTrinityContext {
	var p = new(ForTrinityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forTrinity

	return p
}

func (s *ForTrinityContext) GetParser() antlr.Parser { return s.parser }

func (s *ForTrinityContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForTrinityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForTrinityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForTrinityContext) ForCond() IForCondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForCondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForCondContext)
}

func (s *ForTrinityContext) ForPost() IForPostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForPostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForPostContext)
}

func (s *ForTrinityContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForTrinityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForTrinityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForTrinityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForTrinity(s)
	}
}

func (s *ForTrinityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForTrinity(s)
	}
}

func (s *ForTrinityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForTrinity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForTrinity() (localctx IForTrinityContext) {
	localctx = NewForTrinityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_forTrinity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		p.ForInit()
	}
	{
		p.SetState(680)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(681)
		p.ForCond()
	}
	{
		p.SetState(682)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(683)
		p.ForPost()
	}
	{
		p.SetState(684)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) CopyAll(ctx *ForInitContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForInitLetContext struct {
	ForInitContext
}

func NewLabelForInitLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitLetContext {
	var p = new(LabelForInitLetContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitLetContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LabelForInitLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInitEmptyContext struct {
	ForInitContext
}

func NewLabelForInitEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitEmptyContext {
	var p = new(LabelForInitEmptyContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_forInit)
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelForInitLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(686)
			p.LetSingle()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForInitEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForCondContext is an interface to support dynamic dispatch.
type IForCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForCondContext differentiates from other interfaces.
	IsForCondContext()
}

type ForCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForCondContext() *ForCondContext {
	var p = new(ForCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
	return p
}

func InitEmptyForCondContext(p *ForCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
}

func (*ForCondContext) IsForCondContext() {}

func NewForCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForCondContext {
	var p = new(ForCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forCond

	return p
}

func (s *ForCondContext) GetParser() antlr.Parser { return s.parser }

func (s *ForCondContext) CopyAll(ctx *ForCondContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForCondEmptyContext struct {
	ForCondContext
}

func NewLabelForCondEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondEmptyContext {
	var p = new(LabelForCondEmptyContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForCondExprContext struct {
	ForCondContext
}

func NewLabelForCondExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondExprContext {
	var p = new(LabelForCondExprContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForCondExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForCond() (localctx IForCondContext) {
	localctx = NewForCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_forCond)
	p.SetState(692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN, ManuscriptVOID, ManuscriptTRY, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptASYNC, ManuscriptAWAIT, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelForCondExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)
			p.Expr()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForCondEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForPostContext is an interface to support dynamic dispatch.
type IForPostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForPostContext differentiates from other interfaces.
	IsForPostContext()
}

type ForPostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForPostContext() *ForPostContext {
	var p = new(ForPostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
	return p
}

func InitEmptyForPostContext(p *ForPostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
}

func (*ForPostContext) IsForPostContext() {}

func NewForPostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForPostContext {
	var p = new(ForPostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forPost

	return p
}

func (s *ForPostContext) GetParser() antlr.Parser { return s.parser }

func (s *ForPostContext) CopyAll(ctx *ForPostContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForPostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForPostExprContext struct {
	ForPostContext
}

func NewLabelForPostExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostExprContext {
	var p = new(LabelForPostExprContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForPostExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForPostEmptyContext struct {
	ForPostContext
}

func NewLabelForPostEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostEmptyContext {
	var p = new(LabelForPostEmptyContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForPost() (localctx IForPostContext) {
	localctx = NewForPostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_forPost)
	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForPostExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(694)
			p.Expr()
		}

	case 2:
		localctx = NewLabelForPostEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	LoopBody() ILoopBodyContext

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(699)
		p.Expr()
	}
	{
		p.SetState(700)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBodyContext is an interface to support dynamic dispatch.
type ILoopBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsLoopBodyContext differentiates from other interfaces.
	IsLoopBodyContext()
}

type LoopBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopBodyContext() *LoopBodyContext {
	var p = new(LoopBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
	return p
}

func InitEmptyLoopBodyContext(p *LoopBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
}

func (*LoopBodyContext) IsLoopBodyContext() {}

func NewLoopBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBodyContext {
	var p = new(LoopBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopBody

	return p
}

func (s *LoopBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LoopBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LoopBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LoopBodyContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *LoopBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopBody(s)
	}
}

func (s *LoopBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopBody(s)
	}
}

func (s *LoopBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopBody() (localctx ILoopBodyContext) {
	localctx = NewLoopBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_loopBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(703)
				p.Stmt_sep()
			}

		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180242492932576) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(709)
			p.Stmt()
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(711)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(710)
						p.Stmt_sep()
					}

					p.SetState(713)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(715)
					p.Stmt()
				}

			}
			p.SetState(721)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(727)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(724)
			p.Stmt_sep()
		}

		p.SetState(729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(730)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_codeBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(733)
				p.Stmt_sep()
			}

		}
		p.SetState(738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(752)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180242492932576) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(739)
			p.Stmt()
		}
		p.SetState(749)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(741)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(740)
						p.Stmt_sep()
					}

					p.SetState(743)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(745)
					p.Stmt()
				}

			}
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(754)
			p.Stmt_sep()
		}

		p.SetState(759)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(760)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ManuscriptBREAK, 0)
}

func (s *BreakStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(762)
		p.Match(ManuscriptBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(763)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCONTINUE, 0)
}

func (s *ContinueStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(ManuscriptCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(768)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(767)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	SEMICOLON() antlr.TerminalNode

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *CheckStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *CheckStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CheckStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (s *CheckStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCheckStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_checkStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.Match(ManuscriptCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(771)
		p.Expr()
	}
	{
		p.SetState(772)
		p.Match(ManuscriptCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(773)
		p.StringLiteral()
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(774)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() ITernaryExprContext

	// GetOp returns the op rule contexts.
	GetOp() IAssignmentOpContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ITernaryExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IAssignmentOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	TernaryExpr() ITernaryExprContext
	AssignmentOp() IAssignmentOpContext
	AssignmentExpr() IAssignmentExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ITernaryExprContext
	op     IAssignmentOpContext
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetLeft() ITernaryExprContext { return s.left }

func (s *AssignmentExprContext) GetOp() IAssignmentOpContext { return s.op }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ITernaryExprContext) { s.left = v }

func (s *AssignmentExprContext) SetOp(v IAssignmentOpContext) { s.op = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *AssignmentExprContext) AssignmentOp() IAssignmentOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOpContext)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_assignmentExpr)
	p.SetState(784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(779)
			p.TernaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(780)

			var _x = p.TernaryExpr()

			localctx.(*AssignmentExprContext).left = _x
		}
		{
			p.SetState(781)

			var _x = p.AssignmentOp()

			localctx.(*AssignmentExprContext).op = _x
		}
		{
			p.SetState(782)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOpContext is an interface to support dynamic dispatch.
type IAssignmentOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAssignmentOpContext differentiates from other interfaces.
	IsAssignmentOpContext()
}

type AssignmentOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOpContext() *AssignmentOpContext {
	var p = new(AssignmentOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
	return p
}

func InitEmptyAssignmentOpContext(p *AssignmentOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
}

func (*AssignmentOpContext) IsAssignmentOpContext() {}

func NewAssignmentOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOpContext {
	var p = new(AssignmentOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentOp

	return p
}

func (s *AssignmentOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOpContext) CopyAll(ctx *AssignmentOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AssignmentOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelAssignCaretEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignCaretEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignCaretEqContext {
	var p = new(LabelAssignCaretEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignCaretEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignCaretEqContext) CARET_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET_EQUALS, 0)
}

func (s *LabelAssignCaretEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignCaretEq(s)
	}
}

func (s *LabelAssignCaretEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignCaretEq(s)
	}
}

func (s *LabelAssignCaretEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignCaretEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignEqContext {
	var p = new(LabelAssignEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignEqContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelAssignEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignEq(s)
	}
}

func (s *LabelAssignEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignEq(s)
	}
}

func (s *LabelAssignEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignMinusEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignMinusEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignMinusEqContext {
	var p = new(LabelAssignMinusEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignMinusEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignMinusEqContext) MINUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS_EQUALS, 0)
}

func (s *LabelAssignMinusEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignMinusEq(s)
	}
}

func (s *LabelAssignMinusEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignMinusEq(s)
	}
}

func (s *LabelAssignMinusEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignMinusEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignModEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignModEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignModEqContext {
	var p = new(LabelAssignModEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignModEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignModEqContext) MOD_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD_EQUALS, 0)
}

func (s *LabelAssignModEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignModEq(s)
	}
}

func (s *LabelAssignModEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignModEq(s)
	}
}

func (s *LabelAssignModEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignModEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignStarEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignStarEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignStarEqContext {
	var p = new(LabelAssignStarEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignStarEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignStarEqContext) STAR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR_EQUALS, 0)
}

func (s *LabelAssignStarEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignStarEq(s)
	}
}

func (s *LabelAssignStarEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignStarEq(s)
	}
}

func (s *LabelAssignStarEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignStarEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignPlusEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignPlusEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignPlusEqContext {
	var p = new(LabelAssignPlusEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignPlusEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignPlusEqContext) PLUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS_EQUALS, 0)
}

func (s *LabelAssignPlusEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignPlusEq(s)
	}
}

func (s *LabelAssignPlusEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignPlusEq(s)
	}
}

func (s *LabelAssignPlusEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignPlusEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelAssignSlashEqContext struct {
	AssignmentOpContext
}

func NewLabelAssignSlashEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelAssignSlashEqContext {
	var p = new(LabelAssignSlashEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *LabelAssignSlashEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelAssignSlashEqContext) SLASH_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH_EQUALS, 0)
}

func (s *LabelAssignSlashEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelAssignSlashEq(s)
	}
}

func (s *LabelAssignSlashEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelAssignSlashEq(s)
	}
}

func (s *LabelAssignSlashEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelAssignSlashEq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentOp() (localctx IAssignmentOpContext) {
	localctx = NewAssignmentOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_assignmentOp)
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEQUALS:
		localctx = NewLabelAssignEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(786)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptPLUS_EQUALS:
		localctx = NewLabelAssignPlusEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(787)
			p.Match(ManuscriptPLUS_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMINUS_EQUALS:
		localctx = NewLabelAssignMinusEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(788)
			p.Match(ManuscriptMINUS_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSTAR_EQUALS:
		localctx = NewLabelAssignStarEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(789)
			p.Match(ManuscriptSTAR_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSLASH_EQUALS:
		localctx = NewLabelAssignSlashEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(790)
			p.Match(ManuscriptSLASH_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMOD_EQUALS:
		localctx = NewLabelAssignModEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(791)
			p.Match(ManuscriptMOD_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptCARET_EQUALS:
		localctx = NewLabelAssignCaretEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(792)
			p.Match(ManuscriptCARET_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExprContext is an interface to support dynamic dispatch.
type ITernaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCond returns the cond rule contexts.
	GetCond() ILogicalOrExprContext

	// GetThenBranch returns the thenBranch rule contexts.
	GetThenBranch() IExprContext

	// GetElseExpr returns the elseExpr rule contexts.
	GetElseExpr() ITernaryExprContext

	// SetCond sets the cond rule contexts.
	SetCond(ILogicalOrExprContext)

	// SetThenBranch sets the thenBranch rule contexts.
	SetThenBranch(IExprContext)

	// SetElseExpr sets the elseExpr rule contexts.
	SetElseExpr(ITernaryExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	TernaryExpr() ITernaryExprContext

	// IsTernaryExprContext differentiates from other interfaces.
	IsTernaryExprContext()
}

type TernaryExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	cond       ILogicalOrExprContext
	thenBranch IExprContext
	elseExpr   ITernaryExprContext
}

func NewEmptyTernaryExprContext() *TernaryExprContext {
	var p = new(TernaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
	return p
}

func InitEmptyTernaryExprContext(p *TernaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
}

func (*TernaryExprContext) IsTernaryExprContext() {}

func NewTernaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExprContext {
	var p = new(TernaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ternaryExpr

	return p
}

func (s *TernaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExprContext) GetCond() ILogicalOrExprContext { return s.cond }

func (s *TernaryExprContext) GetThenBranch() IExprContext { return s.thenBranch }

func (s *TernaryExprContext) GetElseExpr() ITernaryExprContext { return s.elseExpr }

func (s *TernaryExprContext) SetCond(v ILogicalOrExprContext) { s.cond = v }

func (s *TernaryExprContext) SetThenBranch(v IExprContext) { s.thenBranch = v }

func (s *TernaryExprContext) SetElseExpr(v ITernaryExprContext) { s.elseExpr = v }

func (s *TernaryExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *TernaryExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TernaryExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *TernaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TernaryExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TernaryExpr() (localctx ITernaryExprContext) {
	localctx = NewTernaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_ternaryExpr)
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(795)
			p.logicalOrExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(796)

			var _x = p.logicalOrExpr(0)

			localctx.(*TernaryExprContext).cond = _x
		}
		{
			p.SetState(797)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(798)

			var _x = p.Expr()

			localctx.(*TernaryExprContext).thenBranch = _x
		}
		{
			p.SetState(799)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(800)

			var _x = p.TernaryExpr()

			localctx.(*TernaryExprContext).elseExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	LogicalAndExpr() ILogicalAndExprContext
	LogicalOrExpr() ILogicalOrExprContext
	PIPE_PIPE() antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalOrExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalOrExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalOrExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *LogicalOrExprContext) PIPE_PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, 0)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	return p.logicalOrExpr(0)
}

func (p *Manuscript) logicalOrExpr(_p int) (localctx ILogicalOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 116
	p.EnterRecursionRule(localctx, 116, ManuscriptRULE_logicalOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(805)
		p.logicalAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalOrExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalOrExpr)
			p.SetState(807)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(808)

				var _m = p.Match(ManuscriptPIPE_PIPE)

				localctx.(*LogicalOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(809)

				var _x = p.logicalAndExpr(0)

				localctx.(*LogicalOrExprContext).right = _x
			}

		}
		p.SetState(814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseOrExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseOrExprContext)

	// Getter signatures
	BitwiseOrExpr() IBitwiseOrExprContext
	LogicalAndExpr() ILogicalAndExprContext
	AMP_AMP() antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  IBitwiseOrExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IBitwiseOrExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IBitwiseOrExprContext) { s.right = v }

func (s *LogicalAndExprContext) BitwiseOrExpr() IBitwiseOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExprContext)
}

func (s *LogicalAndExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalAndExprContext) AMP_AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, 0)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	return p.logicalAndExpr(0)
}

func (p *Manuscript) logicalAndExpr(_p int) (localctx ILogicalAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 118
	p.EnterRecursionRule(localctx, 118, ManuscriptRULE_logicalAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(816)
		p.bitwiseOrExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalAndExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalAndExpr)
			p.SetState(818)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(819)

				var _m = p.Match(ManuscriptAMP_AMP)

				localctx.(*LogicalAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(820)

				var _x = p.bitwiseOrExpr(0)

				localctx.(*LogicalAndExprContext).right = _x
			}

		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseOrExprContext is an interface to support dynamic dispatch.
type IBitwiseOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseXorExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseXorExprContext)

	// Getter signatures
	BitwiseXorExpr() IBitwiseXorExprContext
	BitwiseOrExpr() IBitwiseOrExprContext
	PIPE() antlr.TerminalNode

	// IsBitwiseOrExprContext differentiates from other interfaces.
	IsBitwiseOrExprContext()
}

type BitwiseOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseOrExprContext
	op     antlr.Token
	right  IBitwiseXorExprContext
}

func NewEmptyBitwiseOrExprContext() *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
	return p
}

func InitEmptyBitwiseOrExprContext(p *BitwiseOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
}

func (*BitwiseOrExprContext) IsBitwiseOrExprContext() {}

func NewBitwiseOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr

	return p
}

func (s *BitwiseOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseOrExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrExprContext) GetLeft() IBitwiseOrExprContext { return s.left }

func (s *BitwiseOrExprContext) GetRight() IBitwiseXorExprContext { return s.right }

func (s *BitwiseOrExprContext) SetLeft(v IBitwiseOrExprContext) { s.left = v }

func (s *BitwiseOrExprContext) SetRight(v IBitwiseXorExprContext) { s.right = v }

func (s *BitwiseOrExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseOrExprContext) BitwiseOrExpr() IBitwiseOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExprContext)
}

func (s *BitwiseOrExprContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE, 0)
}

func (s *BitwiseOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseOrExpr() (localctx IBitwiseOrExprContext) {
	return p.bitwiseOrExpr(0)
}

func (p *Manuscript) bitwiseOrExpr(_p int) (localctx IBitwiseOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, ManuscriptRULE_bitwiseOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.bitwiseXorExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseOrExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseOrExpr)
			p.SetState(829)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(830)

				var _m = p.Match(ManuscriptPIPE)

				localctx.(*BitwiseOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(831)

				var _x = p.bitwiseXorExpr(0)

				localctx.(*BitwiseOrExprContext).right = _x
			}

		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseXorExprContext is an interface to support dynamic dispatch.
type IBitwiseXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseXorExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseXorExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseAndExprContext)

	// Getter signatures
	BitwiseAndExpr() IBitwiseAndExprContext
	BitwiseXorExpr() IBitwiseXorExprContext
	CARET() antlr.TerminalNode

	// IsBitwiseXorExprContext differentiates from other interfaces.
	IsBitwiseXorExprContext()
}

type BitwiseXorExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseXorExprContext
	op     antlr.Token
	right  IBitwiseAndExprContext
}

func NewEmptyBitwiseXorExprContext() *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
	return p
}

func InitEmptyBitwiseXorExprContext(p *BitwiseXorExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
}

func (*BitwiseXorExprContext) IsBitwiseXorExprContext() {}

func NewBitwiseXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr

	return p
}

func (s *BitwiseXorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExprContext) GetLeft() IBitwiseXorExprContext { return s.left }

func (s *BitwiseXorExprContext) GetRight() IBitwiseAndExprContext { return s.right }

func (s *BitwiseXorExprContext) SetLeft(v IBitwiseXorExprContext) { s.left = v }

func (s *BitwiseXorExprContext) SetRight(v IBitwiseAndExprContext) { s.right = v }

func (s *BitwiseXorExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseXorExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseXorExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET, 0)
}

func (s *BitwiseXorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseXorExpr() (localctx IBitwiseXorExprContext) {
	return p.bitwiseXorExpr(0)
}

func (p *Manuscript) bitwiseXorExpr(_p int) (localctx IBitwiseXorExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseXorExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseXorExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, ManuscriptRULE_bitwiseXorExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(838)
		p.bitwiseAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseXorExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseXorExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseXorExpr)
			p.SetState(840)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(841)

				var _m = p.Match(ManuscriptCARET)

				localctx.(*BitwiseXorExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(842)

				var _x = p.bitwiseAndExpr(0)

				localctx.(*BitwiseXorExprContext).right = _x
			}

		}
		p.SetState(847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseAndExprContext is an interface to support dynamic dispatch.
type IBitwiseAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	EqualityExpr() IEqualityExprContext
	BitwiseAndExpr() IBitwiseAndExprContext
	AMP() antlr.TerminalNode

	// IsBitwiseAndExprContext differentiates from other interfaces.
	IsBitwiseAndExprContext()
}

type BitwiseAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseAndExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyBitwiseAndExprContext() *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
	return p
}

func InitEmptyBitwiseAndExprContext(p *BitwiseAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
}

func (*BitwiseAndExprContext) IsBitwiseAndExprContext() {}

func NewBitwiseAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr

	return p
}

func (s *BitwiseAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExprContext) GetLeft() IBitwiseAndExprContext { return s.left }

func (s *BitwiseAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *BitwiseAndExprContext) SetLeft(v IBitwiseAndExprContext) { s.left = v }

func (s *BitwiseAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *BitwiseAndExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *BitwiseAndExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseAndExprContext) AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP, 0)
}

func (s *BitwiseAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseAndExpr() (localctx IBitwiseAndExprContext) {
	return p.bitwiseAndExpr(0)
}

func (p *Manuscript) bitwiseAndExpr(_p int) (localctx IBitwiseAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, ManuscriptRULE_bitwiseAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(849)
		p.equalityExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseAndExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseAndExpr)
			p.SetState(851)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(852)

				var _m = p.Match(ManuscriptAMP)

				localctx.(*BitwiseAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(853)

				var _x = p.equalityExpr(0)

				localctx.(*BitwiseAndExprContext).right = _x
			}

		}
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	EqualityExpr() IEqualityExprContext
	EQUALS_EQUALS() antlr.TerminalNode
	NEQ() antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *EqualityExprContext) EQUALS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, 0)
}

func (s *EqualityExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, 0)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	return p.equalityExpr(0)
}

func (p *Manuscript) equalityExpr(_p int) (localctx IEqualityExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, ManuscriptRULE_equalityExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(860)
		p.comparisonExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEqualityExprContext(p, _parentctx, _parentState)
			localctx.(*EqualityExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_equalityExpr)
			p.SetState(862)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(863)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*EqualityExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*EqualityExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(864)

				var _x = p.comparisonExpr(0)

				localctx.(*EqualityExprContext).right = _x
			}

		}
		p.SetState(869)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOpContext is an interface to support dynamic dispatch.
type IComparisonOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	LT_EQUALS() antlr.TerminalNode
	GT() antlr.TerminalNode
	GT_EQUALS() antlr.TerminalNode

	// IsComparisonOpContext differentiates from other interfaces.
	IsComparisonOpContext()
}

type ComparisonOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOpContext() *ComparisonOpContext {
	var p = new(ComparisonOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
	return p
}

func InitEmptyComparisonOpContext(p *ComparisonOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
}

func (*ComparisonOpContext) IsComparisonOpContext() {}

func NewComparisonOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOpContext {
	var p = new(ComparisonOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonOp

	return p
}

func (s *ComparisonOpContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOpContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *ComparisonOpContext) LT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, 0)
}

func (s *ComparisonOpContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *ComparisonOpContext) GT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, 0)
}

func (s *ComparisonOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonOp(s)
	}
}

func (s *ComparisonOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonOp(s)
	}
}

func (s *ComparisonOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonOp() (localctx IComparisonOpContext) {
	localctx = NewComparisonOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ManuscriptRULE_comparisonOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1055531162664960) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetOp returns the op rule contexts.
	GetOp() IComparisonOpContext

	// GetRight returns the right rule contexts.
	GetRight() IShiftExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IComparisonOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IShiftExprContext)

	// Getter signatures
	ShiftExpr() IShiftExprContext
	ComparisonExpr() IComparisonExprContext
	ComparisonOp() IComparisonOpContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     IComparisonOpContext
	right  IShiftExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *ComparisonExprContext) GetOp() IComparisonOpContext { return s.op }

func (s *ComparisonExprContext) GetRight() IShiftExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *ComparisonExprContext) SetOp(v IComparisonOpContext) { s.op = v }

func (s *ComparisonExprContext) SetRight(v IShiftExprContext) { s.right = v }

func (s *ComparisonExprContext) ShiftExpr() IShiftExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ComparisonExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *ComparisonExprContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	return p.comparisonExpr(0)
}

func (p *Manuscript) comparisonExpr(_p int) (localctx IComparisonExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ManuscriptRULE_comparisonExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		p.shiftExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonExprContext(p, _parentctx, _parentState)
			localctx.(*ComparisonExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_comparisonExpr)
			p.SetState(875)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(876)

				var _x = p.ComparisonOp()

				localctx.(*ComparisonExprContext).op = _x
			}
			{
				p.SetState(877)

				var _x = p.shiftExpr(0)

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(883)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExprContext is an interface to support dynamic dispatch.
type IShiftExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IShiftExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAdditiveExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IShiftExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAdditiveExprContext)

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext
	ShiftExpr() IShiftExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsShiftExprContext differentiates from other interfaces.
	IsShiftExprContext()
}

type ShiftExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IShiftExprContext
	op     antlr.Token
	right  IAdditiveExprContext
}

func NewEmptyShiftExprContext() *ShiftExprContext {
	var p = new(ShiftExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
	return p
}

func InitEmptyShiftExprContext(p *ShiftExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
}

func (*ShiftExprContext) IsShiftExprContext() {}

func NewShiftExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExprContext {
	var p = new(ShiftExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_shiftExpr

	return p
}

func (s *ShiftExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExprContext) GetOp() antlr.Token { return s.op }

func (s *ShiftExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ShiftExprContext) GetLeft() IShiftExprContext { return s.left }

func (s *ShiftExprContext) GetRight() IAdditiveExprContext { return s.right }

func (s *ShiftExprContext) SetLeft(v IShiftExprContext) { s.left = v }

func (s *ShiftExprContext) SetRight(v IAdditiveExprContext) { s.right = v }

func (s *ShiftExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ShiftExprContext) ShiftExpr() IShiftExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ShiftExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *ShiftExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *ShiftExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterShiftExpr(s)
	}
}

func (s *ShiftExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitShiftExpr(s)
	}
}

func (s *ShiftExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitShiftExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ShiftExpr() (localctx IShiftExprContext) {
	return p.shiftExpr(0)
}

func (p *Manuscript) shiftExpr(_p int) (localctx IShiftExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewShiftExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShiftExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, ManuscriptRULE_shiftExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.additiveExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShiftExprContext(p, _parentctx, _parentState)
			localctx.(*ShiftExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_shiftExpr)
			p.SetState(887)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(888)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShiftExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShiftExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(889)

				var _x = p.additiveExpr(0)

				localctx.(*ShiftExprContext).right = _x
			}

		}
		p.SetState(894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *AdditiveExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *Manuscript) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, ManuscriptRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			localctx.(*AdditiveExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_additiveExpr)
			p.SetState(898)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(899)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(900)

				var _x = p.multiplicativeExpr(0)

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	MultiplicativeExpr() IMultiplicativeExprContext
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, 0)
}

func (s *MultiplicativeExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, 0)
}

func (s *MultiplicativeExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD, 0)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *Manuscript) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 136
	p.EnterRecursionRule(localctx, 136, ManuscriptRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(907)
		p.UnaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			localctx.(*MultiplicativeExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_multiplicativeExpr)
			p.SetState(909)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(910)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009213693952) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(911)

				var _x = p.UnaryExpr()

				localctx.(*MultiplicativeExprContext).right = _x
			}

		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) CopyAll(ctx *UnaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelUnaryAwaitExprContext struct {
	UnaryExprContext
}

func NewLabelUnaryAwaitExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryAwaitExprContext {
	var p = new(LabelUnaryAwaitExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryAwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryAwaitExprContext) AwaitExpr() IAwaitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAwaitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAwaitExprContext)
}

func (s *LabelUnaryAwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryAwaitExpr(s)
	}
}

func (s *LabelUnaryAwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryAwaitExpr(s)
	}
}

func (s *LabelUnaryAwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelUnaryOpExprContext struct {
	UnaryExprContext
	op    antlr.Token
	unary IUnaryExprContext
}

func NewLabelUnaryOpExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryOpExprContext {
	var p = new(LabelUnaryOpExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryOpExprContext) GetOp() antlr.Token { return s.op }

func (s *LabelUnaryOpExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LabelUnaryOpExprContext) GetUnary() IUnaryExprContext { return s.unary }

func (s *LabelUnaryOpExprContext) SetUnary(v IUnaryExprContext) { s.unary = v }

func (s *LabelUnaryOpExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryOpExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *LabelUnaryOpExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *LabelUnaryOpExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *LabelUnaryOpExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *LabelUnaryOpExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *LabelUnaryOpExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryOpExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(920)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelUnaryOpExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(917)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LabelUnaryOpExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&283124244152321) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LabelUnaryOpExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(918)

			var _x = p.UnaryExpr()

			localctx.(*LabelUnaryOpExprContext).unary = _x
		}

	case 2:
		localctx = NewLabelUnaryAwaitExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(919)
			p.AwaitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAwaitExprContext is an interface to support dynamic dispatch.
type IAwaitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	TRY() antlr.TerminalNode
	AWAIT() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAwaitExprContext differentiates from other interfaces.
	IsAwaitExprContext()
}

type AwaitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExprContext() *AwaitExprContext {
	var p = new(AwaitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
	return p
}

func InitEmptyAwaitExprContext(p *AwaitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
}

func (*AwaitExprContext) IsAwaitExprContext() {}

func NewAwaitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExprContext {
	var p = new(AwaitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_awaitExpr

	return p
}

func (s *AwaitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *AwaitExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *AwaitExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(ManuscriptAWAIT, 0)
}

func (s *AwaitExprContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ManuscriptASYNC, 0)
}

func (s *AwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAwaitExpr(s)
	}
}

func (s *AwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAwaitExpr(s)
	}
}

func (s *AwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AwaitExpr() (localctx IAwaitExprContext) {
	localctx = NewAwaitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ManuscriptRULE_awaitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptTRY {
		{
			p.SetState(922)
			p.Match(ManuscriptTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAWAIT {
		{
			p.SetState(925)
			p.Match(ManuscriptAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptASYNC {
		{
			p.SetState(928)
			p.Match(ManuscriptASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

	{
		p.SetState(931)
		p.postfixExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	PostfixExpr() IPostfixExprContext
	PostfixOp() IPostfixOpContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PostfixExprContext) PostfixOp() IPostfixOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOpContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	return p.postfixExpr(0)
}

func (p *Manuscript) postfixExpr(_p int) (localctx IPostfixExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 142
	p.EnterRecursionRule(localctx, 142, ManuscriptRULE_postfixExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.PrimaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_postfixExpr)
			p.SetState(936)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(937)
				p.PostfixOp()
			}

		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOpContext is an interface to support dynamic dispatch.
type IPostfixOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPostfixOpContext differentiates from other interfaces.
	IsPostfixOpContext()
}

type PostfixOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOpContext() *PostfixOpContext {
	var p = new(PostfixOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
	return p
}

func InitEmptyPostfixOpContext(p *PostfixOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
}

func (*PostfixOpContext) IsPostfixOpContext() {}

func NewPostfixOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOpContext {
	var p = new(PostfixOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixOp

	return p
}

func (s *PostfixOpContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOpContext) CopyAll(ctx *PostfixOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PostfixOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPostfixDotContext struct {
	PostfixOpContext
}

func NewLabelPostfixDotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixDotContext {
	var p = new(LabelPostfixDotContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixDotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixDotContext) DOT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, 0)
}

func (s *LabelPostfixDotContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPostfixDotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixDot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixCallContext struct {
	PostfixOpContext
}

func NewLabelPostfixCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixCallContext {
	var p = new(LabelPostfixCallContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPostfixCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPostfixCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *LabelPostfixCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixIndexContext struct {
	PostfixOpContext
}

func NewLabelPostfixIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixIndexContext {
	var p = new(LabelPostfixIndexContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixIndexContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelPostfixIndexContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPostfixIndexContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelPostfixIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixOp() (localctx IPostfixOpContext) {
	localctx = NewPostfixOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ManuscriptRULE_postfixOp)
	var _la int

	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLPAREN:
		localctx = NewLabelPostfixCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(943)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(944)
				p.ExprList()
			}

		}
		{
			p.SetState(947)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOT:
		localctx = NewLabelPostfixDotContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(948)
			p.Match(ManuscriptDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(949)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		localctx = NewLabelPostfixIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(950)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(951)
			p.Expr()
		}
		{
			p.SetState(952)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) CopyAll(ctx *PrimaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPrimaryTaggedBlockContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryTaggedBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryTaggedBlockContext {
	var p = new(LabelPrimaryTaggedBlockContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryTaggedBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryTaggedBlockContext) TaggedBlockString() ITaggedBlockStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaggedBlockStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaggedBlockStringContext)
}

func (s *LabelPrimaryTaggedBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryTaggedBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryParenContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryParenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryParenContext {
	var p = new(LabelPrimaryParenContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryParenContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPrimaryParenContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPrimaryParenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPrimaryParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryParen(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMatchContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMatchContext {
	var p = new(LabelPrimaryMatchContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMatchContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *LabelPrimaryMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryStructInitContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryStructInitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryStructInitContext {
	var p = new(LabelPrimaryStructInitContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryStructInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryStructInitContext) StructInitExpr() IStructInitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructInitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructInitExprContext)
}

func (s *LabelPrimaryStructInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryStructInit(s)
	}
}

func (s *LabelPrimaryStructInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryStructInit(s)
	}
}

func (s *LabelPrimaryStructInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryStructInit(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryFnContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryFnContext {
	var p = new(LabelPrimaryFnContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryFnContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *LabelPrimaryFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimarySetContext struct {
	PrimaryExprContext
}

func NewLabelPrimarySetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimarySetContext {
	var p = new(LabelPrimarySetContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimarySetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimarySetContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *LabelPrimarySetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimarySet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryIDContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryIDContext {
	var p = new(LabelPrimaryIDContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPrimaryIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryID(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryVoidContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryVoidContext {
	var p = new(LabelPrimaryVoidContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelPrimaryVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMapContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMapContext {
	var p = new(LabelPrimaryMapContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMapContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LabelPrimaryMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMap(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryLiteralContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryLiteralContext {
	var p = new(LabelPrimaryLiteralContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LabelPrimaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryArrayContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryArrayContext {
	var p = new(LabelPrimaryArrayContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryArrayContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *LabelPrimaryArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryNullContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryNullContext {
	var p = new(LabelPrimaryNullContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelPrimaryNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryObjectContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryObjectContext {
	var p = new(LabelPrimaryObjectContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryObjectContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *LabelPrimaryObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ManuscriptRULE_primaryExpr)
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelPrimaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.Literal()
		}

	case 2:
		localctx = NewLabelPrimaryIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(957)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLabelPrimaryParenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(958)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Expr()
		}
		{
			p.SetState(960)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLabelPrimaryArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(962)
			p.ArrayLiteral()
		}

	case 5:
		localctx = NewLabelPrimaryObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(963)
			p.ObjectLiteral()
		}

	case 6:
		localctx = NewLabelPrimaryMapContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(964)
			p.MapLiteral()
		}

	case 7:
		localctx = NewLabelPrimarySetContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(965)
			p.SetLiteral()
		}

	case 8:
		localctx = NewLabelPrimaryFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(966)
			p.FnExpr()
		}

	case 9:
		localctx = NewLabelPrimaryMatchContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(967)
			p.MatchExpr()
		}

	case 10:
		localctx = NewLabelPrimaryVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(968)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewLabelPrimaryNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(969)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewLabelPrimaryTaggedBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(970)
			p.TaggedBlockString()
		}

	case 13:
		localctx = NewLabelPrimaryStructInitContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(971)
			p.StructInitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(976)
			p.Parameters()
		}

	}
	{
		p.SetState(979)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(980)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(983)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expr() IExprContext
	LBRACE() antlr.TerminalNode
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	DefaultClause() IDefaultClauseContext

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MatchExprContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ManuscriptRULE_matchExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(985)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(986)
		p.Expr()
	}
	{
		p.SetState(987)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(988)
			p.Stmt_sep()
		}

		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(994)
		p.CaseClause()
	}
	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(996)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(995)
					p.Stmt_sep()
				}

				p.SetState(998)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1000)
				p.CaseClause()
			}

		}
		p.SetState(1006)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(1007)
			p.Stmt_sep()
		}

		p.SetState(1012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptDEFAULT {
		{
			p.SetState(1013)
			p.DefaultClause()
		}

	}
	{
		p.SetState(1016)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ManuscriptRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1018)
		p.Expr()
	}
	p.SetState(1022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1019)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1020)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1021)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1024)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFAULT, 0)
}

func (s *DefaultClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *DefaultClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DefaultClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *DefaultClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ManuscriptRULE_defaultClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1027)
		p.Match(ManuscriptDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1031)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1028)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1029)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1030)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(1033)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1036)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1037)
			p.StringPart()
		}

		p.SetState(1042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1043)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1046)
			p.StringPart()
		}

		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1052)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTE_START() antlr.TerminalNode
	DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsDoubleQuotedStringContext differentiates from other interfaces.
	IsDoubleQuotedStringContext()
}

type DoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleQuotedStringContext() *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
	return p
}

func InitEmptyDoubleQuotedStringContext(p *DoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
}

func (*DoubleQuotedStringContext) IsDoubleQuotedStringContext() {}

func NewDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_doubleQuotedString

	return p
}

func (s *DoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleQuotedStringContext) DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_QUOTE_START, 0)
}

func (s *DoubleQuotedStringContext) DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_END, 0)
}

func (s *DoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *DoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *DoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DoubleQuotedString() (localctx IDoubleQuotedStringContext) {
	localctx = NewDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ManuscriptRULE_doubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		p.Match(ManuscriptDOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1055)
			p.StringPart()
		}

		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1061)
		p.Match(ManuscriptDOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IMultiDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiDoubleQuotedStringContext differentiates from other interfaces.
	IsMultiDoubleQuotedStringContext()
}

type MultiDoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiDoubleQuotedStringContext() *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
	return p
}

func InitEmptyMultiDoubleQuotedStringContext(p *MultiDoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
}

func (*MultiDoubleQuotedStringContext) IsMultiDoubleQuotedStringContext() {}

func NewMultiDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString

	return p
}

func (s *MultiDoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_QUOTE_START, 0)
}

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_END, 0)
}

func (s *MultiDoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiDoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiDoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiDoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiDoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiDoubleQuotedString() (localctx IMultiDoubleQuotedStringContext) {
	localctx = NewMultiDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ManuscriptRULE_multiDoubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(ManuscriptMULTI_DOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1064)
			p.StringPart()
		}

		p.SetState(1069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1070)
		p.Match(ManuscriptMULTI_DOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) CopyAll(ctx *StringPartContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelStringPartInterpContext struct {
	StringPartContext
}

func NewLabelStringPartInterpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringPartInterpContext {
	var p = new(LabelStringPartInterpContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *LabelStringPartInterpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringPartInterpContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *LabelStringPartInterpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringPartInterp(s)
	}
}

func (s *LabelStringPartInterpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringPartInterp(s)
	}
}

func (s *LabelStringPartInterpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringPartInterp(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringPartSingleContext struct {
	StringPartContext
}

func NewLabelStringPartSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringPartSingleContext {
	var p = new(LabelStringPartSingleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *LabelStringPartSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringPartSingleContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *LabelStringPartSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringPartSingle(s)
	}
}

func (s *LabelStringPartSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringPartSingle(s)
	}
}

func (s *LabelStringPartSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringPartSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringPartMultiDoubleContext struct {
	StringPartContext
}

func NewLabelStringPartMultiDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringPartMultiDoubleContext {
	var p = new(LabelStringPartMultiDoubleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *LabelStringPartMultiDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringPartMultiDoubleContext) MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_CONTENT, 0)
}

func (s *LabelStringPartMultiDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringPartMultiDouble(s)
	}
}

func (s *LabelStringPartMultiDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringPartMultiDouble(s)
	}
}

func (s *LabelStringPartMultiDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringPartMultiDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringPartMultiContext struct {
	StringPartContext
}

func NewLabelStringPartMultiContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringPartMultiContext {
	var p = new(LabelStringPartMultiContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *LabelStringPartMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringPartMultiContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *LabelStringPartMultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringPartMulti(s)
	}
}

func (s *LabelStringPartMultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringPartMulti(s)
	}
}

func (s *LabelStringPartMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringPartMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringPartDoubleContext struct {
	StringPartContext
}

func NewLabelStringPartDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringPartDoubleContext {
	var p = new(LabelStringPartDoubleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *LabelStringPartDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringPartDoubleContext) DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_CONTENT, 0)
}

func (s *LabelStringPartDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringPartDouble(s)
	}
}

func (s *LabelStringPartDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringPartDouble(s)
	}
}

func (s *LabelStringPartDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringPartDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ManuscriptRULE_stringPart)
	p.SetState(1077)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		localctx = NewLabelStringPartSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1072)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		localctx = NewLabelStringPartMultiContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1073)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOUBLE_STR_CONTENT:
		localctx = NewLabelStringPartDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1074)
			p.Match(ManuscriptDOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_DOUBLE_STR_CONTENT:
		localctx = NewLabelStringPartMultiDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1075)
			p.Match(ManuscriptMULTI_DOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START, ManuscriptDOUBLE_STR_INTERP_START, ManuscriptMULTI_DOUBLE_STR_INTERP_START:
		localctx = NewLabelStringPartInterpContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1076)
			p.Interpolation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	DOUBLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1079)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&585) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1080)
		p.Expr()
	}
	{
		p.SetState(1081)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLiteralBoolContext struct {
	LiteralContext
}

func NewLabelLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralBoolContext {
	var p = new(LabelLiteralBoolContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralBoolContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LabelLiteralBoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralStringContext struct {
	LiteralContext
}

func NewLabelLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralStringContext {
	var p = new(LabelLiteralStringContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralStringContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelLiteralStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNumberContext struct {
	LiteralContext
}

func NewLabelLiteralNumberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNumberContext {
	var p = new(LabelLiteralNumberContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNumberContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LabelLiteralNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNullContext struct {
	LiteralContext
}

func NewLabelLiteralNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNullContext {
	var p = new(LabelLiteralNullContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelLiteralNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralVoidContext struct {
	LiteralContext
}

func NewLabelLiteralVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralVoidContext {
	var p = new(LabelLiteralVoidContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelLiteralVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ManuscriptRULE_literal)
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1083)
			p.StringLiteral()
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		localctx = NewLabelLiteralNumberContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1084)
			p.NumberLiteral()
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		localctx = NewLabelLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1085)
			p.BooleanLiteral()
		}

	case ManuscriptNULL:
		localctx = NewLabelLiteralNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1086)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		localctx = NewLabelLiteralVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1087)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) CopyAll(ctx *StringLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelStringLiteralMultiContext struct {
	StringLiteralContext
}

func NewLabelStringLiteralMultiContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringLiteralMultiContext {
	var p = new(LabelStringLiteralMultiContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *LabelStringLiteralMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringLiteralMultiContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *LabelStringLiteralMultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringLiteralMulti(s)
	}
}

func (s *LabelStringLiteralMultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringLiteralMulti(s)
	}
}

func (s *LabelStringLiteralMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringLiteralMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringLiteralDoubleContext struct {
	StringLiteralContext
}

func NewLabelStringLiteralDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringLiteralDoubleContext {
	var p = new(LabelStringLiteralDoubleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *LabelStringLiteralDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringLiteralDoubleContext) DoubleQuotedString() IDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleQuotedStringContext)
}

func (s *LabelStringLiteralDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringLiteralDouble(s)
	}
}

func (s *LabelStringLiteralDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringLiteralDouble(s)
	}
}

func (s *LabelStringLiteralDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringLiteralDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringLiteralMultiDoubleContext struct {
	StringLiteralContext
}

func NewLabelStringLiteralMultiDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringLiteralMultiDoubleContext {
	var p = new(LabelStringLiteralMultiDoubleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *LabelStringLiteralMultiDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringLiteralMultiDoubleContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *LabelStringLiteralMultiDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringLiteralMultiDouble(s)
	}
}

func (s *LabelStringLiteralMultiDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringLiteralMultiDouble(s)
	}
}

func (s *LabelStringLiteralMultiDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringLiteralMultiDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStringLiteralSingleContext struct {
	StringLiteralContext
}

func NewLabelStringLiteralSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStringLiteralSingleContext {
	var p = new(LabelStringLiteralSingleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *LabelStringLiteralSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStringLiteralSingleContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *LabelStringLiteralSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStringLiteralSingle(s)
	}
}

func (s *LabelStringLiteralSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStringLiteralSingle(s)
	}
}

func (s *LabelStringLiteralSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStringLiteralSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ManuscriptRULE_stringLiteral)
	p.SetState(1094)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		localctx = NewLabelStringLiteralSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1090)
			p.SingleQuotedString()
		}

	case ManuscriptMULTI_QUOTE_START:
		localctx = NewLabelStringLiteralMultiContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1091)
			p.MultiQuotedString()
		}

	case ManuscriptDOUBLE_QUOTE_START:
		localctx = NewLabelStringLiteralDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1092)
			p.DoubleQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelStringLiteralMultiDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1093)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) CopyAll(ctx *NumberLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelNumberLiteralHexContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralHexContext {
	var p = new(LabelNumberLiteralHexContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralHexContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *LabelNumberLiteralHexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralIntContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralIntContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralIntContext {
	var p = new(LabelNumberLiteralIntContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralIntContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *LabelNumberLiteralIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralInt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralOctContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralOctContext {
	var p = new(LabelNumberLiteralOctContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralOctContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptOCTAL_LITERAL, 0)
}

func (s *LabelNumberLiteralOctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralOct(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralFloatContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralFloatContext {
	var p = new(LabelNumberLiteralFloatContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *LabelNumberLiteralFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralBinContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralBinContext {
	var p = new(LabelNumberLiteralBinContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralBinContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *LabelNumberLiteralBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralBin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ManuscriptRULE_numberLiteral)
	p.SetState(1101)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		localctx = NewLabelNumberLiteralIntContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1096)
			p.Match(ManuscriptINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		localctx = NewLabelNumberLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1097)
			p.Match(ManuscriptFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		localctx = NewLabelNumberLiteralHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1098)
			p.Match(ManuscriptHEX_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		localctx = NewLabelNumberLiteralBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1099)
			p.Match(ManuscriptBINARY_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptOCTAL_LITERAL:
		localctx = NewLabelNumberLiteralOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1100)
			p.Match(ManuscriptOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) CopyAll(ctx *BooleanLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelBoolLiteralFalseContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralFalseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralFalseContext {
	var p = new(LabelBoolLiteralFalseContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralFalseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralFalseContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *LabelBoolLiteralFalseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralFalse(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelBoolLiteralTrueContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralTrueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralTrueContext {
	var p = new(LabelBoolLiteralTrueContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralTrueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralTrueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *LabelBoolLiteralTrueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralTrue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ManuscriptRULE_booleanLiteral)
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptTRUE:
		localctx = NewLabelBoolLiteralTrueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1103)
			p.Match(ManuscriptTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFALSE:
		localctx = NewLabelBoolLiteralFalseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.Match(ManuscriptFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	ExprList() IExprListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1107)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1108)
			p.ExprList()
		}

	}
	{
		p.SetState(1111)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectFieldList() IObjectFieldListContext

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) ObjectFieldList() IObjectFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldListContext)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ManuscriptRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&31) != 0 {
		{
			p.SetState(1114)
			p.ObjectFieldList()
		}

	}
	{
		p.SetState(1117)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldListContext is an interface to support dynamic dispatch.
type IObjectFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectFieldListContext differentiates from other interfaces.
	IsObjectFieldListContext()
}

type ObjectFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldListContext() *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
	return p
}

func InitEmptyObjectFieldListContext(p *ObjectFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
}

func (*ObjectFieldListContext) IsObjectFieldListContext() {}

func NewObjectFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldList

	return p
}

func (s *ObjectFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldListContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectFieldListContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldList() (localctx IObjectFieldListContext) {
	localctx = NewObjectFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ManuscriptRULE_objectFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.ObjectField()
	}
	p.SetState(1124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1120)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1121)
				p.ObjectField()
			}

		}
		p.SetState(1126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1127)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ObjectFieldName() IObjectFieldNameContext
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) ObjectFieldName() IObjectFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldNameContext)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.ObjectFieldName()
	}
	p.SetState(1133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(1131)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1132)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldNameContext is an interface to support dynamic dispatch.
type IObjectFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectFieldNameContext differentiates from other interfaces.
	IsObjectFieldNameContext()
}

type ObjectFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldNameContext() *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
	return p
}

func InitEmptyObjectFieldNameContext(p *ObjectFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
}

func (*ObjectFieldNameContext) IsObjectFieldNameContext() {}

func NewObjectFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldName

	return p
}

func (s *ObjectFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldNameContext) CopyAll(ctx *ObjectFieldNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelObjectFieldNameStrContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameStrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameStrContext {
	var p = new(LabelObjectFieldNameStrContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameStrContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelObjectFieldNameStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameStr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelObjectFieldNameIDContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameIDContext {
	var p = new(LabelObjectFieldNameIDContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelObjectFieldNameIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldName() (localctx IObjectFieldNameContext) {
	localctx = NewObjectFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ManuscriptRULE_objectFieldName)
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelObjectFieldNameIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1135)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelObjectFieldNameStrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1136)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) CopyAll(ctx *MapLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelMapLiteralNonEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralNonEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralNonEmptyContext {
	var p = new(LabelMapLiteralNonEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralNonEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralNonEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) MapFieldList() IMapFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldListContext)
}

func (s *LabelMapLiteralNonEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralNonEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelMapLiteralEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralEmptyContext {
	var p = new(LabelMapLiteralEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *LabelMapLiteralEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ManuscriptRULE_mapLiteral)
	var _la int

	p.SetState(1147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelMapLiteralEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1139)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1140)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1141)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelMapLiteralNonEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1142)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(1143)
				p.MapFieldList()
			}

		}
		{
			p.SetState(1146)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldListContext is an interface to support dynamic dispatch.
type IMapFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapFieldListContext differentiates from other interfaces.
	IsMapFieldListContext()
}

type MapFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldListContext() *MapFieldListContext {
	var p = new(MapFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
	return p
}

func InitEmptyMapFieldListContext(p *MapFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
}

func (*MapFieldListContext) IsMapFieldListContext() {}

func NewMapFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldListContext {
	var p = new(MapFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapFieldList

	return p
}

func (s *MapFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldListContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldListContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapFieldList(s)
	}
}

func (s *MapFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapFieldList(s)
	}
}

func (s *MapFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapFieldList() (localctx IMapFieldListContext) {
	localctx = NewMapFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ManuscriptRULE_mapFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		p.MapField()
	}
	p.SetState(1154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1150)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1151)
				p.MapField()
			}

		}
		p.SetState(1156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1157)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Expr()
	}
	{
		p.SetState(1161)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1162)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ManuscriptRULE_setLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1164)
		p.Match(ManuscriptLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1165)
			p.Expr()
		}
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1166)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1167)
					p.Expr()
				}

			}
			p.SetState(1172)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(1173)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1178)
		p.Match(ManuscriptGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaggedBlockStringContext is an interface to support dynamic dispatch.
type ITaggedBlockStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	MultiQuotedString() IMultiQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsTaggedBlockStringContext differentiates from other interfaces.
	IsTaggedBlockStringContext()
}

type TaggedBlockStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaggedBlockStringContext() *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
	return p
}

func InitEmptyTaggedBlockStringContext(p *TaggedBlockStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
}

func (*TaggedBlockStringContext) IsTaggedBlockStringContext() {}

func NewTaggedBlockStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_taggedBlockString

	return p
}

func (s *TaggedBlockStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TaggedBlockStringContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TaggedBlockStringContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *TaggedBlockStringContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *TaggedBlockStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaggedBlockStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaggedBlockStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTaggedBlockString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TaggedBlockString() (localctx ITaggedBlockStringContext) {
	localctx = NewTaggedBlockStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ManuscriptRULE_taggedBlockString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptMULTI_QUOTE_START:
		{
			p.SetState(1181)
			p.MultiQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		{
			p.SetState(1182)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructInitExprContext is an interface to support dynamic dispatch.
type IStructInitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	StructFieldList() IStructFieldListContext

	// IsStructInitExprContext differentiates from other interfaces.
	IsStructInitExprContext()
}

type StructInitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructInitExprContext() *StructInitExprContext {
	var p = new(StructInitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
	return p
}

func InitEmptyStructInitExprContext(p *StructInitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
}

func (*StructInitExprContext) IsStructInitExprContext() {}

func NewStructInitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructInitExprContext {
	var p = new(StructInitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structInitExpr

	return p
}

func (s *StructInitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StructInitExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructInitExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *StructInitExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *StructInitExprContext) StructFieldList() IStructFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldListContext)
}

func (s *StructInitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructInitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructInitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructInitExpr(s)
	}
}

func (s *StructInitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructInitExpr(s)
	}
}

func (s *StructInitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructInitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructInitExpr() (localctx IStructInitExprContext) {
	localctx = NewStructInitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ManuscriptRULE_structInitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1185)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1186)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1187)
			p.StructFieldList()
		}

	}
	{
		p.SetState(1190)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldListContext is an interface to support dynamic dispatch.
type IStructFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStructFieldListContext differentiates from other interfaces.
	IsStructFieldListContext()
}

type StructFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldListContext() *StructFieldListContext {
	var p = new(StructFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
	return p
}

func InitEmptyStructFieldListContext(p *StructFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
}

func (*StructFieldListContext) IsStructFieldListContext() {}

func NewStructFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldListContext {
	var p = new(StructFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structFieldList

	return p
}

func (s *StructFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldListContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *StructFieldListContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *StructFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *StructFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *StructFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructFieldList(s)
	}
}

func (s *StructFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructFieldList(s)
	}
}

func (s *StructFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructFieldList() (localctx IStructFieldListContext) {
	localctx = NewStructFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ManuscriptRULE_structFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.StructField()
	}
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1193)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1194)
				p.StructField()
			}

		}
		p.SetState(1199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1200)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *StructFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ManuscriptRULE_structField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1204)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1205)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) CopyAll(ctx *TypeAnnotationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelTypeAnnVoidContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnVoidContext {
	var p = new(LabelTypeAnnVoidContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelTypeAnnVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnArrayContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnArrayContext {
	var p = new(LabelTypeAnnArrayContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnArrayContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *LabelTypeAnnArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnTupleContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnTupleContext {
	var p = new(LabelTypeAnnTupleContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnTupleContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *LabelTypeAnnTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnFnContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnFnContext {
	var p = new(LabelTypeAnnFnContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnFnContext) FnType() IFnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnTypeContext)
}

func (s *LabelTypeAnnFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnIDContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnIDContext {
	var p = new(LabelTypeAnnIDContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelTypeAnnIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ManuscriptRULE_typeAnnotation)
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelTypeAnnIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1207)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelTypeAnnArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1208)
			p.ArrayType()
		}

	case 3:
		localctx = NewLabelTypeAnnTupleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1209)
			p.TupleType()
		}

	case 4:
		localctx = NewLabelTypeAnnFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1210)
			p.FnType()
		}

	case 5:
		localctx = NewLabelTypeAnnVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1211)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(1215)
			p.TypeList()
		}

	}
	{
		p.SetState(1218)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ArrayTypeContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayTypeContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ManuscriptRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1222)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnTypeContext is an interface to support dynamic dispatch.
type IFnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnTypeContext differentiates from other interfaces.
	IsFnTypeContext()
}

type FnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnTypeContext() *FnTypeContext {
	var p = new(FnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
	return p
}

func InitEmptyFnTypeContext(p *FnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
}

func (*FnTypeContext) IsFnTypeContext() {}

func NewFnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnTypeContext {
	var p = new(FnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnType

	return p
}

func (s *FnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FnTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnTypeContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnTypeContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnType(s)
	}
}

func (s *FnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnType(s)
	}
}

func (s *FnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnType() (localctx IFnTypeContext) {
	localctx = NewFnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ManuscriptRULE_fnType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1225)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1226)
			p.Parameters()
		}

	}
	{
		p.SetState(1229)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1230)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_sepContext is an interface to support dynamic dispatch.
type IStmt_sepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	NEWLINE() antlr.TerminalNode

	// IsStmt_sepContext differentiates from other interfaces.
	IsStmt_sepContext()
}

type Stmt_sepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_sepContext() *Stmt_sepContext {
	var p = new(Stmt_sepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
	return p
}

func InitEmptyStmt_sepContext(p *Stmt_sepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
}

func (*Stmt_sepContext) IsStmt_sepContext() {}

func NewStmt_sepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_sepContext {
	var p = new(Stmt_sepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt_sep

	return p
}

func (s *Stmt_sepContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_sepContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *Stmt_sepContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEWLINE, 0)
}

func (s *Stmt_sepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_sepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt_sep(s)
	}
}

func (s *Stmt_sepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt_sep(s)
	}
}

func (s *Stmt_sepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt_sep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt_sep() (localctx IStmt_sepContext) {
	localctx = NewStmt_sepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ManuscriptRULE_stmt_sep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Manuscript) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 58:
		var t *LogicalOrExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalOrExprContext)
		}
		return p.LogicalOrExpr_Sempred(t, predIndex)

	case 59:
		var t *LogicalAndExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalAndExprContext)
		}
		return p.LogicalAndExpr_Sempred(t, predIndex)

	case 60:
		var t *BitwiseOrExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseOrExprContext)
		}
		return p.BitwiseOrExpr_Sempred(t, predIndex)

	case 61:
		var t *BitwiseXorExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseXorExprContext)
		}
		return p.BitwiseXorExpr_Sempred(t, predIndex)

	case 62:
		var t *BitwiseAndExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseAndExprContext)
		}
		return p.BitwiseAndExpr_Sempred(t, predIndex)

	case 63:
		var t *EqualityExprContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExprContext)
		}
		return p.EqualityExpr_Sempred(t, predIndex)

	case 65:
		var t *ComparisonExprContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonExprContext)
		}
		return p.ComparisonExpr_Sempred(t, predIndex)

	case 66:
		var t *ShiftExprContext = nil
		if localctx != nil {
			t = localctx.(*ShiftExprContext)
		}
		return p.ShiftExpr_Sempred(t, predIndex)

	case 67:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 68:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 71:
		var t *PostfixExprContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExprContext)
		}
		return p.PostfixExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Manuscript) LogicalOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) LogicalAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseXorExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) EqualityExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ComparisonExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ShiftExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) PostfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
