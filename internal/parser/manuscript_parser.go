// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "'\\n'", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'",
		"'interface'", "'import'", "'export'", "'extern'", "'void'", "'check'",
		"'try'", "'catch'", "'in'", "'as'", "'is'", "'extends'", "'from'", "'null'",
		"'if'", "'else'", "'for'", "'while'", "'true'", "'false'", "'match'",
		"'case'", "'async'", "'await'", "'methods'", "'break'", "'continue'",
		"'default'", "'defer'", "'go'", "", "", "'['", "']'", "'('", "')'",
		"'<'", "'>'", "'<='", "'>='", "':'", "';'", "','", "'='", "'=='", "'+'",
		"'-'", "'++'", "'--'", "'||'", "'&&'", "'*'", "'/'", "'%'", "'!'", "'?'",
		"'.'", "'!='", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'|'",
		"'&'", "'^'", "'<<'", "'>>'",
	}
	staticData.SymbolicNames = []string{
		"", "NEWLINE", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN",
		"YIELD", "TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID",
		"CHECK", "TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL",
		"IF", "ELSE", "FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC",
		"AWAIT", "METHODS", "BREAK", "CONTINUE", "DEFAULT", "DEFER", "GO", "LBRACE",
		"RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN", "LT", "GT", "LT_EQUALS",
		"GT_EQUALS", "COLON", "SEMICOLON", "COMMA", "EQUALS", "EQUALS_EQUALS",
		"PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS", "PIPE_PIPE", "AMP_AMP",
		"STAR", "SLASH", "MOD", "EXCLAMATION", "QUESTION", "DOT", "NEQ", "PLUS_EQUALS",
		"MINUS_EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "MOD_EQUALS", "CARET_EQUALS",
		"PIPE", "AMP", "CARET", "LSHIFT", "RSHIFT", "HEX_LITERAL", "BINARY_LITERAL",
		"OCTAL_LITERAL", "FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"DOUBLE_QUOTE_START", "MULTI_DOUBLE_QUOTE_START", "SINGLE_STR_INTERP_START",
		"SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START", "MULTI_STR_CONTENT",
		"MULTI_STR_END", "DOUBLE_STR_INTERP_START", "DOUBLE_STR_CONTENT", "DOUBLE_STR_END",
		"MULTI_DOUBLE_STR_INTERP_START", "MULTI_DOUBLE_STR_CONTENT", "MULTI_DOUBLE_STR_END",
		"INTERP_LBRACE", "INTERP_RBRACE", "INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "declaration", "importDecl", "exportDecl", "externDecl",
		"exportedItem", "moduleImport", "destructuredImport", "targetImport",
		"importItemList", "importItem", "letDecl", "letSingle", "letBlock",
		"letBlockItemList", "letBlockItemSep", "letBlockItem", "letDestructuredObj",
		"letDestructuredArray", "typedIDList", "typedID", "typeDecl", "typeDefBody",
		"typeAlias", "fieldList", "fieldDecl", "typeList", "interfaceDecl",
		"interfaceMethod", "fnDecl", "fnSignature", "parameters", "param", "methodsDecl",
		"methodImplList", "methodImpl", "stmt", "returnStmt", "yieldStmt", "deferStmt",
		"exprList", "ifStmt", "forStmt", "forLoopType", "forTrinity", "forInit",
		"forCond", "forPost", "whileStmt", "loopBody", "codeBlock", "breakStmt",
		"continueStmt", "checkStmt", "pipedStmt", "pipedArgs", "pipedArg", "expr",
		"assignmentExpr", "assignmentOp", "ternaryExpr", "logicalOrExpr", "logicalAndExpr",
		"bitwiseXorExpr", "bitwiseAndExpr", "equalityExpr", "comparisonOp",
		"comparisonExpr", "shiftExpr", "additiveExpr", "multiplicativeExpr",
		"unaryExpr", "awaitExpr", "postfixExpr", "postfixOp", "primaryExpr",
		"tryExpr", "fnExpr", "matchExpr", "caseClause", "defaultClause", "singleQuotedString",
		"multiQuotedString", "doubleQuotedString", "multiDoubleQuotedString",
		"stringPart", "interpolation", "literal", "stringLiteral", "numberLiteral",
		"booleanLiteral", "arrayLiteral", "objectLiteral", "objectFieldList",
		"objectField", "objectFieldName", "mapLiteral", "mapFieldList", "mapField",
		"setLiteral", "taggedBlockString", "structInitExpr", "structFieldList",
		"structField", "typeAnnotation", "tupleType", "arrayType", "fnType",
		"stmt_sep",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 103, 1239, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 1, 0, 5, 0, 220, 8, 0, 10, 0, 12, 0, 223, 9, 0, 1, 0, 1, 0, 4, 0,
		227, 8, 0, 11, 0, 12, 0, 228, 1, 0, 1, 0, 5, 0, 233, 8, 0, 10, 0, 12, 0,
		236, 9, 0, 3, 0, 238, 8, 0, 1, 0, 5, 0, 241, 8, 0, 10, 0, 12, 0, 244, 9,
		0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 256,
		8, 1, 1, 2, 1, 2, 1, 2, 3, 2, 261, 8, 2, 1, 3, 1, 3, 1, 3, 3, 3, 266, 8,
		3, 1, 4, 1, 4, 1, 4, 3, 4, 271, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 277,
		8, 5, 1, 6, 1, 6, 3, 6, 281, 8, 6, 1, 7, 1, 7, 3, 7, 285, 8, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 5, 9, 298, 8,
		9, 10, 9, 12, 9, 301, 9, 9, 1, 9, 3, 9, 304, 8, 9, 1, 10, 1, 10, 1, 10,
		3, 10, 309, 8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 314, 8, 11, 1, 11, 1, 11,
		1, 11, 3, 11, 319, 8, 11, 1, 11, 1, 11, 1, 11, 3, 11, 324, 8, 11, 1, 11,
		1, 11, 1, 11, 3, 11, 329, 8, 11, 3, 11, 331, 8, 11, 1, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 337, 8, 12, 3, 12, 339, 8, 12, 1, 13, 1, 13, 3, 13, 343,
		8, 13, 1, 13, 1, 13, 1, 14, 5, 14, 348, 8, 14, 10, 14, 12, 14, 351, 9,
		14, 1, 14, 1, 14, 4, 14, 355, 8, 14, 11, 14, 12, 14, 356, 1, 14, 1, 14,
		5, 14, 361, 8, 14, 10, 14, 12, 14, 364, 9, 14, 1, 14, 5, 14, 367, 8, 14,
		10, 14, 12, 14, 370, 9, 14, 1, 15, 1, 15, 3, 15, 374, 8, 15, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 392, 8, 16, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19,
		1, 19, 5, 19, 409, 8, 19, 10, 19, 12, 19, 412, 9, 19, 1, 19, 3, 19, 415,
		8, 19, 1, 20, 1, 20, 3, 20, 419, 8, 20, 1, 21, 1, 21, 1, 21, 1, 21, 3,
		21, 425, 8, 21, 1, 22, 1, 22, 3, 22, 429, 8, 22, 1, 22, 1, 22, 5, 22, 433,
		8, 22, 10, 22, 12, 22, 436, 9, 22, 1, 22, 1, 22, 5, 22, 440, 8, 22, 10,
		22, 12, 22, 443, 9, 22, 1, 22, 1, 22, 5, 22, 447, 8, 22, 10, 22, 12, 22,
		450, 9, 22, 1, 22, 5, 22, 453, 8, 22, 10, 22, 12, 22, 456, 9, 22, 1, 22,
		5, 22, 459, 8, 22, 10, 22, 12, 22, 462, 9, 22, 1, 22, 3, 22, 465, 8, 22,
		1, 22, 5, 22, 468, 8, 22, 10, 22, 12, 22, 471, 9, 22, 3, 22, 473, 8, 22,
		1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 481, 8, 23, 1, 24, 1,
		24, 1, 24, 5, 24, 486, 8, 24, 10, 24, 12, 24, 489, 9, 24, 1, 24, 3, 24,
		492, 8, 24, 1, 25, 1, 25, 3, 25, 496, 8, 25, 1, 25, 1, 25, 1, 26, 1, 26,
		1, 26, 5, 26, 503, 8, 26, 10, 26, 12, 26, 506, 9, 26, 1, 26, 3, 26, 509,
		8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 515, 8, 27, 1, 27, 1, 27, 5,
		27, 519, 8, 27, 10, 27, 12, 27, 522, 9, 27, 1, 27, 1, 27, 5, 27, 526, 8,
		27, 10, 27, 12, 27, 529, 9, 27, 4, 27, 531, 8, 27, 11, 27, 12, 27, 532,
		1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 540, 8, 28, 1, 28, 1, 28, 3,
		28, 544, 8, 28, 1, 28, 3, 28, 547, 8, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1,
		30, 1, 30, 1, 30, 3, 30, 556, 8, 30, 1, 30, 1, 30, 3, 30, 560, 8, 30, 1,
		30, 3, 30, 563, 8, 30, 1, 31, 1, 31, 1, 31, 5, 31, 568, 8, 31, 10, 31,
		12, 31, 571, 9, 31, 1, 31, 3, 31, 574, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32,
		3, 32, 580, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 588,
		8, 33, 1, 33, 1, 33, 1, 34, 5, 34, 593, 8, 34, 10, 34, 12, 34, 596, 9,
		34, 1, 34, 1, 34, 4, 34, 600, 8, 34, 11, 34, 12, 34, 601, 1, 34, 1, 34,
		5, 34, 606, 8, 34, 10, 34, 12, 34, 609, 9, 34, 1, 34, 5, 34, 612, 8, 34,
		10, 34, 12, 34, 615, 9, 34, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 3,
		36, 623, 8, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 637, 8, 36, 1, 36, 3, 36, 640, 8, 36,
		1, 37, 1, 37, 3, 37, 644, 8, 37, 1, 37, 3, 37, 647, 8, 37, 1, 38, 1, 38,
		3, 38, 651, 8, 38, 1, 38, 3, 38, 654, 8, 38, 1, 39, 1, 39, 1, 39, 3, 39,
		659, 8, 39, 1, 40, 1, 40, 1, 40, 5, 40, 664, 8, 40, 10, 40, 12, 40, 667,
		9, 40, 1, 40, 3, 40, 670, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3,
		41, 677, 8, 41, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		686, 8, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 692, 8, 43, 1, 44, 1, 44,
		1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 703, 8, 45, 1,
		46, 1, 46, 3, 46, 707, 8, 46, 1, 47, 1, 47, 3, 47, 711, 8, 47, 1, 48, 1,
		48, 1, 48, 1, 48, 1, 49, 1, 49, 5, 49, 719, 8, 49, 10, 49, 12, 49, 722,
		9, 49, 1, 49, 1, 49, 4, 49, 726, 8, 49, 11, 49, 12, 49, 727, 1, 49, 1,
		49, 5, 49, 732, 8, 49, 10, 49, 12, 49, 735, 9, 49, 3, 49, 737, 8, 49, 1,
		49, 5, 49, 740, 8, 49, 10, 49, 12, 49, 743, 9, 49, 1, 49, 1, 49, 1, 50,
		1, 50, 5, 50, 749, 8, 50, 10, 50, 12, 50, 752, 9, 50, 1, 50, 1, 50, 4,
		50, 756, 8, 50, 11, 50, 12, 50, 757, 1, 50, 1, 50, 5, 50, 762, 8, 50, 10,
		50, 12, 50, 765, 9, 50, 3, 50, 767, 8, 50, 1, 50, 5, 50, 770, 8, 50, 10,
		50, 12, 50, 773, 9, 50, 1, 50, 1, 50, 1, 51, 1, 51, 3, 51, 779, 8, 51,
		1, 52, 1, 52, 3, 52, 783, 8, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3,
		53, 790, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 796, 8, 54, 4, 54, 798,
		8, 54, 11, 54, 12, 54, 799, 1, 54, 3, 54, 803, 8, 54, 1, 55, 4, 55, 806,
		8, 55, 11, 55, 12, 55, 807, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 821, 8, 58, 1, 59, 1, 59, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 832, 8, 60, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 840, 8, 61, 10, 61, 12, 61, 843,
		9, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 5, 62, 851, 8, 62, 10,
		62, 12, 62, 854, 9, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63,
		862, 8, 63, 10, 63, 12, 63, 865, 9, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1,
		64, 1, 64, 5, 64, 873, 8, 64, 10, 64, 12, 64, 876, 9, 64, 1, 65, 1, 65,
		1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 884, 8, 65, 10, 65, 12, 65, 887, 9,
		65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67,
		898, 8, 67, 10, 67, 12, 67, 901, 9, 67, 1, 68, 1, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 5, 69, 911, 8, 69, 10, 69, 12, 69, 914, 9, 69,
		1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 922, 8, 70, 10, 70, 12,
		70, 925, 9, 70, 1, 71, 1, 71, 1, 71, 3, 71, 930, 8, 71, 1, 72, 1, 72, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 73, 5, 73, 939, 8, 73, 10, 73, 12, 73, 942,
		9, 73, 1, 74, 1, 74, 3, 74, 946, 8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1,
		74, 1, 74, 1, 74, 3, 74, 955, 8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 3, 75, 973, 8, 75, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 3, 77,
		981, 8, 77, 1, 77, 1, 77, 3, 77, 985, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78,
		1, 78, 1, 78, 5, 78, 993, 8, 78, 10, 78, 12, 78, 996, 9, 78, 1, 78, 1,
		78, 4, 78, 1000, 8, 78, 11, 78, 12, 78, 1001, 1, 78, 1, 78, 5, 78, 1006,
		8, 78, 10, 78, 12, 78, 1009, 9, 78, 1, 78, 5, 78, 1012, 8, 78, 10, 78,
		12, 78, 1015, 9, 78, 1, 78, 3, 78, 1018, 8, 78, 1, 78, 1, 78, 1, 79, 1,
		79, 1, 79, 1, 79, 3, 79, 1026, 8, 79, 1, 79, 3, 79, 1029, 8, 79, 1, 80,
		1, 80, 1, 80, 1, 80, 3, 80, 1035, 8, 80, 1, 80, 3, 80, 1038, 8, 80, 1,
		81, 1, 81, 5, 81, 1042, 8, 81, 10, 81, 12, 81, 1045, 9, 81, 1, 81, 1, 81,
		1, 82, 1, 82, 5, 82, 1051, 8, 82, 10, 82, 12, 82, 1054, 9, 82, 1, 82, 1,
		82, 1, 83, 1, 83, 5, 83, 1060, 8, 83, 10, 83, 12, 83, 1063, 9, 83, 1, 83,
		1, 83, 1, 84, 1, 84, 5, 84, 1069, 8, 84, 10, 84, 12, 84, 1072, 9, 84, 1,
		84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 3, 85, 1081, 8, 85, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1092, 8,
		87, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1098, 8, 88, 1, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 3, 89, 1105, 8, 89, 1, 90, 1, 90, 3, 90, 1109, 8, 90, 1,
		91, 1, 91, 3, 91, 1113, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 3, 92, 1119,
		8, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 5, 93, 1126, 8, 93, 10, 93, 12,
		93, 1129, 9, 93, 1, 93, 3, 93, 1132, 8, 93, 1, 94, 1, 94, 1, 94, 3, 94,
		1137, 8, 94, 1, 95, 1, 95, 3, 95, 1141, 8, 95, 1, 96, 1, 96, 1, 96, 1,
		96, 1, 96, 3, 96, 1148, 8, 96, 1, 96, 3, 96, 1151, 8, 96, 1, 97, 1, 97,
		1, 97, 5, 97, 1156, 8, 97, 10, 97, 12, 97, 1159, 9, 97, 1, 97, 3, 97, 1162,
		8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1172,
		8, 99, 10, 99, 12, 99, 1175, 9, 99, 1, 99, 3, 99, 1178, 8, 99, 3, 99, 1180,
		8, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1187, 8, 100, 1, 101,
		1, 101, 1, 101, 3, 101, 1192, 8, 101, 1, 101, 1, 101, 1, 102, 1, 102, 1,
		102, 5, 102, 1199, 8, 102, 10, 102, 12, 102, 1202, 9, 102, 1, 102, 3, 102,
		1205, 8, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1,
		104, 1, 104, 3, 104, 1216, 8, 104, 1, 105, 1, 105, 3, 105, 1220, 8, 105,
		1, 105, 1, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 107,
		3, 107, 1231, 8, 107, 1, 107, 1, 107, 3, 107, 1235, 8, 107, 1, 108, 1,
		108, 1, 108, 0, 9, 122, 124, 126, 128, 130, 134, 138, 140, 146, 109, 0,
		2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
		40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
		76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
		110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
		140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
		170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198,
		200, 202, 204, 206, 208, 210, 212, 214, 216, 0, 8, 2, 0, 53, 53, 68, 73,
		2, 0, 54, 54, 67, 67, 1, 0, 46, 49, 1, 0, 55, 56, 1, 0, 61, 63, 2, 0, 55,
		56, 64, 64, 4, 0, 89, 89, 92, 92, 95, 95, 98, 98, 2, 0, 1, 1, 51, 51, 1333,
		0, 221, 1, 0, 0, 0, 2, 255, 1, 0, 0, 0, 4, 257, 1, 0, 0, 0, 6, 262, 1,
		0, 0, 0, 8, 267, 1, 0, 0, 0, 10, 276, 1, 0, 0, 0, 12, 280, 1, 0, 0, 0,
		14, 282, 1, 0, 0, 0, 16, 290, 1, 0, 0, 0, 18, 294, 1, 0, 0, 0, 20, 305,
		1, 0, 0, 0, 22, 330, 1, 0, 0, 0, 24, 332, 1, 0, 0, 0, 26, 340, 1, 0, 0,
		0, 28, 349, 1, 0, 0, 0, 30, 373, 1, 0, 0, 0, 32, 391, 1, 0, 0, 0, 34, 393,
		1, 0, 0, 0, 36, 399, 1, 0, 0, 0, 38, 405, 1, 0, 0, 0, 40, 416, 1, 0, 0,
		0, 42, 420, 1, 0, 0, 0, 44, 428, 1, 0, 0, 0, 46, 476, 1, 0, 0, 0, 48, 482,
		1, 0, 0, 0, 50, 493, 1, 0, 0, 0, 52, 499, 1, 0, 0, 0, 54, 510, 1, 0, 0,
		0, 56, 536, 1, 0, 0, 0, 58, 548, 1, 0, 0, 0, 60, 551, 1, 0, 0, 0, 62, 564,
		1, 0, 0, 0, 64, 575, 1, 0, 0, 0, 66, 581, 1, 0, 0, 0, 68, 594, 1, 0, 0,
		0, 70, 616, 1, 0, 0, 0, 72, 639, 1, 0, 0, 0, 74, 641, 1, 0, 0, 0, 76, 648,
		1, 0, 0, 0, 78, 655, 1, 0, 0, 0, 80, 660, 1, 0, 0, 0, 82, 671, 1, 0, 0,
		0, 84, 678, 1, 0, 0, 0, 86, 691, 1, 0, 0, 0, 88, 693, 1, 0, 0, 0, 90, 702,
		1, 0, 0, 0, 92, 706, 1, 0, 0, 0, 94, 710, 1, 0, 0, 0, 96, 712, 1, 0, 0,
		0, 98, 716, 1, 0, 0, 0, 100, 746, 1, 0, 0, 0, 102, 776, 1, 0, 0, 0, 104,
		780, 1, 0, 0, 0, 106, 784, 1, 0, 0, 0, 108, 791, 1, 0, 0, 0, 110, 805,
		1, 0, 0, 0, 112, 809, 1, 0, 0, 0, 114, 813, 1, 0, 0, 0, 116, 820, 1, 0,
		0, 0, 118, 822, 1, 0, 0, 0, 120, 831, 1, 0, 0, 0, 122, 833, 1, 0, 0, 0,
		124, 844, 1, 0, 0, 0, 126, 855, 1, 0, 0, 0, 128, 866, 1, 0, 0, 0, 130,
		877, 1, 0, 0, 0, 132, 888, 1, 0, 0, 0, 134, 890, 1, 0, 0, 0, 136, 902,
		1, 0, 0, 0, 138, 904, 1, 0, 0, 0, 140, 915, 1, 0, 0, 0, 142, 929, 1, 0,
		0, 0, 144, 931, 1, 0, 0, 0, 146, 933, 1, 0, 0, 0, 148, 954, 1, 0, 0, 0,
		150, 972, 1, 0, 0, 0, 152, 974, 1, 0, 0, 0, 154, 977, 1, 0, 0, 0, 156,
		988, 1, 0, 0, 0, 158, 1021, 1, 0, 0, 0, 160, 1030, 1, 0, 0, 0, 162, 1039,
		1, 0, 0, 0, 164, 1048, 1, 0, 0, 0, 166, 1057, 1, 0, 0, 0, 168, 1066, 1,
		0, 0, 0, 170, 1080, 1, 0, 0, 0, 172, 1082, 1, 0, 0, 0, 174, 1091, 1, 0,
		0, 0, 176, 1097, 1, 0, 0, 0, 178, 1104, 1, 0, 0, 0, 180, 1108, 1, 0, 0,
		0, 182, 1110, 1, 0, 0, 0, 184, 1116, 1, 0, 0, 0, 186, 1122, 1, 0, 0, 0,
		188, 1133, 1, 0, 0, 0, 190, 1140, 1, 0, 0, 0, 192, 1150, 1, 0, 0, 0, 194,
		1152, 1, 0, 0, 0, 196, 1163, 1, 0, 0, 0, 198, 1167, 1, 0, 0, 0, 200, 1183,
		1, 0, 0, 0, 202, 1188, 1, 0, 0, 0, 204, 1195, 1, 0, 0, 0, 206, 1206, 1,
		0, 0, 0, 208, 1215, 1, 0, 0, 0, 210, 1217, 1, 0, 0, 0, 212, 1223, 1, 0,
		0, 0, 214, 1227, 1, 0, 0, 0, 216, 1236, 1, 0, 0, 0, 218, 220, 3, 216, 108,
		0, 219, 218, 1, 0, 0, 0, 220, 223, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 221,
		222, 1, 0, 0, 0, 222, 237, 1, 0, 0, 0, 223, 221, 1, 0, 0, 0, 224, 234,
		3, 2, 1, 0, 225, 227, 3, 216, 108, 0, 226, 225, 1, 0, 0, 0, 227, 228, 1,
		0, 0, 0, 228, 226, 1, 0, 0, 0, 228, 229, 1, 0, 0, 0, 229, 230, 1, 0, 0,
		0, 230, 231, 3, 2, 1, 0, 231, 233, 1, 0, 0, 0, 232, 226, 1, 0, 0, 0, 233,
		236, 1, 0, 0, 0, 234, 232, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 238,
		1, 0, 0, 0, 236, 234, 1, 0, 0, 0, 237, 224, 1, 0, 0, 0, 237, 238, 1, 0,
		0, 0, 238, 242, 1, 0, 0, 0, 239, 241, 3, 216, 108, 0, 240, 239, 1, 0, 0,
		0, 241, 244, 1, 0, 0, 0, 242, 240, 1, 0, 0, 0, 242, 243, 1, 0, 0, 0, 243,
		245, 1, 0, 0, 0, 244, 242, 1, 0, 0, 0, 245, 246, 5, 0, 0, 1, 246, 1, 1,
		0, 0, 0, 247, 256, 3, 4, 2, 0, 248, 256, 3, 6, 3, 0, 249, 256, 3, 8, 4,
		0, 250, 256, 3, 22, 11, 0, 251, 256, 3, 42, 21, 0, 252, 256, 3, 54, 27,
		0, 253, 256, 3, 58, 29, 0, 254, 256, 3, 66, 33, 0, 255, 247, 1, 0, 0, 0,
		255, 248, 1, 0, 0, 0, 255, 249, 1, 0, 0, 0, 255, 250, 1, 0, 0, 0, 255,
		251, 1, 0, 0, 0, 255, 252, 1, 0, 0, 0, 255, 253, 1, 0, 0, 0, 255, 254,
		1, 0, 0, 0, 256, 3, 1, 0, 0, 0, 257, 258, 5, 11, 0, 0, 258, 260, 3, 12,
		6, 0, 259, 261, 5, 51, 0, 0, 260, 259, 1, 0, 0, 0, 260, 261, 1, 0, 0, 0,
		261, 5, 1, 0, 0, 0, 262, 263, 5, 12, 0, 0, 263, 265, 3, 10, 5, 0, 264,
		266, 5, 51, 0, 0, 265, 264, 1, 0, 0, 0, 265, 266, 1, 0, 0, 0, 266, 7, 1,
		0, 0, 0, 267, 268, 5, 13, 0, 0, 268, 270, 3, 12, 6, 0, 269, 271, 5, 51,
		0, 0, 270, 269, 1, 0, 0, 0, 270, 271, 1, 0, 0, 0, 271, 9, 1, 0, 0, 0, 272,
		277, 3, 58, 29, 0, 273, 277, 3, 22, 11, 0, 274, 277, 3, 42, 21, 0, 275,
		277, 3, 54, 27, 0, 276, 272, 1, 0, 0, 0, 276, 273, 1, 0, 0, 0, 276, 274,
		1, 0, 0, 0, 276, 275, 1, 0, 0, 0, 277, 11, 1, 0, 0, 0, 278, 281, 3, 14,
		7, 0, 279, 281, 3, 16, 8, 0, 280, 278, 1, 0, 0, 0, 280, 279, 1, 0, 0, 0,
		281, 13, 1, 0, 0, 0, 282, 284, 5, 40, 0, 0, 283, 285, 3, 18, 9, 0, 284,
		283, 1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 286, 1, 0, 0, 0, 286, 287,
		5, 41, 0, 0, 287, 288, 5, 22, 0, 0, 288, 289, 3, 162, 81, 0, 289, 15, 1,
		0, 0, 0, 290, 291, 5, 84, 0, 0, 291, 292, 5, 22, 0, 0, 292, 293, 3, 162,
		81, 0, 293, 17, 1, 0, 0, 0, 294, 299, 3, 20, 10, 0, 295, 296, 5, 52, 0,
		0, 296, 298, 3, 20, 10, 0, 297, 295, 1, 0, 0, 0, 298, 301, 1, 0, 0, 0,
		299, 297, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 300, 303, 1, 0, 0, 0, 301,
		299, 1, 0, 0, 0, 302, 304, 5, 52, 0, 0, 303, 302, 1, 0, 0, 0, 303, 304,
		1, 0, 0, 0, 304, 19, 1, 0, 0, 0, 305, 308, 5, 84, 0, 0, 306, 307, 5, 19,
		0, 0, 307, 309, 5, 84, 0, 0, 308, 306, 1, 0, 0, 0, 308, 309, 1, 0, 0, 0,
		309, 21, 1, 0, 0, 0, 310, 311, 5, 5, 0, 0, 311, 313, 3, 24, 12, 0, 312,
		314, 5, 51, 0, 0, 313, 312, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 331,
		1, 0, 0, 0, 315, 316, 5, 5, 0, 0, 316, 318, 3, 26, 13, 0, 317, 319, 5,
		51, 0, 0, 318, 317, 1, 0, 0, 0, 318, 319, 1, 0, 0, 0, 319, 331, 1, 0, 0,
		0, 320, 321, 5, 5, 0, 0, 321, 323, 3, 34, 17, 0, 322, 324, 5, 51, 0, 0,
		323, 322, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 331, 1, 0, 0, 0, 325,
		326, 5, 5, 0, 0, 326, 328, 3, 36, 18, 0, 327, 329, 5, 51, 0, 0, 328, 327,
		1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 331, 1, 0, 0, 0, 330, 310, 1, 0,
		0, 0, 330, 315, 1, 0, 0, 0, 330, 320, 1, 0, 0, 0, 330, 325, 1, 0, 0, 0,
		331, 23, 1, 0, 0, 0, 332, 338, 3, 40, 20, 0, 333, 336, 5, 53, 0, 0, 334,
		337, 3, 114, 57, 0, 335, 337, 3, 152, 76, 0, 336, 334, 1, 0, 0, 0, 336,
		335, 1, 0, 0, 0, 337, 339, 1, 0, 0, 0, 338, 333, 1, 0, 0, 0, 338, 339,
		1, 0, 0, 0, 339, 25, 1, 0, 0, 0, 340, 342, 5, 44, 0, 0, 341, 343, 3, 28,
		14, 0, 342, 341, 1, 0, 0, 0, 342, 343, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0,
		344, 345, 5, 45, 0, 0, 345, 27, 1, 0, 0, 0, 346, 348, 3, 30, 15, 0, 347,
		346, 1, 0, 0, 0, 348, 351, 1, 0, 0, 0, 349, 347, 1, 0, 0, 0, 349, 350,
		1, 0, 0, 0, 350, 352, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0, 352, 362, 3, 32,
		16, 0, 353, 355, 3, 30, 15, 0, 354, 353, 1, 0, 0, 0, 355, 356, 1, 0, 0,
		0, 356, 354, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 358, 1, 0, 0, 0, 358,
		359, 3, 32, 16, 0, 359, 361, 1, 0, 0, 0, 360, 354, 1, 0, 0, 0, 361, 364,
		1, 0, 0, 0, 362, 360, 1, 0, 0, 0, 362, 363, 1, 0, 0, 0, 363, 368, 1, 0,
		0, 0, 364, 362, 1, 0, 0, 0, 365, 367, 3, 30, 15, 0, 366, 365, 1, 0, 0,
		0, 367, 370, 1, 0, 0, 0, 368, 366, 1, 0, 0, 0, 368, 369, 1, 0, 0, 0, 369,
		29, 1, 0, 0, 0, 370, 368, 1, 0, 0, 0, 371, 374, 5, 52, 0, 0, 372, 374,
		3, 216, 108, 0, 373, 371, 1, 0, 0, 0, 373, 372, 1, 0, 0, 0, 374, 31, 1,
		0, 0, 0, 375, 376, 3, 40, 20, 0, 376, 377, 5, 53, 0, 0, 377, 378, 3, 114,
		57, 0, 378, 392, 1, 0, 0, 0, 379, 380, 5, 40, 0, 0, 380, 381, 3, 38, 19,
		0, 381, 382, 5, 41, 0, 0, 382, 383, 5, 53, 0, 0, 383, 384, 3, 114, 57,
		0, 384, 392, 1, 0, 0, 0, 385, 386, 5, 42, 0, 0, 386, 387, 3, 38, 19, 0,
		387, 388, 5, 43, 0, 0, 388, 389, 5, 53, 0, 0, 389, 390, 3, 114, 57, 0,
		390, 392, 1, 0, 0, 0, 391, 375, 1, 0, 0, 0, 391, 379, 1, 0, 0, 0, 391,
		385, 1, 0, 0, 0, 392, 33, 1, 0, 0, 0, 393, 394, 5, 40, 0, 0, 394, 395,
		3, 38, 19, 0, 395, 396, 5, 41, 0, 0, 396, 397, 5, 53, 0, 0, 397, 398, 3,
		114, 57, 0, 398, 35, 1, 0, 0, 0, 399, 400, 5, 42, 0, 0, 400, 401, 3, 38,
		19, 0, 401, 402, 5, 43, 0, 0, 402, 403, 5, 53, 0, 0, 403, 404, 3, 114,
		57, 0, 404, 37, 1, 0, 0, 0, 405, 410, 3, 40, 20, 0, 406, 407, 5, 52, 0,
		0, 407, 409, 3, 40, 20, 0, 408, 406, 1, 0, 0, 0, 409, 412, 1, 0, 0, 0,
		410, 408, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412,
		410, 1, 0, 0, 0, 413, 415, 5, 52, 0, 0, 414, 413, 1, 0, 0, 0, 414, 415,
		1, 0, 0, 0, 415, 39, 1, 0, 0, 0, 416, 418, 5, 84, 0, 0, 417, 419, 3, 208,
		104, 0, 418, 417, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 41, 1, 0, 0, 0,
		420, 421, 5, 9, 0, 0, 421, 424, 5, 84, 0, 0, 422, 425, 3, 44, 22, 0, 423,
		425, 3, 46, 23, 0, 424, 422, 1, 0, 0, 0, 424, 423, 1, 0, 0, 0, 425, 43,
		1, 0, 0, 0, 426, 427, 5, 21, 0, 0, 427, 429, 3, 52, 26, 0, 428, 426, 1,
		0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 472, 5, 40, 0,
		0, 431, 433, 3, 216, 108, 0, 432, 431, 1, 0, 0, 0, 433, 436, 1, 0, 0, 0,
		434, 432, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 437, 1, 0, 0, 0, 436,
		434, 1, 0, 0, 0, 437, 454, 3, 50, 25, 0, 438, 440, 3, 216, 108, 0, 439,
		438, 1, 0, 0, 0, 440, 443, 1, 0, 0, 0, 441, 439, 1, 0, 0, 0, 441, 442,
		1, 0, 0, 0, 442, 444, 1, 0, 0, 0, 443, 441, 1, 0, 0, 0, 444, 448, 5, 52,
		0, 0, 445, 447, 3, 216, 108, 0, 446, 445, 1, 0, 0, 0, 447, 450, 1, 0, 0,
		0, 448, 446, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 451, 1, 0, 0, 0, 450,
		448, 1, 0, 0, 0, 451, 453, 3, 50, 25, 0, 452, 441, 1, 0, 0, 0, 453, 456,
		1, 0, 0, 0, 454, 452, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 464, 1, 0,
		0, 0, 456, 454, 1, 0, 0, 0, 457, 459, 3, 216, 108, 0, 458, 457, 1, 0, 0,
		0, 459, 462, 1, 0, 0, 0, 460, 458, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461,
		463, 1, 0, 0, 0, 462, 460, 1, 0, 0, 0, 463, 465, 5, 52, 0, 0, 464, 460,
		1, 0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 469, 1, 0, 0, 0, 466, 468, 3, 216,
		108, 0, 467, 466, 1, 0, 0, 0, 468, 471, 1, 0, 0, 0, 469, 467, 1, 0, 0,
		0, 469, 470, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471, 469, 1, 0, 0, 0, 472,
		434, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 475,
		5, 41, 0, 0, 475, 45, 1, 0, 0, 0, 476, 477, 5, 53, 0, 0, 477, 480, 3, 208,
		104, 0, 478, 479, 5, 21, 0, 0, 479, 481, 3, 52, 26, 0, 480, 478, 1, 0,
		0, 0, 480, 481, 1, 0, 0, 0, 481, 47, 1, 0, 0, 0, 482, 487, 3, 50, 25, 0,
		483, 484, 5, 52, 0, 0, 484, 486, 3, 50, 25, 0, 485, 483, 1, 0, 0, 0, 486,
		489, 1, 0, 0, 0, 487, 485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 491,
		1, 0, 0, 0, 489, 487, 1, 0, 0, 0, 490, 492, 5, 52, 0, 0, 491, 490, 1, 0,
		0, 0, 491, 492, 1, 0, 0, 0, 492, 49, 1, 0, 0, 0, 493, 495, 5, 84, 0, 0,
		494, 496, 5, 65, 0, 0, 495, 494, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496,
		497, 1, 0, 0, 0, 497, 498, 3, 208, 104, 0, 498, 51, 1, 0, 0, 0, 499, 504,
		3, 208, 104, 0, 500, 501, 5, 52, 0, 0, 501, 503, 3, 208, 104, 0, 502, 500,
		1, 0, 0, 0, 503, 506, 1, 0, 0, 0, 504, 502, 1, 0, 0, 0, 504, 505, 1, 0,
		0, 0, 505, 508, 1, 0, 0, 0, 506, 504, 1, 0, 0, 0, 507, 509, 5, 52, 0, 0,
		508, 507, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0, 509, 53, 1, 0, 0, 0, 510, 511,
		5, 10, 0, 0, 511, 514, 5, 84, 0, 0, 512, 513, 5, 21, 0, 0, 513, 515, 3,
		52, 26, 0, 514, 512, 1, 0, 0, 0, 514, 515, 1, 0, 0, 0, 515, 516, 1, 0,
		0, 0, 516, 530, 5, 40, 0, 0, 517, 519, 3, 216, 108, 0, 518, 517, 1, 0,
		0, 0, 519, 522, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0,
		521, 523, 1, 0, 0, 0, 522, 520, 1, 0, 0, 0, 523, 527, 3, 56, 28, 0, 524,
		526, 3, 216, 108, 0, 525, 524, 1, 0, 0, 0, 526, 529, 1, 0, 0, 0, 527, 525,
		1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 531, 1, 0, 0, 0, 529, 527, 1, 0,
		0, 0, 530, 520, 1, 0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 530, 1, 0, 0, 0,
		532, 533, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 535, 5, 41, 0, 0, 535,
		55, 1, 0, 0, 0, 536, 537, 5, 84, 0, 0, 537, 539, 5, 44, 0, 0, 538, 540,
		3, 62, 31, 0, 539, 538, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 541, 1,
		0, 0, 0, 541, 543, 5, 45, 0, 0, 542, 544, 3, 208, 104, 0, 543, 542, 1,
		0, 0, 0, 543, 544, 1, 0, 0, 0, 544, 546, 1, 0, 0, 0, 545, 547, 5, 64, 0,
		0, 546, 545, 1, 0, 0, 0, 546, 547, 1, 0, 0, 0, 547, 57, 1, 0, 0, 0, 548,
		549, 3, 60, 30, 0, 549, 550, 3, 100, 50, 0, 550, 59, 1, 0, 0, 0, 551, 552,
		5, 6, 0, 0, 552, 553, 5, 84, 0, 0, 553, 555, 5, 44, 0, 0, 554, 556, 3,
		62, 31, 0, 555, 554, 1, 0, 0, 0, 555, 556, 1, 0, 0, 0, 556, 557, 1, 0,
		0, 0, 557, 559, 5, 45, 0, 0, 558, 560, 3, 208, 104, 0, 559, 558, 1, 0,
		0, 0, 559, 560, 1, 0, 0, 0, 560, 562, 1, 0, 0, 0, 561, 563, 5, 64, 0, 0,
		562, 561, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 61, 1, 0, 0, 0, 564, 569,
		3, 64, 32, 0, 565, 566, 5, 52, 0, 0, 566, 568, 3, 64, 32, 0, 567, 565,
		1, 0, 0, 0, 568, 571, 1, 0, 0, 0, 569, 567, 1, 0, 0, 0, 569, 570, 1, 0,
		0, 0, 570, 573, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 572, 574, 5, 52, 0, 0,
		573, 572, 1, 0, 0, 0, 573, 574, 1, 0, 0, 0, 574, 63, 1, 0, 0, 0, 575, 576,
		5, 84, 0, 0, 576, 579, 3, 208, 104, 0, 577, 578, 5, 53, 0, 0, 578, 580,
		3, 114, 57, 0, 579, 577, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 65, 1,
		0, 0, 0, 581, 582, 5, 34, 0, 0, 582, 583, 5, 84, 0, 0, 583, 584, 5, 19,
		0, 0, 584, 585, 5, 84, 0, 0, 585, 587, 5, 40, 0, 0, 586, 588, 3, 68, 34,
		0, 587, 586, 1, 0, 0, 0, 587, 588, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0, 589,
		590, 5, 41, 0, 0, 590, 67, 1, 0, 0, 0, 591, 593, 3, 216, 108, 0, 592, 591,
		1, 0, 0, 0, 593, 596, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 594, 595, 1, 0,
		0, 0, 595, 597, 1, 0, 0, 0, 596, 594, 1, 0, 0, 0, 597, 607, 3, 70, 35,
		0, 598, 600, 3, 216, 108, 0, 599, 598, 1, 0, 0, 0, 600, 601, 1, 0, 0, 0,
		601, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603,
		604, 3, 70, 35, 0, 604, 606, 1, 0, 0, 0, 605, 599, 1, 0, 0, 0, 606, 609,
		1, 0, 0, 0, 607, 605, 1, 0, 0, 0, 607, 608, 1, 0, 0, 0, 608, 613, 1, 0,
		0, 0, 609, 607, 1, 0, 0, 0, 610, 612, 3, 216, 108, 0, 611, 610, 1, 0, 0,
		0, 612, 615, 1, 0, 0, 0, 613, 611, 1, 0, 0, 0, 613, 614, 1, 0, 0, 0, 614,
		69, 1, 0, 0, 0, 615, 613, 1, 0, 0, 0, 616, 617, 3, 56, 28, 0, 617, 618,
		3, 100, 50, 0, 618, 71, 1, 0, 0, 0, 619, 640, 3, 22, 11, 0, 620, 622, 3,
		114, 57, 0, 621, 623, 5, 51, 0, 0, 622, 621, 1, 0, 0, 0, 622, 623, 1, 0,
		0, 0, 623, 640, 1, 0, 0, 0, 624, 640, 3, 74, 37, 0, 625, 640, 3, 76, 38,
		0, 626, 640, 3, 82, 41, 0, 627, 640, 3, 84, 42, 0, 628, 640, 3, 96, 48,
		0, 629, 640, 3, 100, 50, 0, 630, 640, 3, 102, 51, 0, 631, 640, 3, 104,
		52, 0, 632, 640, 3, 106, 53, 0, 633, 640, 3, 78, 39, 0, 634, 636, 3, 152,
		76, 0, 635, 637, 5, 51, 0, 0, 636, 635, 1, 0, 0, 0, 636, 637, 1, 0, 0,
		0, 637, 640, 1, 0, 0, 0, 638, 640, 3, 108, 54, 0, 639, 619, 1, 0, 0, 0,
		639, 620, 1, 0, 0, 0, 639, 624, 1, 0, 0, 0, 639, 625, 1, 0, 0, 0, 639,
		626, 1, 0, 0, 0, 639, 627, 1, 0, 0, 0, 639, 628, 1, 0, 0, 0, 639, 629,
		1, 0, 0, 0, 639, 630, 1, 0, 0, 0, 639, 631, 1, 0, 0, 0, 639, 632, 1, 0,
		0, 0, 639, 633, 1, 0, 0, 0, 639, 634, 1, 0, 0, 0, 639, 638, 1, 0, 0, 0,
		640, 73, 1, 0, 0, 0, 641, 643, 5, 7, 0, 0, 642, 644, 3, 80, 40, 0, 643,
		642, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 646, 1, 0, 0, 0, 645, 647,
		5, 51, 0, 0, 646, 645, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647, 75, 1, 0,
		0, 0, 648, 650, 5, 8, 0, 0, 649, 651, 3, 80, 40, 0, 650, 649, 1, 0, 0,
		0, 650, 651, 1, 0, 0, 0, 651, 653, 1, 0, 0, 0, 652, 654, 5, 51, 0, 0, 653,
		652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 77, 1, 0, 0, 0, 655, 656, 5,
		38, 0, 0, 656, 658, 3, 114, 57, 0, 657, 659, 5, 51, 0, 0, 658, 657, 1,
		0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 79, 1, 0, 0, 0, 660, 665, 3, 114, 57,
		0, 661, 662, 5, 52, 0, 0, 662, 664, 3, 114, 57, 0, 663, 661, 1, 0, 0, 0,
		664, 667, 1, 0, 0, 0, 665, 663, 1, 0, 0, 0, 665, 666, 1, 0, 0, 0, 666,
		669, 1, 0, 0, 0, 667, 665, 1, 0, 0, 0, 668, 670, 5, 52, 0, 0, 669, 668,
		1, 0, 0, 0, 669, 670, 1, 0, 0, 0, 670, 81, 1, 0, 0, 0, 671, 672, 5, 24,
		0, 0, 672, 673, 3, 114, 57, 0, 673, 676, 3, 100, 50, 0, 674, 675, 5, 25,
		0, 0, 675, 677, 3, 100, 50, 0, 676, 674, 1, 0, 0, 0, 676, 677, 1, 0, 0,
		0, 677, 83, 1, 0, 0, 0, 678, 679, 5, 26, 0, 0, 679, 680, 3, 86, 43, 0,
		680, 85, 1, 0, 0, 0, 681, 692, 3, 88, 44, 0, 682, 685, 5, 84, 0, 0, 683,
		684, 5, 52, 0, 0, 684, 686, 5, 84, 0, 0, 685, 683, 1, 0, 0, 0, 685, 686,
		1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 688, 5, 18, 0, 0, 688, 689, 3, 114,
		57, 0, 689, 690, 3, 98, 49, 0, 690, 692, 1, 0, 0, 0, 691, 681, 1, 0, 0,
		0, 691, 682, 1, 0, 0, 0, 692, 87, 1, 0, 0, 0, 693, 694, 3, 90, 45, 0, 694,
		695, 5, 51, 0, 0, 695, 696, 3, 92, 46, 0, 696, 697, 5, 51, 0, 0, 697, 698,
		3, 94, 47, 0, 698, 699, 3, 98, 49, 0, 699, 89, 1, 0, 0, 0, 700, 703, 3,
		24, 12, 0, 701, 703, 1, 0, 0, 0, 702, 700, 1, 0, 0, 0, 702, 701, 1, 0,
		0, 0, 703, 91, 1, 0, 0, 0, 704, 707, 3, 114, 57, 0, 705, 707, 1, 0, 0,
		0, 706, 704, 1, 0, 0, 0, 706, 705, 1, 0, 0, 0, 707, 93, 1, 0, 0, 0, 708,
		711, 3, 114, 57, 0, 709, 711, 1, 0, 0, 0, 710, 708, 1, 0, 0, 0, 710, 709,
		1, 0, 0, 0, 711, 95, 1, 0, 0, 0, 712, 713, 5, 27, 0, 0, 713, 714, 3, 114,
		57, 0, 714, 715, 3, 98, 49, 0, 715, 97, 1, 0, 0, 0, 716, 720, 5, 40, 0,
		0, 717, 719, 3, 216, 108, 0, 718, 717, 1, 0, 0, 0, 719, 722, 1, 0, 0, 0,
		720, 718, 1, 0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 736, 1, 0, 0, 0, 722,
		720, 1, 0, 0, 0, 723, 733, 3, 72, 36, 0, 724, 726, 3, 216, 108, 0, 725,
		724, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 727, 728,
		1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 3, 72, 36, 0, 730, 732, 1,
		0, 0, 0, 731, 725, 1, 0, 0, 0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0,
		0, 733, 734, 1, 0, 0, 0, 734, 737, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736,
		723, 1, 0, 0, 0, 736, 737, 1, 0, 0, 0, 737, 741, 1, 0, 0, 0, 738, 740,
		3, 216, 108, 0, 739, 738, 1, 0, 0, 0, 740, 743, 1, 0, 0, 0, 741, 739, 1,
		0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 744, 1, 0, 0, 0, 743, 741, 1, 0, 0,
		0, 744, 745, 5, 41, 0, 0, 745, 99, 1, 0, 0, 0, 746, 750, 5, 40, 0, 0, 747,
		749, 3, 216, 108, 0, 748, 747, 1, 0, 0, 0, 749, 752, 1, 0, 0, 0, 750, 748,
		1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 766, 1, 0, 0, 0, 752, 750, 1, 0,
		0, 0, 753, 763, 3, 72, 36, 0, 754, 756, 3, 216, 108, 0, 755, 754, 1, 0,
		0, 0, 756, 757, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0,
		758, 759, 1, 0, 0, 0, 759, 760, 3, 72, 36, 0, 760, 762, 1, 0, 0, 0, 761,
		755, 1, 0, 0, 0, 762, 765, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764,
		1, 0, 0, 0, 764, 767, 1, 0, 0, 0, 765, 763, 1, 0, 0, 0, 766, 753, 1, 0,
		0, 0, 766, 767, 1, 0, 0, 0, 767, 771, 1, 0, 0, 0, 768, 770, 3, 216, 108,
		0, 769, 768, 1, 0, 0, 0, 770, 773, 1, 0, 0, 0, 771, 769, 1, 0, 0, 0, 771,
		772, 1, 0, 0, 0, 772, 774, 1, 0, 0, 0, 773, 771, 1, 0, 0, 0, 774, 775,
		5, 41, 0, 0, 775, 101, 1, 0, 0, 0, 776, 778, 5, 35, 0, 0, 777, 779, 5,
		51, 0, 0, 778, 777, 1, 0, 0, 0, 778, 779, 1, 0, 0, 0, 779, 103, 1, 0, 0,
		0, 780, 782, 5, 36, 0, 0, 781, 783, 5, 51, 0, 0, 782, 781, 1, 0, 0, 0,
		782, 783, 1, 0, 0, 0, 783, 105, 1, 0, 0, 0, 784, 785, 5, 15, 0, 0, 785,
		786, 3, 114, 57, 0, 786, 787, 5, 52, 0, 0, 787, 789, 3, 176, 88, 0, 788,
		790, 5, 51, 0, 0, 789, 788, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 107,
		1, 0, 0, 0, 791, 797, 3, 146, 73, 0, 792, 793, 5, 74, 0, 0, 793, 795, 3,
		146, 73, 0, 794, 796, 3, 110, 55, 0, 795, 794, 1, 0, 0, 0, 795, 796, 1,
		0, 0, 0, 796, 798, 1, 0, 0, 0, 797, 792, 1, 0, 0, 0, 798, 799, 1, 0, 0,
		0, 799, 797, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 802, 1, 0, 0, 0, 801,
		803, 5, 51, 0, 0, 802, 801, 1, 0, 0, 0, 802, 803, 1, 0, 0, 0, 803, 109,
		1, 0, 0, 0, 804, 806, 3, 112, 56, 0, 805, 804, 1, 0, 0, 0, 806, 807, 1,
		0, 0, 0, 807, 805, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 111, 1, 0, 0,
		0, 809, 810, 5, 84, 0, 0, 810, 811, 5, 53, 0, 0, 811, 812, 3, 114, 57,
		0, 812, 113, 1, 0, 0, 0, 813, 814, 3, 116, 58, 0, 814, 115, 1, 0, 0, 0,
		815, 821, 3, 120, 60, 0, 816, 817, 3, 120, 60, 0, 817, 818, 3, 118, 59,
		0, 818, 819, 3, 116, 58, 0, 819, 821, 1, 0, 0, 0, 820, 815, 1, 0, 0, 0,
		820, 816, 1, 0, 0, 0, 821, 117, 1, 0, 0, 0, 822, 823, 7, 0, 0, 0, 823,
		119, 1, 0, 0, 0, 824, 832, 3, 122, 61, 0, 825, 826, 3, 122, 61, 0, 826,
		827, 5, 65, 0, 0, 827, 828, 3, 114, 57, 0, 828, 829, 5, 50, 0, 0, 829,
		830, 3, 120, 60, 0, 830, 832, 1, 0, 0, 0, 831, 824, 1, 0, 0, 0, 831, 825,
		1, 0, 0, 0, 832, 121, 1, 0, 0, 0, 833, 834, 6, 61, -1, 0, 834, 835, 3,
		124, 62, 0, 835, 841, 1, 0, 0, 0, 836, 837, 10, 1, 0, 0, 837, 838, 5, 59,
		0, 0, 838, 840, 3, 124, 62, 0, 839, 836, 1, 0, 0, 0, 840, 843, 1, 0, 0,
		0, 841, 839, 1, 0, 0, 0, 841, 842, 1, 0, 0, 0, 842, 123, 1, 0, 0, 0, 843,
		841, 1, 0, 0, 0, 844, 845, 6, 62, -1, 0, 845, 846, 3, 126, 63, 0, 846,
		852, 1, 0, 0, 0, 847, 848, 10, 1, 0, 0, 848, 849, 5, 60, 0, 0, 849, 851,
		3, 126, 63, 0, 850, 847, 1, 0, 0, 0, 851, 854, 1, 0, 0, 0, 852, 850, 1,
		0, 0, 0, 852, 853, 1, 0, 0, 0, 853, 125, 1, 0, 0, 0, 854, 852, 1, 0, 0,
		0, 855, 856, 6, 63, -1, 0, 856, 857, 3, 128, 64, 0, 857, 863, 1, 0, 0,
		0, 858, 859, 10, 1, 0, 0, 859, 860, 5, 76, 0, 0, 860, 862, 3, 128, 64,
		0, 861, 858, 1, 0, 0, 0, 862, 865, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0, 863,
		864, 1, 0, 0, 0, 864, 127, 1, 0, 0, 0, 865, 863, 1, 0, 0, 0, 866, 867,
		6, 64, -1, 0, 867, 868, 3, 130, 65, 0, 868, 874, 1, 0, 0, 0, 869, 870,
		10, 1, 0, 0, 870, 871, 5, 75, 0, 0, 871, 873, 3, 130, 65, 0, 872, 869,
		1, 0, 0, 0, 873, 876, 1, 0, 0, 0, 874, 872, 1, 0, 0, 0, 874, 875, 1, 0,
		0, 0, 875, 129, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 877, 878, 6, 65, -1,
		0, 878, 879, 3, 134, 67, 0, 879, 885, 1, 0, 0, 0, 880, 881, 10, 1, 0, 0,
		881, 882, 7, 1, 0, 0, 882, 884, 3, 134, 67, 0, 883, 880, 1, 0, 0, 0, 884,
		887, 1, 0, 0, 0, 885, 883, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 131,
		1, 0, 0, 0, 887, 885, 1, 0, 0, 0, 888, 889, 7, 2, 0, 0, 889, 133, 1, 0,
		0, 0, 890, 891, 6, 67, -1, 0, 891, 892, 3, 136, 68, 0, 892, 899, 1, 0,
		0, 0, 893, 894, 10, 1, 0, 0, 894, 895, 3, 132, 66, 0, 895, 896, 3, 136,
		68, 0, 896, 898, 1, 0, 0, 0, 897, 893, 1, 0, 0, 0, 898, 901, 1, 0, 0, 0,
		899, 897, 1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 135, 1, 0, 0, 0, 901,
		899, 1, 0, 0, 0, 902, 903, 3, 138, 69, 0, 903, 137, 1, 0, 0, 0, 904, 905,
		6, 69, -1, 0, 905, 906, 3, 140, 70, 0, 906, 912, 1, 0, 0, 0, 907, 908,
		10, 1, 0, 0, 908, 909, 7, 3, 0, 0, 909, 911, 3, 140, 70, 0, 910, 907, 1,
		0, 0, 0, 911, 914, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 912, 913, 1, 0, 0,
		0, 913, 139, 1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 915, 916, 6, 70, -1, 0,
		916, 917, 3, 142, 71, 0, 917, 923, 1, 0, 0, 0, 918, 919, 10, 1, 0, 0, 919,
		920, 7, 4, 0, 0, 920, 922, 3, 142, 71, 0, 921, 918, 1, 0, 0, 0, 922, 925,
		1, 0, 0, 0, 923, 921, 1, 0, 0, 0, 923, 924, 1, 0, 0, 0, 924, 141, 1, 0,
		0, 0, 925, 923, 1, 0, 0, 0, 926, 927, 7, 5, 0, 0, 927, 930, 3, 142, 71,
		0, 928, 930, 3, 144, 72, 0, 929, 926, 1, 0, 0, 0, 929, 928, 1, 0, 0, 0,
		930, 143, 1, 0, 0, 0, 931, 932, 3, 146, 73, 0, 932, 145, 1, 0, 0, 0, 933,
		934, 6, 73, -1, 0, 934, 935, 3, 150, 75, 0, 935, 940, 1, 0, 0, 0, 936,
		937, 10, 1, 0, 0, 937, 939, 3, 148, 74, 0, 938, 936, 1, 0, 0, 0, 939, 942,
		1, 0, 0, 0, 940, 938, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 147, 1, 0,
		0, 0, 942, 940, 1, 0, 0, 0, 943, 945, 5, 44, 0, 0, 944, 946, 3, 80, 40,
		0, 945, 944, 1, 0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947,
		955, 5, 45, 0, 0, 948, 949, 5, 66, 0, 0, 949, 955, 5, 84, 0, 0, 950, 951,
		5, 42, 0, 0, 951, 952, 3, 114, 57, 0, 952, 953, 5, 43, 0, 0, 953, 955,
		1, 0, 0, 0, 954, 943, 1, 0, 0, 0, 954, 948, 1, 0, 0, 0, 954, 950, 1, 0,
		0, 0, 955, 149, 1, 0, 0, 0, 956, 973, 3, 174, 87, 0, 957, 973, 5, 84, 0,
		0, 958, 959, 5, 44, 0, 0, 959, 960, 3, 114, 57, 0, 960, 961, 5, 45, 0,
		0, 961, 973, 1, 0, 0, 0, 962, 973, 3, 182, 91, 0, 963, 973, 3, 184, 92,
		0, 964, 973, 3, 192, 96, 0, 965, 973, 3, 198, 99, 0, 966, 973, 3, 154,
		77, 0, 967, 973, 3, 156, 78, 0, 968, 973, 5, 14, 0, 0, 969, 973, 5, 23,
		0, 0, 970, 973, 3, 200, 100, 0, 971, 973, 3, 202, 101, 0, 972, 956, 1,
		0, 0, 0, 972, 957, 1, 0, 0, 0, 972, 958, 1, 0, 0, 0, 972, 962, 1, 0, 0,
		0, 972, 963, 1, 0, 0, 0, 972, 964, 1, 0, 0, 0, 972, 965, 1, 0, 0, 0, 972,
		966, 1, 0, 0, 0, 972, 967, 1, 0, 0, 0, 972, 968, 1, 0, 0, 0, 972, 969,
		1, 0, 0, 0, 972, 970, 1, 0, 0, 0, 972, 971, 1, 0, 0, 0, 973, 151, 1, 0,
		0, 0, 974, 975, 5, 16, 0, 0, 975, 976, 3, 114, 57, 0, 976, 153, 1, 0, 0,
		0, 977, 978, 5, 6, 0, 0, 978, 980, 5, 44, 0, 0, 979, 981, 3, 62, 31, 0,
		980, 979, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982,
		984, 5, 45, 0, 0, 983, 985, 3, 208, 104, 0, 984, 983, 1, 0, 0, 0, 984,
		985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 987, 3, 100, 50, 0, 987, 155,
		1, 0, 0, 0, 988, 989, 5, 30, 0, 0, 989, 990, 3, 114, 57, 0, 990, 994, 5,
		40, 0, 0, 991, 993, 3, 216, 108, 0, 992, 991, 1, 0, 0, 0, 993, 996, 1,
		0, 0, 0, 994, 992, 1, 0, 0, 0, 994, 995, 1, 0, 0, 0, 995, 997, 1, 0, 0,
		0, 996, 994, 1, 0, 0, 0, 997, 1007, 3, 158, 79, 0, 998, 1000, 3, 216, 108,
		0, 999, 998, 1, 0, 0, 0, 1000, 1001, 1, 0, 0, 0, 1001, 999, 1, 0, 0, 0,
		1001, 1002, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 3, 158, 79,
		0, 1004, 1006, 1, 0, 0, 0, 1005, 999, 1, 0, 0, 0, 1006, 1009, 1, 0, 0,
		0, 1007, 1005, 1, 0, 0, 0, 1007, 1008, 1, 0, 0, 0, 1008, 1013, 1, 0, 0,
		0, 1009, 1007, 1, 0, 0, 0, 1010, 1012, 3, 216, 108, 0, 1011, 1010, 1, 0,
		0, 0, 1012, 1015, 1, 0, 0, 0, 1013, 1011, 1, 0, 0, 0, 1013, 1014, 1, 0,
		0, 0, 1014, 1017, 1, 0, 0, 0, 1015, 1013, 1, 0, 0, 0, 1016, 1018, 3, 160,
		80, 0, 1017, 1016, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1019, 1, 0,
		0, 0, 1019, 1020, 5, 41, 0, 0, 1020, 157, 1, 0, 0, 0, 1021, 1025, 3, 114,
		57, 0, 1022, 1023, 5, 50, 0, 0, 1023, 1026, 3, 114, 57, 0, 1024, 1026,
		3, 100, 50, 0, 1025, 1022, 1, 0, 0, 0, 1025, 1024, 1, 0, 0, 0, 1026, 1028,
		1, 0, 0, 0, 1027, 1029, 5, 51, 0, 0, 1028, 1027, 1, 0, 0, 0, 1028, 1029,
		1, 0, 0, 0, 1029, 159, 1, 0, 0, 0, 1030, 1034, 5, 37, 0, 0, 1031, 1032,
		5, 50, 0, 0, 1032, 1035, 3, 114, 57, 0, 1033, 1035, 3, 100, 50, 0, 1034,
		1031, 1, 0, 0, 0, 1034, 1033, 1, 0, 0, 0, 1035, 1037, 1, 0, 0, 0, 1036,
		1038, 5, 51, 0, 0, 1037, 1036, 1, 0, 0, 0, 1037, 1038, 1, 0, 0, 0, 1038,
		161, 1, 0, 0, 0, 1039, 1043, 5, 85, 0, 0, 1040, 1042, 3, 170, 85, 0, 1041,
		1040, 1, 0, 0, 0, 1042, 1045, 1, 0, 0, 0, 1043, 1041, 1, 0, 0, 0, 1043,
		1044, 1, 0, 0, 0, 1044, 1046, 1, 0, 0, 0, 1045, 1043, 1, 0, 0, 0, 1046,
		1047, 5, 91, 0, 0, 1047, 163, 1, 0, 0, 0, 1048, 1052, 5, 86, 0, 0, 1049,
		1051, 3, 170, 85, 0, 1050, 1049, 1, 0, 0, 0, 1051, 1054, 1, 0, 0, 0, 1052,
		1050, 1, 0, 0, 0, 1052, 1053, 1, 0, 0, 0, 1053, 1055, 1, 0, 0, 0, 1054,
		1052, 1, 0, 0, 0, 1055, 1056, 5, 94, 0, 0, 1056, 165, 1, 0, 0, 0, 1057,
		1061, 5, 87, 0, 0, 1058, 1060, 3, 170, 85, 0, 1059, 1058, 1, 0, 0, 0, 1060,
		1063, 1, 0, 0, 0, 1061, 1059, 1, 0, 0, 0, 1061, 1062, 1, 0, 0, 0, 1062,
		1064, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1064, 1065, 5, 97, 0, 0, 1065,
		167, 1, 0, 0, 0, 1066, 1070, 5, 88, 0, 0, 1067, 1069, 3, 170, 85, 0, 1068,
		1067, 1, 0, 0, 0, 1069, 1072, 1, 0, 0, 0, 1070, 1068, 1, 0, 0, 0, 1070,
		1071, 1, 0, 0, 0, 1071, 1073, 1, 0, 0, 0, 1072, 1070, 1, 0, 0, 0, 1073,
		1074, 5, 100, 0, 0, 1074, 169, 1, 0, 0, 0, 1075, 1081, 5, 90, 0, 0, 1076,
		1081, 5, 93, 0, 0, 1077, 1081, 5, 96, 0, 0, 1078, 1081, 5, 99, 0, 0, 1079,
		1081, 3, 172, 86, 0, 1080, 1075, 1, 0, 0, 0, 1080, 1076, 1, 0, 0, 0, 1080,
		1077, 1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1079, 1, 0, 0, 0, 1081,
		171, 1, 0, 0, 0, 1082, 1083, 7, 6, 0, 0, 1083, 1084, 3, 114, 57, 0, 1084,
		1085, 5, 102, 0, 0, 1085, 173, 1, 0, 0, 0, 1086, 1092, 3, 176, 88, 0, 1087,
		1092, 3, 178, 89, 0, 1088, 1092, 3, 180, 90, 0, 1089, 1092, 5, 23, 0, 0,
		1090, 1092, 5, 14, 0, 0, 1091, 1086, 1, 0, 0, 0, 1091, 1087, 1, 0, 0, 0,
		1091, 1088, 1, 0, 0, 0, 1091, 1089, 1, 0, 0, 0, 1091, 1090, 1, 0, 0, 0,
		1092, 175, 1, 0, 0, 0, 1093, 1098, 3, 162, 81, 0, 1094, 1098, 3, 164, 82,
		0, 1095, 1098, 3, 166, 83, 0, 1096, 1098, 3, 168, 84, 0, 1097, 1093, 1,
		0, 0, 0, 1097, 1094, 1, 0, 0, 0, 1097, 1095, 1, 0, 0, 0, 1097, 1096, 1,
		0, 0, 0, 1098, 177, 1, 0, 0, 0, 1099, 1105, 5, 83, 0, 0, 1100, 1105, 5,
		82, 0, 0, 1101, 1105, 5, 79, 0, 0, 1102, 1105, 5, 80, 0, 0, 1103, 1105,
		5, 81, 0, 0, 1104, 1099, 1, 0, 0, 0, 1104, 1100, 1, 0, 0, 0, 1104, 1101,
		1, 0, 0, 0, 1104, 1102, 1, 0, 0, 0, 1104, 1103, 1, 0, 0, 0, 1105, 179,
		1, 0, 0, 0, 1106, 1109, 5, 28, 0, 0, 1107, 1109, 5, 29, 0, 0, 1108, 1106,
		1, 0, 0, 0, 1108, 1107, 1, 0, 0, 0, 1109, 181, 1, 0, 0, 0, 1110, 1112,
		5, 42, 0, 0, 1111, 1113, 3, 80, 40, 0, 1112, 1111, 1, 0, 0, 0, 1112, 1113,
		1, 0, 0, 0, 1113, 1114, 1, 0, 0, 0, 1114, 1115, 5, 43, 0, 0, 1115, 183,
		1, 0, 0, 0, 1116, 1118, 5, 40, 0, 0, 1117, 1119, 3, 186, 93, 0, 1118, 1117,
		1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1120, 1, 0, 0, 0, 1120, 1121,
		5, 41, 0, 0, 1121, 185, 1, 0, 0, 0, 1122, 1127, 3, 188, 94, 0, 1123, 1124,
		5, 52, 0, 0, 1124, 1126, 3, 188, 94, 0, 1125, 1123, 1, 0, 0, 0, 1126, 1129,
		1, 0, 0, 0, 1127, 1125, 1, 0, 0, 0, 1127, 1128, 1, 0, 0, 0, 1128, 1131,
		1, 0, 0, 0, 1129, 1127, 1, 0, 0, 0, 1130, 1132, 5, 52, 0, 0, 1131, 1130,
		1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0, 1132, 187, 1, 0, 0, 0, 1133, 1136,
		3, 190, 95, 0, 1134, 1135, 5, 50, 0, 0, 1135, 1137, 3, 114, 57, 0, 1136,
		1134, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 189, 1, 0, 0, 0, 1138,
		1141, 5, 84, 0, 0, 1139, 1141, 3, 176, 88, 0, 1140, 1138, 1, 0, 0, 0, 1140,
		1139, 1, 0, 0, 0, 1141, 191, 1, 0, 0, 0, 1142, 1143, 5, 42, 0, 0, 1143,
		1144, 5, 50, 0, 0, 1144, 1151, 5, 43, 0, 0, 1145, 1147, 5, 42, 0, 0, 1146,
		1148, 3, 194, 97, 0, 1147, 1146, 1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148,
		1149, 1, 0, 0, 0, 1149, 1151, 5, 43, 0, 0, 1150, 1142, 1, 0, 0, 0, 1150,
		1145, 1, 0, 0, 0, 1151, 193, 1, 0, 0, 0, 1152, 1157, 3, 196, 98, 0, 1153,
		1154, 5, 52, 0, 0, 1154, 1156, 3, 196, 98, 0, 1155, 1153, 1, 0, 0, 0, 1156,
		1159, 1, 0, 0, 0, 1157, 1155, 1, 0, 0, 0, 1157, 1158, 1, 0, 0, 0, 1158,
		1161, 1, 0, 0, 0, 1159, 1157, 1, 0, 0, 0, 1160, 1162, 5, 52, 0, 0, 1161,
		1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 195, 1, 0, 0, 0, 1163,
		1164, 3, 114, 57, 0, 1164, 1165, 5, 50, 0, 0, 1165, 1166, 3, 114, 57, 0,
		1166, 197, 1, 0, 0, 0, 1167, 1179, 5, 46, 0, 0, 1168, 1173, 3, 114, 57,
		0, 1169, 1170, 5, 52, 0, 0, 1170, 1172, 3, 114, 57, 0, 1171, 1169, 1, 0,
		0, 0, 1172, 1175, 1, 0, 0, 0, 1173, 1171, 1, 0, 0, 0, 1173, 1174, 1, 0,
		0, 0, 1174, 1177, 1, 0, 0, 0, 1175, 1173, 1, 0, 0, 0, 1176, 1178, 5, 52,
		0, 0, 1177, 1176, 1, 0, 0, 0, 1177, 1178, 1, 0, 0, 0, 1178, 1180, 1, 0,
		0, 0, 1179, 1168, 1, 0, 0, 0, 1179, 1180, 1, 0, 0, 0, 1180, 1181, 1, 0,
		0, 0, 1181, 1182, 5, 47, 0, 0, 1182, 199, 1, 0, 0, 0, 1183, 1186, 5, 84,
		0, 0, 1184, 1187, 3, 164, 82, 0, 1185, 1187, 3, 168, 84, 0, 1186, 1184,
		1, 0, 0, 0, 1186, 1185, 1, 0, 0, 0, 1187, 201, 1, 0, 0, 0, 1188, 1189,
		5, 84, 0, 0, 1189, 1191, 5, 44, 0, 0, 1190, 1192, 3, 204, 102, 0, 1191,
		1190, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193,
		1194, 5, 45, 0, 0, 1194, 203, 1, 0, 0, 0, 1195, 1200, 3, 206, 103, 0, 1196,
		1197, 5, 52, 0, 0, 1197, 1199, 3, 206, 103, 0, 1198, 1196, 1, 0, 0, 0,
		1199, 1202, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0,
		1201, 1204, 1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0, 1203, 1205, 5, 52, 0, 0,
		1204, 1203, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 205, 1, 0, 0, 0,
		1206, 1207, 5, 84, 0, 0, 1207, 1208, 5, 50, 0, 0, 1208, 1209, 3, 114, 57,
		0, 1209, 207, 1, 0, 0, 0, 1210, 1216, 5, 84, 0, 0, 1211, 1216, 3, 212,
		106, 0, 1212, 1216, 3, 210, 105, 0, 1213, 1216, 3, 214, 107, 0, 1214, 1216,
		5, 14, 0, 0, 1215, 1210, 1, 0, 0, 0, 1215, 1211, 1, 0, 0, 0, 1215, 1212,
		1, 0, 0, 0, 1215, 1213, 1, 0, 0, 0, 1215, 1214, 1, 0, 0, 0, 1216, 209,
		1, 0, 0, 0, 1217, 1219, 5, 44, 0, 0, 1218, 1220, 3, 52, 26, 0, 1219, 1218,
		1, 0, 0, 0, 1219, 1220, 1, 0, 0, 0, 1220, 1221, 1, 0, 0, 0, 1221, 1222,
		5, 45, 0, 0, 1222, 211, 1, 0, 0, 0, 1223, 1224, 5, 84, 0, 0, 1224, 1225,
		5, 42, 0, 0, 1225, 1226, 5, 43, 0, 0, 1226, 213, 1, 0, 0, 0, 1227, 1228,
		5, 6, 0, 0, 1228, 1230, 5, 44, 0, 0, 1229, 1231, 3, 62, 31, 0, 1230, 1229,
		1, 0, 0, 0, 1230, 1231, 1, 0, 0, 0, 1231, 1232, 1, 0, 0, 0, 1232, 1234,
		5, 45, 0, 0, 1233, 1235, 3, 208, 104, 0, 1234, 1233, 1, 0, 0, 0, 1234,
		1235, 1, 0, 0, 0, 1235, 215, 1, 0, 0, 0, 1236, 1237, 7, 7, 0, 0, 1237,
		217, 1, 0, 0, 0, 155, 221, 228, 234, 237, 242, 255, 260, 265, 270, 276,
		280, 284, 299, 303, 308, 313, 318, 323, 328, 330, 336, 338, 342, 349, 356,
		362, 368, 373, 391, 410, 414, 418, 424, 428, 434, 441, 448, 454, 460, 464,
		469, 472, 480, 487, 491, 495, 504, 508, 514, 520, 527, 532, 539, 543, 546,
		555, 559, 562, 569, 573, 579, 587, 594, 601, 607, 613, 622, 636, 639, 643,
		646, 650, 653, 658, 665, 669, 676, 685, 691, 702, 706, 710, 720, 727, 733,
		736, 741, 750, 757, 763, 766, 771, 778, 782, 789, 795, 799, 802, 807, 820,
		831, 841, 852, 863, 874, 885, 899, 912, 923, 929, 940, 945, 954, 972, 980,
		984, 994, 1001, 1007, 1013, 1017, 1025, 1028, 1034, 1037, 1043, 1052, 1061,
		1070, 1080, 1091, 1097, 1104, 1108, 1112, 1118, 1127, 1131, 1136, 1140,
		1147, 1150, 1157, 1161, 1173, 1177, 1179, 1186, 1191, 1200, 1204, 1215,
		1219, 1230, 1234,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                           = antlr.TokenEOF
	ManuscriptNEWLINE                       = 1
	ManuscriptWS                            = 2
	ManuscriptCOMMENT                       = 3
	ManuscriptMULTI_LINE_COMMENT            = 4
	ManuscriptLET                           = 5
	ManuscriptFN                            = 6
	ManuscriptRETURN                        = 7
	ManuscriptYIELD                         = 8
	ManuscriptTYPE                          = 9
	ManuscriptINTERFACE                     = 10
	ManuscriptIMPORT                        = 11
	ManuscriptEXPORT                        = 12
	ManuscriptEXTERN                        = 13
	ManuscriptVOID                          = 14
	ManuscriptCHECK                         = 15
	ManuscriptTRY                           = 16
	ManuscriptCATCH                         = 17
	ManuscriptIN                            = 18
	ManuscriptAS                            = 19
	ManuscriptIS                            = 20
	ManuscriptEXTENDS                       = 21
	ManuscriptFROM                          = 22
	ManuscriptNULL                          = 23
	ManuscriptIF                            = 24
	ManuscriptELSE                          = 25
	ManuscriptFOR                           = 26
	ManuscriptWHILE                         = 27
	ManuscriptTRUE                          = 28
	ManuscriptFALSE                         = 29
	ManuscriptMATCH                         = 30
	ManuscriptCASE                          = 31
	ManuscriptASYNC                         = 32
	ManuscriptAWAIT                         = 33
	ManuscriptMETHODS                       = 34
	ManuscriptBREAK                         = 35
	ManuscriptCONTINUE                      = 36
	ManuscriptDEFAULT                       = 37
	ManuscriptDEFER                         = 38
	ManuscriptGO                            = 39
	ManuscriptLBRACE                        = 40
	ManuscriptRBRACE                        = 41
	ManuscriptLSQBR                         = 42
	ManuscriptRSQBR                         = 43
	ManuscriptLPAREN                        = 44
	ManuscriptRPAREN                        = 45
	ManuscriptLT                            = 46
	ManuscriptGT                            = 47
	ManuscriptLT_EQUALS                     = 48
	ManuscriptGT_EQUALS                     = 49
	ManuscriptCOLON                         = 50
	ManuscriptSEMICOLON                     = 51
	ManuscriptCOMMA                         = 52
	ManuscriptEQUALS                        = 53
	ManuscriptEQUALS_EQUALS                 = 54
	ManuscriptPLUS                          = 55
	ManuscriptMINUS                         = 56
	ManuscriptPLUS_PLUS                     = 57
	ManuscriptMINUS_MINUS                   = 58
	ManuscriptPIPE_PIPE                     = 59
	ManuscriptAMP_AMP                       = 60
	ManuscriptSTAR                          = 61
	ManuscriptSLASH                         = 62
	ManuscriptMOD                           = 63
	ManuscriptEXCLAMATION                   = 64
	ManuscriptQUESTION                      = 65
	ManuscriptDOT                           = 66
	ManuscriptNEQ                           = 67
	ManuscriptPLUS_EQUALS                   = 68
	ManuscriptMINUS_EQUALS                  = 69
	ManuscriptSTAR_EQUALS                   = 70
	ManuscriptSLASH_EQUALS                  = 71
	ManuscriptMOD_EQUALS                    = 72
	ManuscriptCARET_EQUALS                  = 73
	ManuscriptPIPE                          = 74
	ManuscriptAMP                           = 75
	ManuscriptCARET                         = 76
	ManuscriptLSHIFT                        = 77
	ManuscriptRSHIFT                        = 78
	ManuscriptHEX_LITERAL                   = 79
	ManuscriptBINARY_LITERAL                = 80
	ManuscriptOCTAL_LITERAL                 = 81
	ManuscriptFLOAT                         = 82
	ManuscriptINTEGER                       = 83
	ManuscriptID                            = 84
	ManuscriptSINGLE_QUOTE_START            = 85
	ManuscriptMULTI_QUOTE_START             = 86
	ManuscriptDOUBLE_QUOTE_START            = 87
	ManuscriptMULTI_DOUBLE_QUOTE_START      = 88
	ManuscriptSINGLE_STR_INTERP_START       = 89
	ManuscriptSINGLE_STR_CONTENT            = 90
	ManuscriptSINGLE_STR_END                = 91
	ManuscriptMULTI_STR_INTERP_START        = 92
	ManuscriptMULTI_STR_CONTENT             = 93
	ManuscriptMULTI_STR_END                 = 94
	ManuscriptDOUBLE_STR_INTERP_START       = 95
	ManuscriptDOUBLE_STR_CONTENT            = 96
	ManuscriptDOUBLE_STR_END                = 97
	ManuscriptMULTI_DOUBLE_STR_INTERP_START = 98
	ManuscriptMULTI_DOUBLE_STR_CONTENT      = 99
	ManuscriptMULTI_DOUBLE_STR_END          = 100
	ManuscriptINTERP_LBRACE                 = 101
	ManuscriptINTERP_RBRACE                 = 102
	ManuscriptINTERP_WS                     = 103
)

// Manuscript rules.
const (
	ManuscriptRULE_program                 = 0
	ManuscriptRULE_declaration             = 1
	ManuscriptRULE_importDecl              = 2
	ManuscriptRULE_exportDecl              = 3
	ManuscriptRULE_externDecl              = 4
	ManuscriptRULE_exportedItem            = 5
	ManuscriptRULE_moduleImport            = 6
	ManuscriptRULE_destructuredImport      = 7
	ManuscriptRULE_targetImport            = 8
	ManuscriptRULE_importItemList          = 9
	ManuscriptRULE_importItem              = 10
	ManuscriptRULE_letDecl                 = 11
	ManuscriptRULE_letSingle               = 12
	ManuscriptRULE_letBlock                = 13
	ManuscriptRULE_letBlockItemList        = 14
	ManuscriptRULE_letBlockItemSep         = 15
	ManuscriptRULE_letBlockItem            = 16
	ManuscriptRULE_letDestructuredObj      = 17
	ManuscriptRULE_letDestructuredArray    = 18
	ManuscriptRULE_typedIDList             = 19
	ManuscriptRULE_typedID                 = 20
	ManuscriptRULE_typeDecl                = 21
	ManuscriptRULE_typeDefBody             = 22
	ManuscriptRULE_typeAlias               = 23
	ManuscriptRULE_fieldList               = 24
	ManuscriptRULE_fieldDecl               = 25
	ManuscriptRULE_typeList                = 26
	ManuscriptRULE_interfaceDecl           = 27
	ManuscriptRULE_interfaceMethod         = 28
	ManuscriptRULE_fnDecl                  = 29
	ManuscriptRULE_fnSignature             = 30
	ManuscriptRULE_parameters              = 31
	ManuscriptRULE_param                   = 32
	ManuscriptRULE_methodsDecl             = 33
	ManuscriptRULE_methodImplList          = 34
	ManuscriptRULE_methodImpl              = 35
	ManuscriptRULE_stmt                    = 36
	ManuscriptRULE_returnStmt              = 37
	ManuscriptRULE_yieldStmt               = 38
	ManuscriptRULE_deferStmt               = 39
	ManuscriptRULE_exprList                = 40
	ManuscriptRULE_ifStmt                  = 41
	ManuscriptRULE_forStmt                 = 42
	ManuscriptRULE_forLoopType             = 43
	ManuscriptRULE_forTrinity              = 44
	ManuscriptRULE_forInit                 = 45
	ManuscriptRULE_forCond                 = 46
	ManuscriptRULE_forPost                 = 47
	ManuscriptRULE_whileStmt               = 48
	ManuscriptRULE_loopBody                = 49
	ManuscriptRULE_codeBlock               = 50
	ManuscriptRULE_breakStmt               = 51
	ManuscriptRULE_continueStmt            = 52
	ManuscriptRULE_checkStmt               = 53
	ManuscriptRULE_pipedStmt               = 54
	ManuscriptRULE_pipedArgs               = 55
	ManuscriptRULE_pipedArg                = 56
	ManuscriptRULE_expr                    = 57
	ManuscriptRULE_assignmentExpr          = 58
	ManuscriptRULE_assignmentOp            = 59
	ManuscriptRULE_ternaryExpr             = 60
	ManuscriptRULE_logicalOrExpr           = 61
	ManuscriptRULE_logicalAndExpr          = 62
	ManuscriptRULE_bitwiseXorExpr          = 63
	ManuscriptRULE_bitwiseAndExpr          = 64
	ManuscriptRULE_equalityExpr            = 65
	ManuscriptRULE_comparisonOp            = 66
	ManuscriptRULE_comparisonExpr          = 67
	ManuscriptRULE_shiftExpr               = 68
	ManuscriptRULE_additiveExpr            = 69
	ManuscriptRULE_multiplicativeExpr      = 70
	ManuscriptRULE_unaryExpr               = 71
	ManuscriptRULE_awaitExpr               = 72
	ManuscriptRULE_postfixExpr             = 73
	ManuscriptRULE_postfixOp               = 74
	ManuscriptRULE_primaryExpr             = 75
	ManuscriptRULE_tryExpr                 = 76
	ManuscriptRULE_fnExpr                  = 77
	ManuscriptRULE_matchExpr               = 78
	ManuscriptRULE_caseClause              = 79
	ManuscriptRULE_defaultClause           = 80
	ManuscriptRULE_singleQuotedString      = 81
	ManuscriptRULE_multiQuotedString       = 82
	ManuscriptRULE_doubleQuotedString      = 83
	ManuscriptRULE_multiDoubleQuotedString = 84
	ManuscriptRULE_stringPart              = 85
	ManuscriptRULE_interpolation           = 86
	ManuscriptRULE_literal                 = 87
	ManuscriptRULE_stringLiteral           = 88
	ManuscriptRULE_numberLiteral           = 89
	ManuscriptRULE_booleanLiteral          = 90
	ManuscriptRULE_arrayLiteral            = 91
	ManuscriptRULE_objectLiteral           = 92
	ManuscriptRULE_objectFieldList         = 93
	ManuscriptRULE_objectField             = 94
	ManuscriptRULE_objectFieldName         = 95
	ManuscriptRULE_mapLiteral              = 96
	ManuscriptRULE_mapFieldList            = 97
	ManuscriptRULE_mapField                = 98
	ManuscriptRULE_setLiteral              = 99
	ManuscriptRULE_taggedBlockString       = 100
	ManuscriptRULE_structInitExpr          = 101
	ManuscriptRULE_structFieldList         = 102
	ManuscriptRULE_structField             = 103
	ManuscriptRULE_typeAnnotation          = 104
	ManuscriptRULE_tupleType               = 105
	ManuscriptRULE_arrayType               = 106
	ManuscriptRULE_fnType                  = 107
	ManuscriptRULE_stmt_sep                = 108
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *ProgramContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(221)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(218)
				p.Stmt_sep()
			}

		}
		p.SetState(223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17179885152) != 0 {
		{
			p.SetState(224)
			p.Declaration()
		}
		p.SetState(234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(226)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(225)
						p.Stmt_sep()
					}

					p.SetState(228)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(230)
					p.Declaration()
				}

			}
			p.SetState(236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(239)
			p.Stmt_sep()
		}

		p.SetState(244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(245)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ImportDecl() IImportDeclContext
	ExportDecl() IExportDeclContext
	ExternDecl() IExternDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext
	FnDecl() IFnDeclContext
	MethodsDecl() IMethodsDeclContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) ImportDecl() IImportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *DeclarationContext) ExportDecl() IExportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportDeclContext)
}

func (s *DeclarationContext) ExternDecl() IExternDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternDeclContext)
}

func (s *DeclarationContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *DeclarationContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclarationContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *DeclarationContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *DeclarationContext) MethodsDecl() IMethodsDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodsDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodsDeclContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_declaration)
	p.SetState(255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptIMPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.ImportDecl()
		}

	case ManuscriptEXPORT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(248)
			p.ExportDecl()
		}

	case ManuscriptEXTERN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(249)
			p.ExternDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(250)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(251)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(252)
			p.InterfaceDecl()
		}

	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(253)
			p.FnDecl()
		}

	case ManuscriptMETHODS:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(254)
			p.MethodsDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ImportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(257)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)
		p.ModuleImport()
	}
	p.SetState(260)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(259)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportDeclContext is an interface to support dynamic dispatch.
type IExportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	ExportedItem() IExportedItemContext
	SEMICOLON() antlr.TerminalNode

	// IsExportDeclContext differentiates from other interfaces.
	IsExportDeclContext()
}

type ExportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportDeclContext() *ExportDeclContext {
	var p = new(ExportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
	return p
}

func InitEmptyExportDeclContext(p *ExportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
}

func (*ExportDeclContext) IsExportDeclContext() {}

func NewExportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportDeclContext {
	var p = new(ExportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportDecl

	return p
}

func (s *ExportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportDeclContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportDeclContext) ExportedItem() IExportedItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedItemContext)
}

func (s *ExportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportDecl(s)
	}
}

func (s *ExportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportDecl(s)
	}
}

func (s *ExportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportDecl() (localctx IExportDeclContext) {
	localctx = NewExportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_exportDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(262)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(263)
		p.ExportedItem()
	}
	p.SetState(265)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(264)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternDeclContext is an interface to support dynamic dispatch.
type IExternDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsExternDeclContext differentiates from other interfaces.
	IsExternDeclContext()
}

type ExternDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternDeclContext() *ExternDeclContext {
	var p = new(ExternDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
	return p
}

func InitEmptyExternDeclContext(p *ExternDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
}

func (*ExternDeclContext) IsExternDeclContext() {}

func NewExternDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternDeclContext {
	var p = new(ExternDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externDecl

	return p
}

func (s *ExternDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternDeclContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ExternDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExternDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternDecl(s)
	}
}

func (s *ExternDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternDecl(s)
	}
}

func (s *ExternDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternDecl() (localctx IExternDeclContext) {
	localctx = NewExternDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_externDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(267)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(268)
		p.ModuleImport()
	}
	p.SetState(270)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(269)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportedItemContext is an interface to support dynamic dispatch.
type IExportedItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnDecl() IFnDeclContext
	LetDecl() ILetDeclContext
	TypeDecl() ITypeDeclContext
	InterfaceDecl() IInterfaceDeclContext

	// IsExportedItemContext differentiates from other interfaces.
	IsExportedItemContext()
}

type ExportedItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportedItemContext() *ExportedItemContext {
	var p = new(ExportedItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
	return p
}

func InitEmptyExportedItemContext(p *ExportedItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
}

func (*ExportedItemContext) IsExportedItemContext() {}

func NewExportedItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportedItemContext {
	var p = new(ExportedItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportedItem

	return p
}

func (s *ExportedItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportedItemContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportedItemContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportedItemContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportedItemContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ExportedItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportedItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedItem(s)
	}
}

func (s *ExportedItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedItem(s)
	}
}

func (s *ExportedItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportedItem() (localctx IExportedItemContext) {
	localctx = NewExportedItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_exportedItem)
	p.SetState(276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.FnDecl()
		}

	case ManuscriptLET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(273)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(274)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(275)
			p.InterfaceDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleImportContext is an interface to support dynamic dispatch.
type IModuleImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DestructuredImport() IDestructuredImportContext
	TargetImport() ITargetImportContext

	// IsModuleImportContext differentiates from other interfaces.
	IsModuleImportContext()
}

type ModuleImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleImportContext() *ModuleImportContext {
	var p = new(ModuleImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
	return p
}

func InitEmptyModuleImportContext(p *ModuleImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
}

func (*ModuleImportContext) IsModuleImportContext() {}

func NewModuleImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleImportContext {
	var p = new(ModuleImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_moduleImport

	return p
}

func (s *ModuleImportContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleImportContext) DestructuredImport() IDestructuredImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestructuredImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestructuredImportContext)
}

func (s *ModuleImportContext) TargetImport() ITargetImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetImportContext)
}

func (s *ModuleImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterModuleImport(s)
	}
}

func (s *ModuleImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitModuleImport(s)
	}
}

func (s *ModuleImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitModuleImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ModuleImport() (localctx IModuleImportContext) {
	localctx = NewModuleImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_moduleImport)
	p.SetState(280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(278)
			p.DestructuredImport()
		}

	case ManuscriptID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(279)
			p.TargetImport()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestructuredImportContext is an interface to support dynamic dispatch.
type IDestructuredImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext
	ImportItemList() IImportItemListContext

	// IsDestructuredImportContext differentiates from other interfaces.
	IsDestructuredImportContext()
}

type DestructuredImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestructuredImportContext() *DestructuredImportContext {
	var p = new(DestructuredImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
	return p
}

func InitEmptyDestructuredImportContext(p *DestructuredImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
}

func (*DestructuredImportContext) IsDestructuredImportContext() {}

func NewDestructuredImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestructuredImportContext {
	var p = new(DestructuredImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_destructuredImport

	return p
}

func (s *DestructuredImportContext) GetParser() antlr.Parser { return s.parser }

func (s *DestructuredImportContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *DestructuredImportContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *DestructuredImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *DestructuredImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *DestructuredImportContext) ImportItemList() IImportItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemListContext)
}

func (s *DestructuredImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestructuredImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestructuredImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDestructuredImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DestructuredImport() (localctx IDestructuredImportContext) {
	localctx = NewDestructuredImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_destructuredImport)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(282)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(283)
			p.ImportItemList()
		}

	}
	{
		p.SetState(286)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(287)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(288)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetImportContext is an interface to support dynamic dispatch.
type ITargetImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	FROM() antlr.TerminalNode
	SingleQuotedString() ISingleQuotedStringContext

	// IsTargetImportContext differentiates from other interfaces.
	IsTargetImportContext()
}

type TargetImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetImportContext() *TargetImportContext {
	var p = new(TargetImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
	return p
}

func InitEmptyTargetImportContext(p *TargetImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
}

func (*TargetImportContext) IsTargetImportContext() {}

func NewTargetImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetImportContext {
	var p = new(TargetImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_targetImport

	return p
}

func (s *TargetImportContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetImportContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TargetImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *TargetImportContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *TargetImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTargetImport(s)
	}
}

func (s *TargetImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTargetImport(s)
	}
}

func (s *TargetImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTargetImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TargetImport() (localctx ITargetImportContext) {
	localctx = NewTargetImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_targetImport)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(290)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(291)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(292)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemListContext is an interface to support dynamic dispatch.
type IImportItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportItem() []IImportItemContext
	ImportItem(i int) IImportItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportItemListContext differentiates from other interfaces.
	IsImportItemListContext()
}

type ImportItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemListContext() *ImportItemListContext {
	var p = new(ImportItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
	return p
}

func InitEmptyImportItemListContext(p *ImportItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
}

func (*ImportItemListContext) IsImportItemListContext() {}

func NewImportItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemListContext {
	var p = new(ImportItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItemList

	return p
}

func (s *ImportItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemListContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *ImportItemListContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *ImportItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ImportItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ImportItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItemList(s)
	}
}

func (s *ImportItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItemList(s)
	}
}

func (s *ImportItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItemList() (localctx IImportItemListContext) {
	localctx = NewImportItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_importItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.ImportItem()
	}
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(295)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(296)
				p.ImportItem()
			}

		}
		p.SetState(301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(302)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(308)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(306)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(307)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	LetSingle() ILetSingleContext
	SEMICOLON() antlr.TerminalNode
	LetBlock() ILetBlockContext
	LetDestructuredObj() ILetDestructuredObjContext
	LetDestructuredArray() ILetDestructuredArrayContext

	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LetDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclContext) LetBlock() ILetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockContext)
}

func (s *LetDeclContext) LetDestructuredObj() ILetDestructuredObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredObjContext)
}

func (s *LetDeclContext) LetDestructuredArray() ILetDestructuredArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredArrayContext)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDecl(s)
	}
}

func (s *LetDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDecl(s)
	}
}

func (s *LetDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_letDecl)
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(310)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(311)
			p.LetSingle()
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(315)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(316)
			p.LetBlock()
		}
		p.SetState(318)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(317)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(320)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(321)
			p.LetDestructuredObj()
		}
		p.SetState(323)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(322)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(325)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(326)
			p.LetDestructuredArray()
		}
		p.SetState(328)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(327)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetSingleContext is an interface to support dynamic dispatch.
type ILetSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedID() ITypedIDContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext
	TryExpr() ITryExprContext

	// IsLetSingleContext differentiates from other interfaces.
	IsLetSingleContext()
}

type LetSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetSingleContext() *LetSingleContext {
	var p = new(LetSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
	return p
}

func InitEmptyLetSingleContext(p *LetSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
}

func (*LetSingleContext) IsLetSingleContext() {}

func NewLetSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetSingleContext {
	var p = new(LetSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letSingle

	return p
}

func (s *LetSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LetSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetSingleContext) TryExpr() ITryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExprContext)
}

func (s *LetSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetSingle(s)
	}
}

func (s *LetSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetSingle(s)
	}
}

func (s *LetSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetSingle() (localctx ILetSingleContext) {
	localctx = NewLetSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_letSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(332)
		p.TypedID()
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(333)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
			{
				p.SetState(334)
				p.Expr()
			}

		case ManuscriptTRY:
			{
				p.SetState(335)
				p.TryExpr()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockContext is an interface to support dynamic dispatch.
type ILetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LetBlockItemList() ILetBlockItemListContext

	// IsLetBlockContext differentiates from other interfaces.
	IsLetBlockContext()
}

type LetBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockContext() *LetBlockContext {
	var p = new(LetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
	return p
}

func InitEmptyLetBlockContext(p *LetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
}

func (*LetBlockContext) IsLetBlockContext() {}

func NewLetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockContext {
	var p = new(LetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlock

	return p
}

func (s *LetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LetBlockContext) LetBlockItemList() ILetBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemListContext)
}

func (s *LetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlock(s)
	}
}

func (s *LetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlock(s)
	}
}

func (s *LetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlock() (localctx ILetBlockContext) {
	localctx = NewLetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_letBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6760896999194626) != 0) || _la == ManuscriptID {
		{
			p.SetState(341)
			p.LetBlockItemList()
		}

	}
	{
		p.SetState(344)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemListContext is an interface to support dynamic dispatch.
type ILetBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetBlockItem() []ILetBlockItemContext
	LetBlockItem(i int) ILetBlockItemContext
	AllLetBlockItemSep() []ILetBlockItemSepContext
	LetBlockItemSep(i int) ILetBlockItemSepContext

	// IsLetBlockItemListContext differentiates from other interfaces.
	IsLetBlockItemListContext()
}

type LetBlockItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemListContext() *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
	return p
}

func InitEmptyLetBlockItemListContext(p *LetBlockItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
}

func (*LetBlockItemListContext) IsLetBlockItemListContext() {}

func NewLetBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemList

	return p
}

func (s *LetBlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemListContext) AllLetBlockItem() []ILetBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemContext); ok {
			tst[i] = t.(ILetBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItem(i int) ILetBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemContext)
}

func (s *LetBlockItemListContext) AllLetBlockItemSep() []ILetBlockItemSepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemSepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemSepContext); ok {
			tst[i] = t.(ILetBlockItemSepContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItemSep(i int) ILetBlockItemSepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemSepContext)
}

func (s *LetBlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemList() (localctx ILetBlockItemListContext) {
	localctx = NewLetBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_letBlockItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(346)
			p.LetBlockItemSep()
		}

		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(352)
		p.LetBlockItem()
	}
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(354)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0) {
				{
					p.SetState(353)
					p.LetBlockItemSep()
				}

				p.SetState(356)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(358)
				p.LetBlockItem()
			}

		}
		p.SetState(364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(365)
			p.LetBlockItemSep()
		}

		p.SetState(370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemSepContext is an interface to support dynamic dispatch.
type ILetBlockItemSepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	Stmt_sep() IStmt_sepContext

	// IsLetBlockItemSepContext differentiates from other interfaces.
	IsLetBlockItemSepContext()
}

type LetBlockItemSepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemSepContext() *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
	return p
}

func InitEmptyLetBlockItemSepContext(p *LetBlockItemSepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
}

func (*LetBlockItemSepContext) IsLetBlockItemSepContext() {}

func NewLetBlockItemSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemSep

	return p
}

func (s *LetBlockItemSepContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemSepContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LetBlockItemSepContext) Stmt_sep() IStmt_sepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LetBlockItemSepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemSepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemSep() (localctx ILetBlockItemSepContext) {
	localctx = NewLetBlockItemSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_letBlockItemSep)
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptNEWLINE, ManuscriptSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(372)
			p.Stmt_sep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemContext is an interface to support dynamic dispatch.
type ILetBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetBlockItemContext differentiates from other interfaces.
	IsLetBlockItemContext()
}

type LetBlockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemContext() *LetBlockItemContext {
	var p = new(LetBlockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
	return p
}

func InitEmptyLetBlockItemContext(p *LetBlockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
}

func (*LetBlockItemContext) IsLetBlockItemContext() {}

func NewLetBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemContext {
	var p = new(LetBlockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItem

	return p
}

func (s *LetBlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemContext) CopyAll(ctx *LetBlockItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetBlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLetBlockItemDestructuredObjContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemDestructuredObjContext {
	var p = new(LabelLetBlockItemDestructuredObjContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LabelLetBlockItemDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemDestructuredObj(s)
	}
}

func (s *LabelLetBlockItemDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemDestructuredObj(s)
	}
}

func (s *LabelLetBlockItemDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetBlockItemDestructuredArrayContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemDestructuredArrayContext {
	var p = new(LabelLetBlockItemDestructuredArrayContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LabelLetBlockItemDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemDestructuredArray(s)
	}
}

func (s *LabelLetBlockItemDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemDestructuredArray(s)
	}
}

func (s *LabelLetBlockItemDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLetBlockItemSingleContext struct {
	LetBlockItemContext
}

func NewLabelLetBlockItemSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLetBlockItemSingleContext {
	var p = new(LabelLetBlockItemSingleContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LabelLetBlockItemSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLetBlockItemSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LabelLetBlockItemSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LabelLetBlockItemSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelLetBlockItemSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLetBlockItemSingle(s)
	}
}

func (s *LabelLetBlockItemSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLetBlockItemSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItem() (localctx ILetBlockItemContext) {
	localctx = NewLetBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_letBlockItem)
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelLetBlockItemSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(375)
			p.TypedID()
		}
		{
			p.SetState(376)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Expr()
		}

	case ManuscriptLBRACE:
		localctx = NewLabelLetBlockItemDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(379)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.TypedIDList()
		}
		{
			p.SetState(381)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(382)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(383)
			p.Expr()
		}

	case ManuscriptLSQBR:
		localctx = NewLabelLetBlockItemDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(385)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(386)
			p.TypedIDList()
		}
		{
			p.SetState(387)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(388)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(389)
			p.Expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredObjContext is an interface to support dynamic dispatch.
type ILetDestructuredObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RBRACE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredObjContext differentiates from other interfaces.
	IsLetDestructuredObjContext()
}

type LetDestructuredObjContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredObjContext() *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
	return p
}

func InitEmptyLetDestructuredObjContext(p *LetDestructuredObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
}

func (*LetDestructuredObjContext) IsLetDestructuredObjContext() {}

func NewLetDestructuredObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredObj

	return p
}

func (s *LetDestructuredObjContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredObj() (localctx ILetDestructuredObjContext) {
	localctx = NewLetDestructuredObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_letDestructuredObj)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(394)
		p.TypedIDList()
	}
	{
		p.SetState(395)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(396)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredArrayContext is an interface to support dynamic dispatch.
type ILetDestructuredArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RSQBR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredArrayContext differentiates from other interfaces.
	IsLetDestructuredArrayContext()
}

type LetDestructuredArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredArrayContext() *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
	return p
}

func InitEmptyLetDestructuredArrayContext(p *LetDestructuredArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
}

func (*LetDestructuredArrayContext) IsLetDestructuredArrayContext() {}

func NewLetDestructuredArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredArray

	return p
}

func (s *LetDestructuredArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredArray() (localctx ILetDestructuredArrayContext) {
	localctx = NewLetDestructuredArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_letDestructuredArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(399)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(400)
		p.TypedIDList()
	}
	{
		p.SetState(401)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(402)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(403)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDListContext is an interface to support dynamic dispatch.
type ITypedIDListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedID() []ITypedIDContext
	TypedID(i int) ITypedIDContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedIDListContext differentiates from other interfaces.
	IsTypedIDListContext()
}

type TypedIDListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDListContext() *TypedIDListContext {
	var p = new(TypedIDListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
	return p
}

func InitEmptyTypedIDListContext(p *TypedIDListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
}

func (*TypedIDListContext) IsTypedIDListContext() {}

func NewTypedIDListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDListContext {
	var p = new(TypedIDListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedIDList

	return p
}

func (s *TypedIDListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDListContext) AllTypedID() []ITypedIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIDContext); ok {
			len++
		}
	}

	tst := make([]ITypedIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIDContext); ok {
			tst[i] = t.(ITypedIDContext)
			i++
		}
	}

	return tst
}

func (s *TypedIDListContext) TypedID(i int) ITypedIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *TypedIDListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypedIDListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypedIDListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedIDList(s)
	}
}

func (s *TypedIDListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedIDList(s)
	}
}

func (s *TypedIDListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedIDList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedIDList() (localctx ITypedIDListContext) {
	localctx = NewTypedIDListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_typedIDList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(405)
		p.TypedID()
	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(406)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(407)
				p.TypedID()
			}

		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(413)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDContext is an interface to support dynamic dispatch.
type ITypedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsTypedIDContext differentiates from other interfaces.
	IsTypedIDContext()
}

type TypedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDContext() *TypedIDContext {
	var p = new(TypedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
	return p
}

func InitEmptyTypedIDContext(p *TypedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
}

func (*TypedIDContext) IsTypedIDContext() {}

func NewTypedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDContext {
	var p = new(TypedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedID

	return p
}

func (s *TypedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypedIDContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedID(s)
	}
}

func (s *TypedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedID(s)
	}
}

func (s *TypedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedID() (localctx ITypedIDContext) {
	localctx = NewTypedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_typedID)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(417)
			p.TypeAnnotation()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	ID() antlr.TerminalNode
	TypeDefBody() ITypeDefBodyContext
	TypeAlias() ITypeAliasContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeDeclContext) TypeDefBody() ITypeDefBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefBodyContext)
}

func (s *TypeDeclContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_typeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(421)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(424)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEXTENDS, ManuscriptLBRACE:
		{
			p.SetState(422)
			p.TypeDefBody()
		}

	case ManuscriptEQUALS:
		{
			p.SetState(423)
			p.TypeAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefBodyContext is an interface to support dynamic dispatch.
type ITypeDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDefBodyContext differentiates from other interfaces.
	IsTypeDefBodyContext()
}

type TypeDefBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefBodyContext() *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
	return p
}

func InitEmptyTypeDefBodyContext(p *TypeDefBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
}

func (*TypeDefBodyContext) IsTypeDefBodyContext() {}

func NewTypeDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDefBody

	return p
}

func (s *TypeDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDefBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDefBodyContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDefBodyContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeDefBodyContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDefBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *TypeDefBodyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDefBodyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDefBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDefBody() (localctx ITypeDefBodyContext) {
	localctx = NewTypeDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_typeDefBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(426)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.TypeList()
		}

	}
	{
		p.SetState(430)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(431)
				p.Stmt_sep()
			}

			p.SetState(436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(437)
			p.FieldDecl()
		}
		p.SetState(454)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(441)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(438)
						p.Stmt_sep()
					}

					p.SetState(443)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(444)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(448)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(445)
						p.Stmt_sep()
					}

					p.SetState(450)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(451)
					p.FieldDecl()
				}

			}
			p.SetState(456)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(464)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) == 1 {
			p.SetState(460)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(457)
					p.Stmt_sep()
				}

				p.SetState(462)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(463)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(466)
				p.Stmt_sep()
			}

			p.SetState(471)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(474)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *TypeAliasContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAliasContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeAliasContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(477)
		p.TypeAnnotation()
	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(478)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(479)
			p.TypeList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		p.FieldDecl()
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(483)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(484)
				p.FieldDecl()
			}

		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(490)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(493)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(494)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(497)
		p.TypeAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.TypeAnnotation()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(500)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(501)
				p.TypeAnnotation()
			}

		}
		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(507)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *InterfaceDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *InterfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *InterfaceDeclContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceDeclContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_interfaceDecl)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(510)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(511)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(512)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(513)
			p.TypeList()
		}

	}
	{
		p.SetState(516)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(517)
				p.Stmt_sep()
			}

			p.SetState(522)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(523)
			p.InterfaceMethod()
		}
		p.SetState(527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(524)
					p.Stmt_sep()
				}

			}
			p.SetState(529)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(534)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *InterfaceMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *InterfaceMethodContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *InterfaceMethodContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *InterfaceMethodContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(537)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(538)
			p.Parameters()
		}

	}
	{
		p.SetState(541)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(542)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(545)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnSignature() IFnSignatureContext
	CodeBlock() ICodeBlockContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_fnDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(548)
		p.FnSignature()
	}
	{
		p.SetState(549)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnSignatureContext is an interface to support dynamic dispatch.
type IFnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsFnSignatureContext differentiates from other interfaces.
	IsFnSignatureContext()
}

type FnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnSignatureContext() *FnSignatureContext {
	var p = new(FnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
	return p
}

func InitEmptyFnSignatureContext(p *FnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
}

func (*FnSignatureContext) IsFnSignatureContext() {}

func NewFnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnSignatureContext {
	var p = new(FnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnSignature

	return p
}

func (s *FnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FnSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnSignatureContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FnSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnSignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnSignatureContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnSignature(s)
	}
}

func (s *FnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnSignature(s)
	}
}

func (s *FnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnSignature() (localctx IFnSignatureContext) {
	localctx = NewFnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_fnSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(551)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(552)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(554)
			p.Parameters()
		}

	}
	{
		p.SetState(557)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(558)
			p.TypeAnnotation()
		}

	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(561)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(564)
		p.Param()
	}
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(565)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(566)
				p.Param()
			}

		}
		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(572)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(576)
		p.TypeAnnotation()
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(577)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(578)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodsDeclContext is an interface to support dynamic dispatch.
type IMethodsDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	METHODS() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MethodImplList() IMethodImplListContext

	// IsMethodsDeclContext differentiates from other interfaces.
	IsMethodsDeclContext()
}

type MethodsDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodsDeclContext() *MethodsDeclContext {
	var p = new(MethodsDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
	return p
}

func InitEmptyMethodsDeclContext(p *MethodsDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
}

func (*MethodsDeclContext) IsMethodsDeclContext() {}

func NewMethodsDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodsDeclContext {
	var p = new(MethodsDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodsDecl

	return p
}

func (s *MethodsDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodsDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodsDeclContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *MethodsDeclContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *MethodsDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *MethodsDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodsDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodsDeclContext) MethodImplList() IMethodImplListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplListContext)
}

func (s *MethodsDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodsDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodsDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodsDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodsDecl() (localctx IMethodsDeclContext) {
	localctx = NewMethodsDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_methodsDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(582)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(583)
		p.Match(ManuscriptAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(584)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(585)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		{
			p.SetState(586)
			p.MethodImplList()
		}

	}
	{
		p.SetState(589)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplListContext is an interface to support dynamic dispatch.
type IMethodImplListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsMethodImplListContext differentiates from other interfaces.
	IsMethodImplListContext()
}

type MethodImplListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplListContext() *MethodImplListContext {
	var p = new(MethodImplListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
	return p
}

func InitEmptyMethodImplListContext(p *MethodImplListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
}

func (*MethodImplListContext) IsMethodImplListContext() {}

func NewMethodImplListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplListContext {
	var p = new(MethodImplListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImplList

	return p
}

func (s *MethodImplListContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplListContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodImplListContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MethodImplListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImplList(s)
	}
}

func (s *MethodImplListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImplList(s)
	}
}

func (s *MethodImplListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImplList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImplList() (localctx IMethodImplListContext) {
	localctx = NewMethodImplListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_methodImplList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(591)
			p.Stmt_sep()
		}

		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(597)
		p.MethodImpl()
	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(599)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(598)
					p.Stmt_sep()
				}

				p.SetState(601)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(603)
				p.MethodImpl()
			}

		}
		p.SetState(609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(610)
			p.Stmt_sep()
		}

		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceMethod() IInterfaceMethodContext
	CodeBlock() ICodeBlockContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) InterfaceMethod() IInterfaceMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_methodImpl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.InterfaceMethod()
	}
	{
		p.SetState(617)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyAll(ctx *StmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelStmtIfContext struct {
	StmtContext
}

func NewLabelStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtIfContext {
	var p = new(LabelStmtIfContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtIfContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *LabelStmtIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtIf(s)
	}
}

func (s *LabelStmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtDeferContext struct {
	StmtContext
}

func NewLabelStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtDeferContext {
	var p = new(LabelStmtDeferContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtDeferContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *LabelStmtDeferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtDefer(s)
	}
}

func (s *LabelStmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtExprContext struct {
	StmtContext
}

func NewLabelStmtExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtExprContext {
	var p = new(LabelStmtExprContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelStmtExprContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelStmtExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtExpr(s)
	}
}

func (s *LabelStmtExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtForContext struct {
	StmtContext
}

func NewLabelStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtForContext {
	var p = new(LabelStmtForContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtForContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *LabelStmtForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtFor(s)
	}
}

func (s *LabelStmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtPipedContext struct {
	StmtContext
}

func NewLabelStmtPipedContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtPipedContext {
	var p = new(LabelStmtPipedContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtPipedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtPipedContext) PipedStmt() IPipedStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedStmtContext)
}

func (s *LabelStmtPipedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtPiped(s)
	}
}

func (s *LabelStmtPipedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtPiped(s)
	}
}

func (s *LabelStmtPipedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtPiped(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtContinueContext struct {
	StmtContext
}

func NewLabelStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtContinueContext {
	var p = new(LabelStmtContinueContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtContinueContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *LabelStmtContinueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtContinue(s)
	}
}

func (s *LabelStmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBlockContext struct {
	StmtContext
}

func NewLabelStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBlockContext {
	var p = new(LabelStmtBlockContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *LabelStmtBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBlock(s)
	}
}

func (s *LabelStmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtCheckContext struct {
	StmtContext
}

func NewLabelStmtCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtCheckContext {
	var p = new(LabelStmtCheckContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtCheckContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *LabelStmtCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtCheck(s)
	}
}

func (s *LabelStmtCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtYieldContext struct {
	StmtContext
}

func NewLabelStmtYieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtYieldContext {
	var p = new(LabelStmtYieldContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtYieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtYieldContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *LabelStmtYieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtYield(s)
	}
}

func (s *LabelStmtYieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtYield(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtLetContext struct {
	StmtContext
}

func NewLabelStmtLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtLetContext {
	var p = new(LabelStmtLetContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *LabelStmtLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtLet(s)
	}
}

func (s *LabelStmtLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtTryContext struct {
	StmtContext
}

func NewLabelStmtTryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtTryContext {
	var p = new(LabelStmtTryContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtTryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtTryContext) TryExpr() ITryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryExprContext)
}

func (s *LabelStmtTryContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LabelStmtTryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtTry(s)
	}
}

func (s *LabelStmtTryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtTry(s)
	}
}

func (s *LabelStmtTryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtTry(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtReturnContext struct {
	StmtContext
}

func NewLabelStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtReturnContext {
	var p = new(LabelStmtReturnContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtReturnContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *LabelStmtReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtReturn(s)
	}
}

func (s *LabelStmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtWhileContext struct {
	StmtContext
}

func NewLabelStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtWhileContext {
	var p = new(LabelStmtWhileContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtWhileContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *LabelStmtWhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtWhile(s)
	}
}

func (s *LabelStmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelStmtBreakContext struct {
	StmtContext
}

func NewLabelStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelStmtBreakContext {
	var p = new(LabelStmtBreakContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *LabelStmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelStmtBreakContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *LabelStmtBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelStmtBreak(s)
	}
}

func (s *LabelStmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_stmt)
	p.SetState(639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelStmtLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(619)
			p.LetDecl()
		}

	case 2:
		localctx = NewLabelStmtExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(620)
			p.Expr()
		}
		p.SetState(622)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(621)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewLabelStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(624)
			p.ReturnStmt()
		}

	case 4:
		localctx = NewLabelStmtYieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(625)
			p.YieldStmt()
		}

	case 5:
		localctx = NewLabelStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(626)
			p.IfStmt()
		}

	case 6:
		localctx = NewLabelStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(627)
			p.ForStmt()
		}

	case 7:
		localctx = NewLabelStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(628)
			p.WhileStmt()
		}

	case 8:
		localctx = NewLabelStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(629)
			p.CodeBlock()
		}

	case 9:
		localctx = NewLabelStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(630)
			p.BreakStmt()
		}

	case 10:
		localctx = NewLabelStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(631)
			p.ContinueStmt()
		}

	case 11:
		localctx = NewLabelStmtCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(632)
			p.CheckStmt()
		}

	case 12:
		localctx = NewLabelStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(633)
			p.DeferStmt()
		}

	case 13:
		localctx = NewLabelStmtTryContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(634)
			p.TryExpr()
		}
		p.SetState(636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(635)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		localctx = NewLabelStmtPipedContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(638)
			p.PipedStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ReturnStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_returnStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(642)
			p.ExprList()
		}

	}
	p.SetState(646)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(645)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *YieldStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_yieldStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(648)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(649)
			p.ExprList()
		}

	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(652)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFER, 0)
}

func (s *DeferStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeferStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.Match(ManuscriptDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(656)
		p.Expr()
	}
	p.SetState(658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(657)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Expr()
	}
	p.SetState(665)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(661)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(662)
				p.Expr()
			}

		}
		p.SetState(667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(668)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(672)
		p.Expr()
	}
	{
		p.SetState(673)
		p.CodeBlock()
	}
	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(674)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)
			p.CodeBlock()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	ForLoopType() IForLoopTypeContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) ForLoopType() IForLoopTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForLoopTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForLoopTypeContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(679)
		p.ForLoopType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForLoopTypeContext is an interface to support dynamic dispatch.
type IForLoopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForLoopTypeContext differentiates from other interfaces.
	IsForLoopTypeContext()
}

type ForLoopTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopTypeContext() *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
	return p
}

func InitEmptyForLoopTypeContext(p *ForLoopTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
}

func (*ForLoopTypeContext) IsForLoopTypeContext() {}

func NewForLoopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forLoopType

	return p
}

func (s *ForLoopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopTypeContext) CopyAll(ctx *ForLoopTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForLoopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForLoopContext {
	var p = new(LabelForLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForLoopContext) ForTrinity() IForTrinityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForTrinityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForTrinityContext)
}

func (s *LabelForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForLoop(s)
	}
}

func (s *LabelForLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInLoopContext struct {
	ForLoopTypeContext
}

func NewLabelForInLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInLoopContext {
	var p = new(LabelForInLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *LabelForInLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInLoopContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *LabelForInLoopContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForInLoopContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *LabelForInLoopContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *LabelForInLoopContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *LabelForInLoopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LabelForInLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInLoop(s)
	}
}

func (s *LabelForInLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForLoopType() (localctx IForLoopTypeContext) {
	localctx = NewForLoopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_forLoopType)
	var _la int

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.ForTrinity()
		}

	case 2:
		localctx = NewLabelForInLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(683)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(684)
				p.Match(ManuscriptID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(687)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(688)
			p.Expr()
		}
		{
			p.SetState(689)
			p.LoopBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForTrinityContext is an interface to support dynamic dispatch.
type IForTrinityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForInit() IForInitContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	ForCond() IForCondContext
	ForPost() IForPostContext
	LoopBody() ILoopBodyContext

	// IsForTrinityContext differentiates from other interfaces.
	IsForTrinityContext()
}

type ForTrinityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForTrinityContext() *ForTrinityContext {
	var p = new(ForTrinityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
	return p
}

func InitEmptyForTrinityContext(p *ForTrinityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
}

func (*ForTrinityContext) IsForTrinityContext() {}

func NewForTrinityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForTrinityContext {
	var p = new(ForTrinityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forTrinity

	return p
}

func (s *ForTrinityContext) GetParser() antlr.Parser { return s.parser }

func (s *ForTrinityContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForTrinityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForTrinityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForTrinityContext) ForCond() IForCondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForCondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForCondContext)
}

func (s *ForTrinityContext) ForPost() IForPostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForPostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForPostContext)
}

func (s *ForTrinityContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForTrinityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForTrinityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForTrinityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForTrinity(s)
	}
}

func (s *ForTrinityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForTrinity(s)
	}
}

func (s *ForTrinityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForTrinity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForTrinity() (localctx IForTrinityContext) {
	localctx = NewForTrinityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_forTrinity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(693)
		p.ForInit()
	}
	{
		p.SetState(694)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(695)
		p.ForCond()
	}
	{
		p.SetState(696)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(697)
		p.ForPost()
	}
	{
		p.SetState(698)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) CopyAll(ctx *ForInitContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForInitLetContext struct {
	ForInitContext
}

func NewLabelForInitLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitLetContext {
	var p = new(LabelForInitLetContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitLetContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LabelForInitLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitLet(s)
	}
}

func (s *LabelForInitLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForInitEmptyContext struct {
	ForInitContext
}

func NewLabelForInitEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForInitEmptyContext {
	var p = new(LabelForInitEmptyContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *LabelForInitEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForInitEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForInitEmpty(s)
	}
}

func (s *LabelForInitEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForInitEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_forInit)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelForInitLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.LetSingle()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForInitEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForCondContext is an interface to support dynamic dispatch.
type IForCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForCondContext differentiates from other interfaces.
	IsForCondContext()
}

type ForCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForCondContext() *ForCondContext {
	var p = new(ForCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
	return p
}

func InitEmptyForCondContext(p *ForCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
}

func (*ForCondContext) IsForCondContext() {}

func NewForCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForCondContext {
	var p = new(ForCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forCond

	return p
}

func (s *ForCondContext) GetParser() antlr.Parser { return s.parser }

func (s *ForCondContext) CopyAll(ctx *ForCondContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForCondEmptyContext struct {
	ForCondContext
}

func NewLabelForCondEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondEmptyContext {
	var p = new(LabelForCondEmptyContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondEmpty(s)
	}
}

func (s *LabelForCondEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForCondExprContext struct {
	ForCondContext
}

func NewLabelForCondExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForCondExprContext {
	var p = new(LabelForCondExprContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *LabelForCondExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForCondExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForCondExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForCondExpr(s)
	}
}

func (s *LabelForCondExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForCondExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForCond() (localctx IForCondContext) {
	localctx = NewForCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_forCond)
	p.SetState(706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelForCondExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.Expr()
		}

	case ManuscriptSEMICOLON:
		localctx = NewLabelForCondEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForPostContext is an interface to support dynamic dispatch.
type IForPostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForPostContext differentiates from other interfaces.
	IsForPostContext()
}

type ForPostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForPostContext() *ForPostContext {
	var p = new(ForPostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
	return p
}

func InitEmptyForPostContext(p *ForPostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
}

func (*ForPostContext) IsForPostContext() {}

func NewForPostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForPostContext {
	var p = new(ForPostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forPost

	return p
}

func (s *ForPostContext) GetParser() antlr.Parser { return s.parser }

func (s *ForPostContext) CopyAll(ctx *ForPostContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForPostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelForPostExprContext struct {
	ForPostContext
}

func NewLabelForPostExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostExprContext {
	var p = new(LabelForPostExprContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelForPostExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostExpr(s)
	}
}

func (s *LabelForPostExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelForPostEmptyContext struct {
	ForPostContext
}

func NewLabelForPostEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelForPostEmptyContext {
	var p = new(LabelForPostEmptyContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *LabelForPostEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelForPostEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelForPostEmpty(s)
	}
}

func (s *LabelForPostEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelForPostEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForPost() (localctx IForPostContext) {
	localctx = NewForPostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_forPost)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelForPostExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.Expr()
		}

	case 2:
		localctx = NewLabelForPostEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	LoopBody() ILoopBodyContext

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(713)
		p.Expr()
	}
	{
		p.SetState(714)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBodyContext is an interface to support dynamic dispatch.
type ILoopBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsLoopBodyContext differentiates from other interfaces.
	IsLoopBodyContext()
}

type LoopBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopBodyContext() *LoopBodyContext {
	var p = new(LoopBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
	return p
}

func InitEmptyLoopBodyContext(p *LoopBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
}

func (*LoopBodyContext) IsLoopBodyContext() {}

func NewLoopBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBodyContext {
	var p = new(LoopBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopBody

	return p
}

func (s *LoopBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LoopBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LoopBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LoopBodyContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *LoopBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopBody(s)
	}
}

func (s *LoopBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopBody(s)
	}
}

func (s *LoopBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopBody() (localctx ILoopBodyContext) {
	localctx = NewLoopBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_loopBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(716)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(717)
				p.Stmt_sep()
			}

		}
		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180229608030688) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(723)
			p.Stmt()
		}
		p.SetState(733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(725)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(724)
						p.Stmt_sep()
					}

					p.SetState(727)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(729)
					p.Stmt()
				}

			}
			p.SetState(735)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(738)
			p.Stmt_sep()
		}

		p.SetState(743)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(744)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_codeBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(750)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(747)
				p.Stmt_sep()
			}

		}
		p.SetState(752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108180229608030688) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(753)
			p.Stmt()
		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(755)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(754)
						p.Stmt_sep()
					}

					p.SetState(757)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(759)
					p.Stmt()
				}

			}
			p.SetState(765)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	}
	p.SetState(771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(768)
			p.Stmt_sep()
		}

		p.SetState(773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(774)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ManuscriptBREAK, 0)
}

func (s *BreakStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(776)
		p.Match(ManuscriptBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(778)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(777)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCONTINUE, 0)
}

func (s *ContinueStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(780)
		p.Match(ManuscriptCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	SEMICOLON() antlr.TerminalNode

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *CheckStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *CheckStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CheckStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (s *CheckStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCheckStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_checkStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(784)
		p.Match(ManuscriptCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(785)
		p.Expr()
	}
	{
		p.SetState(786)
		p.Match(ManuscriptCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(787)
		p.StringLiteral()
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(788)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedStmtContext is an interface to support dynamic dispatch.
type IPipedStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPostfixExpr() []IPostfixExprContext
	PostfixExpr(i int) IPostfixExprContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	AllPipedArgs() []IPipedArgsContext
	PipedArgs(i int) IPipedArgsContext

	// IsPipedStmtContext differentiates from other interfaces.
	IsPipedStmtContext()
}

type PipedStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedStmtContext() *PipedStmtContext {
	var p = new(PipedStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedStmt
	return p
}

func InitEmptyPipedStmtContext(p *PipedStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedStmt
}

func (*PipedStmtContext) IsPipedStmtContext() {}

func NewPipedStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedStmtContext {
	var p = new(PipedStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedStmt

	return p
}

func (s *PipedStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedStmtContext) AllPostfixExpr() []IPostfixExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixExprContext); ok {
			len++
		}
	}

	tst := make([]IPostfixExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixExprContext); ok {
			tst[i] = t.(IPostfixExprContext)
			i++
		}
	}

	return tst
}

func (s *PipedStmtContext) PostfixExpr(i int) IPostfixExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PipedStmtContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptPIPE)
}

func (s *PipedStmtContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE, i)
}

func (s *PipedStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *PipedStmtContext) AllPipedArgs() []IPipedArgsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPipedArgsContext); ok {
			len++
		}
	}

	tst := make([]IPipedArgsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPipedArgsContext); ok {
			tst[i] = t.(IPipedArgsContext)
			i++
		}
	}

	return tst
}

func (s *PipedStmtContext) PipedArgs(i int) IPipedArgsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedArgsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedArgsContext)
}

func (s *PipedStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedStmt(s)
	}
}

func (s *PipedStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedStmt(s)
	}
}

func (s *PipedStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedStmt() (localctx IPipedStmtContext) {
	localctx = NewPipedStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_pipedStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.postfixExpr(0)
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptPIPE {
		{
			p.SetState(792)
			p.Match(ManuscriptPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(793)
			p.postfixExpr(0)
		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptID {
			{
				p.SetState(794)
				p.PipedArgs()
			}

		}

		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(802)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(801)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedArgsContext is an interface to support dynamic dispatch.
type IPipedArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPipedArg() []IPipedArgContext
	PipedArg(i int) IPipedArgContext

	// IsPipedArgsContext differentiates from other interfaces.
	IsPipedArgsContext()
}

type PipedArgsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedArgsContext() *PipedArgsContext {
	var p = new(PipedArgsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArgs
	return p
}

func InitEmptyPipedArgsContext(p *PipedArgsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArgs
}

func (*PipedArgsContext) IsPipedArgsContext() {}

func NewPipedArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedArgsContext {
	var p = new(PipedArgsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedArgs

	return p
}

func (s *PipedArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedArgsContext) AllPipedArg() []IPipedArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPipedArgContext); ok {
			len++
		}
	}

	tst := make([]IPipedArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPipedArgContext); ok {
			tst[i] = t.(IPipedArgContext)
			i++
		}
	}

	return tst
}

func (s *PipedArgsContext) PipedArg(i int) IPipedArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPipedArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPipedArgContext)
}

func (s *PipedArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedArgs(s)
	}
}

func (s *PipedArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedArgs(s)
	}
}

func (s *PipedArgsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedArgs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedArgs() (localctx IPipedArgsContext) {
	localctx = NewPipedArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_pipedArgs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptID {
		{
			p.SetState(804)
			p.PipedArg()
		}

		p.SetState(807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPipedArgContext is an interface to support dynamic dispatch.
type IPipedArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsPipedArgContext differentiates from other interfaces.
	IsPipedArgContext()
}

type PipedArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPipedArgContext() *PipedArgContext {
	var p = new(PipedArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArg
	return p
}

func InitEmptyPipedArgContext(p *PipedArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_pipedArg
}

func (*PipedArgContext) IsPipedArgContext() {}

func NewPipedArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PipedArgContext {
	var p = new(PipedArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_pipedArg

	return p
}

func (s *PipedArgContext) GetParser() antlr.Parser { return s.parser }

func (s *PipedArgContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PipedArgContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *PipedArgContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PipedArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PipedArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PipedArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPipedArg(s)
	}
}

func (s *PipedArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPipedArg(s)
	}
}

func (s *PipedArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPipedArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PipedArg() (localctx IPipedArgContext) {
	localctx = NewPipedArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_pipedArg)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(811)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(813)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() ITernaryExprContext

	// GetOp returns the op rule contexts.
	GetOp() IAssignmentOpContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ITernaryExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IAssignmentOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	TernaryExpr() ITernaryExprContext
	AssignmentOp() IAssignmentOpContext
	AssignmentExpr() IAssignmentExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ITernaryExprContext
	op     IAssignmentOpContext
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetLeft() ITernaryExprContext { return s.left }

func (s *AssignmentExprContext) GetOp() IAssignmentOpContext { return s.op }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ITernaryExprContext) { s.left = v }

func (s *AssignmentExprContext) SetOp(v IAssignmentOpContext) { s.op = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *AssignmentExprContext) AssignmentOp() IAssignmentOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOpContext)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ManuscriptRULE_assignmentExpr)
	p.SetState(820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.TernaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)

			var _x = p.TernaryExpr()

			localctx.(*AssignmentExprContext).left = _x
		}
		{
			p.SetState(817)

			var _x = p.AssignmentOp()

			localctx.(*AssignmentExprContext).op = _x
		}
		{
			p.SetState(818)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOpContext is an interface to support dynamic dispatch.
type IAssignmentOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	PLUS_EQUALS() antlr.TerminalNode
	MINUS_EQUALS() antlr.TerminalNode
	STAR_EQUALS() antlr.TerminalNode
	SLASH_EQUALS() antlr.TerminalNode
	MOD_EQUALS() antlr.TerminalNode
	CARET_EQUALS() antlr.TerminalNode

	// IsAssignmentOpContext differentiates from other interfaces.
	IsAssignmentOpContext()
}

type AssignmentOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOpContext() *AssignmentOpContext {
	var p = new(AssignmentOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
	return p
}

func InitEmptyAssignmentOpContext(p *AssignmentOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
}

func (*AssignmentOpContext) IsAssignmentOpContext() {}

func NewAssignmentOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOpContext {
	var p = new(AssignmentOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentOp

	return p
}

func (s *AssignmentOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOpContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *AssignmentOpContext) PLUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS_EQUALS, 0)
}

func (s *AssignmentOpContext) MINUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS_EQUALS, 0)
}

func (s *AssignmentOpContext) STAR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR_EQUALS, 0)
}

func (s *AssignmentOpContext) SLASH_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH_EQUALS, 0)
}

func (s *AssignmentOpContext) MOD_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD_EQUALS, 0)
}

func (s *AssignmentOpContext) CARET_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET_EQUALS, 0)
}

func (s *AssignmentOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentOp(s)
	}
}

func (s *AssignmentOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentOp() (localctx IAssignmentOpContext) {
	localctx = NewAssignmentOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ManuscriptRULE_assignmentOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(822)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&2064385) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExprContext is an interface to support dynamic dispatch.
type ITernaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCond returns the cond rule contexts.
	GetCond() ILogicalOrExprContext

	// GetThenBranch returns the thenBranch rule contexts.
	GetThenBranch() IExprContext

	// GetElseExpr returns the elseExpr rule contexts.
	GetElseExpr() ITernaryExprContext

	// SetCond sets the cond rule contexts.
	SetCond(ILogicalOrExprContext)

	// SetThenBranch sets the thenBranch rule contexts.
	SetThenBranch(IExprContext)

	// SetElseExpr sets the elseExpr rule contexts.
	SetElseExpr(ITernaryExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	TernaryExpr() ITernaryExprContext

	// IsTernaryExprContext differentiates from other interfaces.
	IsTernaryExprContext()
}

type TernaryExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	cond       ILogicalOrExprContext
	thenBranch IExprContext
	elseExpr   ITernaryExprContext
}

func NewEmptyTernaryExprContext() *TernaryExprContext {
	var p = new(TernaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
	return p
}

func InitEmptyTernaryExprContext(p *TernaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
}

func (*TernaryExprContext) IsTernaryExprContext() {}

func NewTernaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExprContext {
	var p = new(TernaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ternaryExpr

	return p
}

func (s *TernaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExprContext) GetCond() ILogicalOrExprContext { return s.cond }

func (s *TernaryExprContext) GetThenBranch() IExprContext { return s.thenBranch }

func (s *TernaryExprContext) GetElseExpr() ITernaryExprContext { return s.elseExpr }

func (s *TernaryExprContext) SetCond(v ILogicalOrExprContext) { s.cond = v }

func (s *TernaryExprContext) SetThenBranch(v IExprContext) { s.thenBranch = v }

func (s *TernaryExprContext) SetElseExpr(v ITernaryExprContext) { s.elseExpr = v }

func (s *TernaryExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *TernaryExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TernaryExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *TernaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TernaryExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TernaryExpr() (localctx ITernaryExprContext) {
	localctx = NewTernaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ManuscriptRULE_ternaryExpr)
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(824)
			p.logicalOrExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(825)

			var _x = p.logicalOrExpr(0)

			localctx.(*TernaryExprContext).cond = _x
		}
		{
			p.SetState(826)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)

			var _x = p.Expr()

			localctx.(*TernaryExprContext).thenBranch = _x
		}
		{
			p.SetState(828)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(829)

			var _x = p.TernaryExpr()

			localctx.(*TernaryExprContext).elseExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	LogicalAndExpr() ILogicalAndExprContext
	LogicalOrExpr() ILogicalOrExprContext
	PIPE_PIPE() antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalOrExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalOrExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalOrExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *LogicalOrExprContext) PIPE_PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, 0)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	return p.logicalOrExpr(0)
}

func (p *Manuscript) logicalOrExpr(_p int) (localctx ILogicalOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, ManuscriptRULE_logicalOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		p.logicalAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalOrExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalOrExpr)
			p.SetState(836)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(837)

				var _m = p.Match(ManuscriptPIPE_PIPE)

				localctx.(*LogicalOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(838)

				var _x = p.logicalAndExpr(0)

				localctx.(*LogicalOrExprContext).right = _x
			}

		}
		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseXorExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseXorExprContext)

	// Getter signatures
	BitwiseXorExpr() IBitwiseXorExprContext
	LogicalAndExpr() ILogicalAndExprContext
	AMP_AMP() antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  IBitwiseXorExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IBitwiseXorExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IBitwiseXorExprContext) { s.right = v }

func (s *LogicalAndExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *LogicalAndExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalAndExprContext) AMP_AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, 0)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	return p.logicalAndExpr(0)
}

func (p *Manuscript) logicalAndExpr(_p int) (localctx ILogicalAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, ManuscriptRULE_logicalAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(845)
		p.bitwiseXorExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalAndExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalAndExpr)
			p.SetState(847)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(848)

				var _m = p.Match(ManuscriptAMP_AMP)

				localctx.(*LogicalAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(849)

				var _x = p.bitwiseXorExpr(0)

				localctx.(*LogicalAndExprContext).right = _x
			}

		}
		p.SetState(854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseXorExprContext is an interface to support dynamic dispatch.
type IBitwiseXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseXorExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseXorExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseAndExprContext)

	// Getter signatures
	BitwiseAndExpr() IBitwiseAndExprContext
	BitwiseXorExpr() IBitwiseXorExprContext
	CARET() antlr.TerminalNode

	// IsBitwiseXorExprContext differentiates from other interfaces.
	IsBitwiseXorExprContext()
}

type BitwiseXorExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseXorExprContext
	op     antlr.Token
	right  IBitwiseAndExprContext
}

func NewEmptyBitwiseXorExprContext() *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
	return p
}

func InitEmptyBitwiseXorExprContext(p *BitwiseXorExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
}

func (*BitwiseXorExprContext) IsBitwiseXorExprContext() {}

func NewBitwiseXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr

	return p
}

func (s *BitwiseXorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExprContext) GetLeft() IBitwiseXorExprContext { return s.left }

func (s *BitwiseXorExprContext) GetRight() IBitwiseAndExprContext { return s.right }

func (s *BitwiseXorExprContext) SetLeft(v IBitwiseXorExprContext) { s.left = v }

func (s *BitwiseXorExprContext) SetRight(v IBitwiseAndExprContext) { s.right = v }

func (s *BitwiseXorExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseXorExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseXorExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET, 0)
}

func (s *BitwiseXorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseXorExpr() (localctx IBitwiseXorExprContext) {
	return p.bitwiseXorExpr(0)
}

func (p *Manuscript) bitwiseXorExpr(_p int) (localctx IBitwiseXorExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseXorExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseXorExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, ManuscriptRULE_bitwiseXorExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.bitwiseAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseXorExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseXorExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseXorExpr)
			p.SetState(858)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(859)

				var _m = p.Match(ManuscriptCARET)

				localctx.(*BitwiseXorExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(860)

				var _x = p.bitwiseAndExpr(0)

				localctx.(*BitwiseXorExprContext).right = _x
			}

		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseAndExprContext is an interface to support dynamic dispatch.
type IBitwiseAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	EqualityExpr() IEqualityExprContext
	BitwiseAndExpr() IBitwiseAndExprContext
	AMP() antlr.TerminalNode

	// IsBitwiseAndExprContext differentiates from other interfaces.
	IsBitwiseAndExprContext()
}

type BitwiseAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseAndExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyBitwiseAndExprContext() *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
	return p
}

func InitEmptyBitwiseAndExprContext(p *BitwiseAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
}

func (*BitwiseAndExprContext) IsBitwiseAndExprContext() {}

func NewBitwiseAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr

	return p
}

func (s *BitwiseAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExprContext) GetLeft() IBitwiseAndExprContext { return s.left }

func (s *BitwiseAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *BitwiseAndExprContext) SetLeft(v IBitwiseAndExprContext) { s.left = v }

func (s *BitwiseAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *BitwiseAndExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *BitwiseAndExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseAndExprContext) AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP, 0)
}

func (s *BitwiseAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseAndExpr() (localctx IBitwiseAndExprContext) {
	return p.bitwiseAndExpr(0)
}

func (p *Manuscript) bitwiseAndExpr(_p int) (localctx IBitwiseAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, ManuscriptRULE_bitwiseAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.equalityExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseAndExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseAndExpr)
			p.SetState(869)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(870)

				var _m = p.Match(ManuscriptAMP)

				localctx.(*BitwiseAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(871)

				var _x = p.equalityExpr(0)

				localctx.(*BitwiseAndExprContext).right = _x
			}

		}
		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	EqualityExpr() IEqualityExprContext
	EQUALS_EQUALS() antlr.TerminalNode
	NEQ() antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *EqualityExprContext) EQUALS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, 0)
}

func (s *EqualityExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, 0)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	return p.equalityExpr(0)
}

func (p *Manuscript) equalityExpr(_p int) (localctx IEqualityExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ManuscriptRULE_equalityExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(878)
		p.comparisonExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(885)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEqualityExprContext(p, _parentctx, _parentState)
			localctx.(*EqualityExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_equalityExpr)
			p.SetState(880)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(881)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*EqualityExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*EqualityExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(882)

				var _x = p.comparisonExpr(0)

				localctx.(*EqualityExprContext).right = _x
			}

		}
		p.SetState(887)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOpContext is an interface to support dynamic dispatch.
type IComparisonOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	LT_EQUALS() antlr.TerminalNode
	GT() antlr.TerminalNode
	GT_EQUALS() antlr.TerminalNode

	// IsComparisonOpContext differentiates from other interfaces.
	IsComparisonOpContext()
}

type ComparisonOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOpContext() *ComparisonOpContext {
	var p = new(ComparisonOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
	return p
}

func InitEmptyComparisonOpContext(p *ComparisonOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
}

func (*ComparisonOpContext) IsComparisonOpContext() {}

func NewComparisonOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOpContext {
	var p = new(ComparisonOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonOp

	return p
}

func (s *ComparisonOpContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOpContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *ComparisonOpContext) LT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, 0)
}

func (s *ComparisonOpContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *ComparisonOpContext) GT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, 0)
}

func (s *ComparisonOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonOp(s)
	}
}

func (s *ComparisonOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonOp(s)
	}
}

func (s *ComparisonOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonOp() (localctx IComparisonOpContext) {
	localctx = NewComparisonOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ManuscriptRULE_comparisonOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1055531162664960) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetOp returns the op rule contexts.
	GetOp() IComparisonOpContext

	// GetRight returns the right rule contexts.
	GetRight() IShiftExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IComparisonOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IShiftExprContext)

	// Getter signatures
	ShiftExpr() IShiftExprContext
	ComparisonExpr() IComparisonExprContext
	ComparisonOp() IComparisonOpContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     IComparisonOpContext
	right  IShiftExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *ComparisonExprContext) GetOp() IComparisonOpContext { return s.op }

func (s *ComparisonExprContext) GetRight() IShiftExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *ComparisonExprContext) SetOp(v IComparisonOpContext) { s.op = v }

func (s *ComparisonExprContext) SetRight(v IShiftExprContext) { s.right = v }

func (s *ComparisonExprContext) ShiftExpr() IShiftExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ComparisonExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *ComparisonExprContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	return p.comparisonExpr(0)
}

func (p *Manuscript) comparisonExpr(_p int) (localctx IComparisonExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, ManuscriptRULE_comparisonExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		p.ShiftExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(899)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonExprContext(p, _parentctx, _parentState)
			localctx.(*ComparisonExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_comparisonExpr)
			p.SetState(893)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(894)

				var _x = p.ComparisonOp()

				localctx.(*ComparisonExprContext).op = _x
			}
			{
				p.SetState(895)

				var _x = p.ShiftExpr()

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExprContext is an interface to support dynamic dispatch.
type IShiftExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext

	// IsShiftExprContext differentiates from other interfaces.
	IsShiftExprContext()
}

type ShiftExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftExprContext() *ShiftExprContext {
	var p = new(ShiftExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
	return p
}

func InitEmptyShiftExprContext(p *ShiftExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
}

func (*ShiftExprContext) IsShiftExprContext() {}

func NewShiftExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExprContext {
	var p = new(ShiftExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_shiftExpr

	return p
}

func (s *ShiftExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ShiftExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterShiftExpr(s)
	}
}

func (s *ShiftExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitShiftExpr(s)
	}
}

func (s *ShiftExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitShiftExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ShiftExpr() (localctx IShiftExprContext) {
	localctx = NewShiftExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ManuscriptRULE_shiftExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.additiveExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *AdditiveExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *Manuscript) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 138
	p.EnterRecursionRule(localctx, 138, ManuscriptRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			localctx.(*AdditiveExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_additiveExpr)
			p.SetState(907)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(908)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(909)

				var _x = p.multiplicativeExpr(0)

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	MultiplicativeExpr() IMultiplicativeExprContext
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, 0)
}

func (s *MultiplicativeExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, 0)
}

func (s *MultiplicativeExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD, 0)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *Manuscript) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 140
	p.EnterRecursionRule(localctx, 140, ManuscriptRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(916)
		p.UnaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			localctx.(*MultiplicativeExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_multiplicativeExpr)
			p.SetState(918)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(919)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009213693952) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(920)

				var _x = p.UnaryExpr()

				localctx.(*MultiplicativeExprContext).right = _x
			}

		}
		p.SetState(925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) CopyAll(ctx *UnaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelUnaryAwaitExprContext struct {
	UnaryExprContext
}

func NewLabelUnaryAwaitExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryAwaitExprContext {
	var p = new(LabelUnaryAwaitExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryAwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryAwaitExprContext) AwaitExpr() IAwaitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAwaitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAwaitExprContext)
}

func (s *LabelUnaryAwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryAwaitExpr(s)
	}
}

func (s *LabelUnaryAwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryAwaitExpr(s)
	}
}

func (s *LabelUnaryAwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelUnaryOpExprContext struct {
	UnaryExprContext
	op    antlr.Token
	unary IUnaryExprContext
}

func NewLabelUnaryOpExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelUnaryOpExprContext {
	var p = new(LabelUnaryOpExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *LabelUnaryOpExprContext) GetOp() antlr.Token { return s.op }

func (s *LabelUnaryOpExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LabelUnaryOpExprContext) GetUnary() IUnaryExprContext { return s.unary }

func (s *LabelUnaryOpExprContext) SetUnary(v IUnaryExprContext) { s.unary = v }

func (s *LabelUnaryOpExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelUnaryOpExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *LabelUnaryOpExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *LabelUnaryOpExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *LabelUnaryOpExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *LabelUnaryOpExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelUnaryOpExpr(s)
	}
}

func (s *LabelUnaryOpExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelUnaryOpExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(929)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION:
		localctx = NewLabelUnaryOpExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(926)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*LabelUnaryOpExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&515) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*LabelUnaryOpExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(927)

			var _x = p.UnaryExpr()

			localctx.(*LabelUnaryOpExprContext).unary = _x
		}

	case ManuscriptFN, ManuscriptVOID, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelUnaryAwaitExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(928)
			p.AwaitExpr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAwaitExprContext is an interface to support dynamic dispatch.
type IAwaitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext

	// IsAwaitExprContext differentiates from other interfaces.
	IsAwaitExprContext()
}

type AwaitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExprContext() *AwaitExprContext {
	var p = new(AwaitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
	return p
}

func InitEmptyAwaitExprContext(p *AwaitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
}

func (*AwaitExprContext) IsAwaitExprContext() {}

func NewAwaitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExprContext {
	var p = new(AwaitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_awaitExpr

	return p
}

func (s *AwaitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *AwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAwaitExpr(s)
	}
}

func (s *AwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAwaitExpr(s)
	}
}

func (s *AwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AwaitExpr() (localctx IAwaitExprContext) {
	localctx = NewAwaitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ManuscriptRULE_awaitExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.postfixExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	PostfixExpr() IPostfixExprContext
	PostfixOp() IPostfixOpContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PostfixExprContext) PostfixOp() IPostfixOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOpContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	return p.postfixExpr(0)
}

func (p *Manuscript) postfixExpr(_p int) (localctx IPostfixExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 146
	p.EnterRecursionRule(localctx, 146, ManuscriptRULE_postfixExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.PrimaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_postfixExpr)
			p.SetState(936)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(937)
				p.PostfixOp()
			}

		}
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOpContext is an interface to support dynamic dispatch.
type IPostfixOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPostfixOpContext differentiates from other interfaces.
	IsPostfixOpContext()
}

type PostfixOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOpContext() *PostfixOpContext {
	var p = new(PostfixOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
	return p
}

func InitEmptyPostfixOpContext(p *PostfixOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
}

func (*PostfixOpContext) IsPostfixOpContext() {}

func NewPostfixOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOpContext {
	var p = new(PostfixOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixOp

	return p
}

func (s *PostfixOpContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOpContext) CopyAll(ctx *PostfixOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PostfixOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPostfixDotContext struct {
	PostfixOpContext
}

func NewLabelPostfixDotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixDotContext {
	var p = new(LabelPostfixDotContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixDotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixDotContext) DOT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, 0)
}

func (s *LabelPostfixDotContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPostfixDotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixDot(s)
	}
}

func (s *LabelPostfixDotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixDot(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixCallContext struct {
	PostfixOpContext
}

func NewLabelPostfixCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixCallContext {
	var p = new(LabelPostfixCallContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPostfixCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPostfixCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *LabelPostfixCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixCall(s)
	}
}

func (s *LabelPostfixCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPostfixIndexContext struct {
	PostfixOpContext
}

func NewLabelPostfixIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPostfixIndexContext {
	var p = new(LabelPostfixIndexContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *LabelPostfixIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPostfixIndexContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelPostfixIndexContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPostfixIndexContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelPostfixIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPostfixIndex(s)
	}
}

func (s *LabelPostfixIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPostfixIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixOp() (localctx IPostfixOpContext) {
	localctx = NewPostfixOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ManuscriptRULE_postfixOp)
	var _la int

	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLPAREN:
		localctx = NewLabelPostfixCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(943)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(944)
				p.ExprList()
			}

		}
		{
			p.SetState(947)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOT:
		localctx = NewLabelPostfixDotContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(948)
			p.Match(ManuscriptDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(949)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		localctx = NewLabelPostfixIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(950)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(951)
			p.Expr()
		}
		{
			p.SetState(952)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) CopyAll(ctx *PrimaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelPrimaryTaggedBlockContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryTaggedBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryTaggedBlockContext {
	var p = new(LabelPrimaryTaggedBlockContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryTaggedBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryTaggedBlockContext) TaggedBlockString() ITaggedBlockStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaggedBlockStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaggedBlockStringContext)
}

func (s *LabelPrimaryTaggedBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryTaggedBlock(s)
	}
}

func (s *LabelPrimaryTaggedBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryTaggedBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryParenContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryParenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryParenContext {
	var p = new(LabelPrimaryParenContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryParenContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LabelPrimaryParenContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LabelPrimaryParenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LabelPrimaryParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryParen(s)
	}
}

func (s *LabelPrimaryParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryParen(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMatchContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMatchContext {
	var p = new(LabelPrimaryMatchContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMatchContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *LabelPrimaryMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMatch(s)
	}
}

func (s *LabelPrimaryMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryStructInitContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryStructInitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryStructInitContext {
	var p = new(LabelPrimaryStructInitContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryStructInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryStructInitContext) StructInitExpr() IStructInitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructInitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructInitExprContext)
}

func (s *LabelPrimaryStructInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryStructInit(s)
	}
}

func (s *LabelPrimaryStructInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryStructInit(s)
	}
}

func (s *LabelPrimaryStructInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryStructInit(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryFnContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryFnContext {
	var p = new(LabelPrimaryFnContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryFnContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *LabelPrimaryFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryFn(s)
	}
}

func (s *LabelPrimaryFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimarySetContext struct {
	PrimaryExprContext
}

func NewLabelPrimarySetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimarySetContext {
	var p = new(LabelPrimarySetContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimarySetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimarySetContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *LabelPrimarySetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimarySet(s)
	}
}

func (s *LabelPrimarySetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimarySet(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryIDContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryIDContext {
	var p = new(LabelPrimaryIDContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelPrimaryIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryID(s)
	}
}

func (s *LabelPrimaryIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryID(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryVoidContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryVoidContext {
	var p = new(LabelPrimaryVoidContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelPrimaryVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryVoid(s)
	}
}

func (s *LabelPrimaryVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryMapContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryMapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryMapContext {
	var p = new(LabelPrimaryMapContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryMapContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *LabelPrimaryMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryMap(s)
	}
}

func (s *LabelPrimaryMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryMap(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryLiteralContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryLiteralContext {
	var p = new(LabelPrimaryLiteralContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LabelPrimaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryLiteral(s)
	}
}

func (s *LabelPrimaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryArrayContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryArrayContext {
	var p = new(LabelPrimaryArrayContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryArrayContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *LabelPrimaryArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryArray(s)
	}
}

func (s *LabelPrimaryArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryNullContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryNullContext {
	var p = new(LabelPrimaryNullContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelPrimaryNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryNull(s)
	}
}

func (s *LabelPrimaryNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelPrimaryObjectContext struct {
	PrimaryExprContext
}

func NewLabelPrimaryObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelPrimaryObjectContext {
	var p = new(LabelPrimaryObjectContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *LabelPrimaryObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelPrimaryObjectContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *LabelPrimaryObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelPrimaryObject(s)
	}
}

func (s *LabelPrimaryObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelPrimaryObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ManuscriptRULE_primaryExpr)
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelPrimaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(956)
			p.Literal()
		}

	case 2:
		localctx = NewLabelPrimaryIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(957)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewLabelPrimaryParenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(958)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(959)
			p.Expr()
		}
		{
			p.SetState(960)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewLabelPrimaryArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(962)
			p.ArrayLiteral()
		}

	case 5:
		localctx = NewLabelPrimaryObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(963)
			p.ObjectLiteral()
		}

	case 6:
		localctx = NewLabelPrimaryMapContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(964)
			p.MapLiteral()
		}

	case 7:
		localctx = NewLabelPrimarySetContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(965)
			p.SetLiteral()
		}

	case 8:
		localctx = NewLabelPrimaryFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(966)
			p.FnExpr()
		}

	case 9:
		localctx = NewLabelPrimaryMatchContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(967)
			p.MatchExpr()
		}

	case 10:
		localctx = NewLabelPrimaryVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(968)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewLabelPrimaryNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(969)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewLabelPrimaryTaggedBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(970)
			p.TaggedBlockString()
		}

	case 13:
		localctx = NewLabelPrimaryStructInitContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(971)
			p.StructInitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryExprContext is an interface to support dynamic dispatch.
type ITryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRY() antlr.TerminalNode
	Expr() IExprContext

	// IsTryExprContext differentiates from other interfaces.
	IsTryExprContext()
}

type TryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryExprContext() *TryExprContext {
	var p = new(TryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryExpr
	return p
}

func InitEmptyTryExprContext(p *TryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tryExpr
}

func (*TryExprContext) IsTryExprContext() {}

func NewTryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryExprContext {
	var p = new(TryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tryExpr

	return p
}

func (s *TryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TryExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *TryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTryExpr(s)
	}
}

func (s *TryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTryExpr(s)
	}
}

func (s *TryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TryExpr() (localctx ITryExprContext) {
	localctx = NewTryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ManuscriptRULE_tryExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(ManuscriptTRY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(978)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(979)
			p.Parameters()
		}

	}
	{
		p.SetState(982)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(983)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(986)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expr() IExprContext
	LBRACE() antlr.TerminalNode
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	DefaultClause() IDefaultClauseContext

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MatchExprContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ManuscriptRULE_matchExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(988)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(989)
		p.Expr()
	}
	{
		p.SetState(990)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(991)
			p.Stmt_sep()
		}

		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(997)
		p.CaseClause()
	}
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(999)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(998)
					p.Stmt_sep()
				}

				p.SetState(1001)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1003)
				p.CaseClause()
			}

		}
		p.SetState(1009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(1010)
			p.Stmt_sep()
		}

		p.SetState(1015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptDEFAULT {
		{
			p.SetState(1016)
			p.DefaultClause()
		}

	}
	{
		p.SetState(1019)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ManuscriptRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1021)
		p.Expr()
	}
	p.SetState(1025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1022)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1023)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1024)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1028)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1027)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFAULT, 0)
}

func (s *DefaultClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *DefaultClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DefaultClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *DefaultClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ManuscriptRULE_defaultClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1030)
		p.Match(ManuscriptDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1031)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1032)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1033)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(1036)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1039)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1040)
			p.StringPart()
		}

		p.SetState(1045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1046)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1052)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1049)
			p.StringPart()
		}

		p.SetState(1054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1055)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTE_START() antlr.TerminalNode
	DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsDoubleQuotedStringContext differentiates from other interfaces.
	IsDoubleQuotedStringContext()
}

type DoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleQuotedStringContext() *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
	return p
}

func InitEmptyDoubleQuotedStringContext(p *DoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
}

func (*DoubleQuotedStringContext) IsDoubleQuotedStringContext() {}

func NewDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_doubleQuotedString

	return p
}

func (s *DoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleQuotedStringContext) DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_QUOTE_START, 0)
}

func (s *DoubleQuotedStringContext) DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_END, 0)
}

func (s *DoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *DoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *DoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DoubleQuotedString() (localctx IDoubleQuotedStringContext) {
	localctx = NewDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ManuscriptRULE_doubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(ManuscriptDOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1058)
			p.StringPart()
		}

		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1064)
		p.Match(ManuscriptDOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IMultiDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiDoubleQuotedStringContext differentiates from other interfaces.
	IsMultiDoubleQuotedStringContext()
}

type MultiDoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiDoubleQuotedStringContext() *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
	return p
}

func InitEmptyMultiDoubleQuotedStringContext(p *MultiDoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
}

func (*MultiDoubleQuotedStringContext) IsMultiDoubleQuotedStringContext() {}

func NewMultiDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString

	return p
}

func (s *MultiDoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_QUOTE_START, 0)
}

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_END, 0)
}

func (s *MultiDoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiDoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiDoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiDoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiDoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiDoubleQuotedString() (localctx IMultiDoubleQuotedStringContext) {
	localctx = NewMultiDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ManuscriptRULE_multiDoubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1066)
		p.Match(ManuscriptMULTI_DOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1067)
			p.StringPart()
		}

		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1073)
		p.Match(ManuscriptMULTI_DOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_STR_CONTENT() antlr.TerminalNode
	MULTI_STR_CONTENT() antlr.TerminalNode
	DOUBLE_STR_CONTENT() antlr.TerminalNode
	MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode
	Interpolation() IInterpolationContext

	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *StringPartContext) DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_CONTENT, 0)
}

func (s *StringPartContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPart(s)
	}
}

func (s *StringPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPart(s)
	}
}

func (s *StringPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ManuscriptRULE_stringPart)
	p.SetState(1080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1075)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1076)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1077)
			p.Match(ManuscriptDOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_DOUBLE_STR_CONTENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1078)
			p.Match(ManuscriptMULTI_DOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START, ManuscriptDOUBLE_STR_INTERP_START, ManuscriptMULTI_DOUBLE_STR_INTERP_START:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1079)
			p.Interpolation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	DOUBLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&585) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1083)
		p.Expr()
	}
	{
		p.SetState(1084)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelLiteralBoolContext struct {
	LiteralContext
}

func NewLabelLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralBoolContext {
	var p = new(LabelLiteralBoolContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralBoolContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LabelLiteralBoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralBool(s)
	}
}

func (s *LabelLiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralStringContext struct {
	LiteralContext
}

func NewLabelLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralStringContext {
	var p = new(LabelLiteralStringContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralStringContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelLiteralStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralString(s)
	}
}

func (s *LabelLiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNumberContext struct {
	LiteralContext
}

func NewLabelLiteralNumberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNumberContext {
	var p = new(LabelLiteralNumberContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNumberContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LabelLiteralNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNumber(s)
	}
}

func (s *LabelLiteralNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralNullContext struct {
	LiteralContext
}

func NewLabelLiteralNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralNullContext {
	var p = new(LabelLiteralNullContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LabelLiteralNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralNull(s)
	}
}

func (s *LabelLiteralNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelLiteralVoidContext struct {
	LiteralContext
}

func NewLabelLiteralVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelLiteralVoidContext {
	var p = new(LabelLiteralVoidContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LabelLiteralVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelLiteralVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelLiteralVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelLiteralVoid(s)
	}
}

func (s *LabelLiteralVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelLiteralVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ManuscriptRULE_literal)
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1086)
			p.StringLiteral()
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		localctx = NewLabelLiteralNumberContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1087)
			p.NumberLiteral()
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		localctx = NewLabelLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1088)
			p.BooleanLiteral()
		}

	case ManuscriptNULL:
		localctx = NewLabelLiteralNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1089)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		localctx = NewLabelLiteralVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1090)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext
	MultiQuotedString() IMultiQuotedStringContext
	DoubleQuotedString() IDoubleQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *StringLiteralContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *StringLiteralContext) DoubleQuotedString() IDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleQuotedStringContext)
}

func (s *StringLiteralContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ManuscriptRULE_stringLiteral)
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1093)
			p.SingleQuotedString()
		}

	case ManuscriptMULTI_QUOTE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.MultiQuotedString()
		}

	case ManuscriptDOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1095)
			p.DoubleQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1096)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) CopyAll(ctx *NumberLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelNumberLiteralHexContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralHexContext {
	var p = new(LabelNumberLiteralHexContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralHexContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *LabelNumberLiteralHexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralHex(s)
	}
}

func (s *LabelNumberLiteralHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralIntContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralIntContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralIntContext {
	var p = new(LabelNumberLiteralIntContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralIntContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *LabelNumberLiteralIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralInt(s)
	}
}

func (s *LabelNumberLiteralIntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralInt(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralOctContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralOctContext {
	var p = new(LabelNumberLiteralOctContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralOctContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptOCTAL_LITERAL, 0)
}

func (s *LabelNumberLiteralOctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralOct(s)
	}
}

func (s *LabelNumberLiteralOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralOct(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralFloatContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralFloatContext {
	var p = new(LabelNumberLiteralFloatContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *LabelNumberLiteralFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralFloat(s)
	}
}

func (s *LabelNumberLiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelNumberLiteralBinContext struct {
	NumberLiteralContext
}

func NewLabelNumberLiteralBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelNumberLiteralBinContext {
	var p = new(LabelNumberLiteralBinContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *LabelNumberLiteralBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNumberLiteralBinContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *LabelNumberLiteralBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelNumberLiteralBin(s)
	}
}

func (s *LabelNumberLiteralBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelNumberLiteralBin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ManuscriptRULE_numberLiteral)
	p.SetState(1104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		localctx = NewLabelNumberLiteralIntContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1099)
			p.Match(ManuscriptINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		localctx = NewLabelNumberLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1100)
			p.Match(ManuscriptFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		localctx = NewLabelNumberLiteralHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1101)
			p.Match(ManuscriptHEX_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		localctx = NewLabelNumberLiteralBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1102)
			p.Match(ManuscriptBINARY_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptOCTAL_LITERAL:
		localctx = NewLabelNumberLiteralOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1103)
			p.Match(ManuscriptOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) CopyAll(ctx *BooleanLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelBoolLiteralFalseContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralFalseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralFalseContext {
	var p = new(LabelBoolLiteralFalseContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralFalseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralFalseContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *LabelBoolLiteralFalseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralFalse(s)
	}
}

func (s *LabelBoolLiteralFalseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralFalse(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelBoolLiteralTrueContext struct {
	BooleanLiteralContext
}

func NewLabelBoolLiteralTrueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelBoolLiteralTrueContext {
	var p = new(LabelBoolLiteralTrueContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *LabelBoolLiteralTrueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelBoolLiteralTrueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *LabelBoolLiteralTrueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelBoolLiteralTrue(s)
	}
}

func (s *LabelBoolLiteralTrueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelBoolLiteralTrue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ManuscriptRULE_booleanLiteral)
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptTRUE:
		localctx = NewLabelBoolLiteralTrueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1106)
			p.Match(ManuscriptTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFALSE:
		localctx = NewLabelBoolLiteralFalseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1107)
			p.Match(ManuscriptFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	ExprList() IExprListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1110)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1111)
			p.ExprList()
		}

	}
	{
		p.SetState(1114)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectFieldList() IObjectFieldListContext

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) ObjectFieldList() IObjectFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldListContext)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ManuscriptRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1116)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&31) != 0 {
		{
			p.SetState(1117)
			p.ObjectFieldList()
		}

	}
	{
		p.SetState(1120)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldListContext is an interface to support dynamic dispatch.
type IObjectFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectFieldListContext differentiates from other interfaces.
	IsObjectFieldListContext()
}

type ObjectFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldListContext() *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
	return p
}

func InitEmptyObjectFieldListContext(p *ObjectFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
}

func (*ObjectFieldListContext) IsObjectFieldListContext() {}

func NewObjectFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldList

	return p
}

func (s *ObjectFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldListContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectFieldListContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldList() (localctx IObjectFieldListContext) {
	localctx = NewObjectFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ManuscriptRULE_objectFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.ObjectField()
	}
	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1123)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1124)
				p.ObjectField()
			}

		}
		p.SetState(1129)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1130)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ObjectFieldName() IObjectFieldNameContext
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) ObjectFieldName() IObjectFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldNameContext)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.ObjectFieldName()
	}
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(1134)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1135)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldNameContext is an interface to support dynamic dispatch.
type IObjectFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectFieldNameContext differentiates from other interfaces.
	IsObjectFieldNameContext()
}

type ObjectFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldNameContext() *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
	return p
}

func InitEmptyObjectFieldNameContext(p *ObjectFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
}

func (*ObjectFieldNameContext) IsObjectFieldNameContext() {}

func NewObjectFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldName

	return p
}

func (s *ObjectFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldNameContext) CopyAll(ctx *ObjectFieldNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelObjectFieldNameStrContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameStrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameStrContext {
	var p = new(LabelObjectFieldNameStrContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameStrContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LabelObjectFieldNameStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameStr(s)
	}
}

func (s *LabelObjectFieldNameStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameStr(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelObjectFieldNameIDContext struct {
	ObjectFieldNameContext
}

func NewLabelObjectFieldNameIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelObjectFieldNameIDContext {
	var p = new(LabelObjectFieldNameIDContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *LabelObjectFieldNameIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelObjectFieldNameIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelObjectFieldNameIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelObjectFieldNameID(s)
	}
}

func (s *LabelObjectFieldNameIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelObjectFieldNameID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldName() (localctx IObjectFieldNameContext) {
	localctx = NewObjectFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ManuscriptRULE_objectFieldName)
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLabelObjectFieldNameIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1138)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLabelObjectFieldNameStrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1139)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) CopyAll(ctx *MapLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelMapLiteralNonEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralNonEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralNonEmptyContext {
	var p = new(LabelMapLiteralNonEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralNonEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralNonEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralNonEmptyContext) MapFieldList() IMapFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldListContext)
}

func (s *LabelMapLiteralNonEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralNonEmpty(s)
	}
}

func (s *LabelMapLiteralNonEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralNonEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelMapLiteralEmptyContext struct {
	MapLiteralContext
}

func NewLabelMapLiteralEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelMapLiteralEmptyContext {
	var p = new(LabelMapLiteralEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *LabelMapLiteralEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelMapLiteralEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *LabelMapLiteralEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LabelMapLiteralEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelMapLiteralEmpty(s)
	}
}

func (s *LabelMapLiteralEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelMapLiteralEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ManuscriptRULE_mapLiteral)
	var _la int

	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelMapLiteralEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1142)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1143)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1144)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelMapLiteralNonEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1145)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(1146)
				p.MapFieldList()
			}

		}
		{
			p.SetState(1149)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldListContext is an interface to support dynamic dispatch.
type IMapFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapFieldListContext differentiates from other interfaces.
	IsMapFieldListContext()
}

type MapFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldListContext() *MapFieldListContext {
	var p = new(MapFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
	return p
}

func InitEmptyMapFieldListContext(p *MapFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
}

func (*MapFieldListContext) IsMapFieldListContext() {}

func NewMapFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldListContext {
	var p = new(MapFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapFieldList

	return p
}

func (s *MapFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldListContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldListContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapFieldList(s)
	}
}

func (s *MapFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapFieldList(s)
	}
}

func (s *MapFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapFieldList() (localctx IMapFieldListContext) {
	localctx = NewMapFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ManuscriptRULE_mapFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		p.MapField()
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1153)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1154)
				p.MapField()
			}

		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1160)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1163)
		p.Expr()
	}
	{
		p.SetState(1164)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1165)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ManuscriptRULE_setLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1167)
		p.Match(ManuscriptLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179851432706112) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1168)
			p.Expr()
		}
		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1169)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1170)
					p.Expr()
				}

			}
			p.SetState(1175)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(1176)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1181)
		p.Match(ManuscriptGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaggedBlockStringContext is an interface to support dynamic dispatch.
type ITaggedBlockStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	MultiQuotedString() IMultiQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsTaggedBlockStringContext differentiates from other interfaces.
	IsTaggedBlockStringContext()
}

type TaggedBlockStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaggedBlockStringContext() *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
	return p
}

func InitEmptyTaggedBlockStringContext(p *TaggedBlockStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
}

func (*TaggedBlockStringContext) IsTaggedBlockStringContext() {}

func NewTaggedBlockStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_taggedBlockString

	return p
}

func (s *TaggedBlockStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TaggedBlockStringContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TaggedBlockStringContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *TaggedBlockStringContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *TaggedBlockStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaggedBlockStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaggedBlockStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTaggedBlockString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TaggedBlockString() (localctx ITaggedBlockStringContext) {
	localctx = NewTaggedBlockStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ManuscriptRULE_taggedBlockString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1183)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1186)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptMULTI_QUOTE_START:
		{
			p.SetState(1184)
			p.MultiQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		{
			p.SetState(1185)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructInitExprContext is an interface to support dynamic dispatch.
type IStructInitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	StructFieldList() IStructFieldListContext

	// IsStructInitExprContext differentiates from other interfaces.
	IsStructInitExprContext()
}

type StructInitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructInitExprContext() *StructInitExprContext {
	var p = new(StructInitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
	return p
}

func InitEmptyStructInitExprContext(p *StructInitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
}

func (*StructInitExprContext) IsStructInitExprContext() {}

func NewStructInitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructInitExprContext {
	var p = new(StructInitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structInitExpr

	return p
}

func (s *StructInitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StructInitExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructInitExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *StructInitExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *StructInitExprContext) StructFieldList() IStructFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldListContext)
}

func (s *StructInitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructInitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructInitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructInitExpr(s)
	}
}

func (s *StructInitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructInitExpr(s)
	}
}

func (s *StructInitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructInitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructInitExpr() (localctx IStructInitExprContext) {
	localctx = NewStructInitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ManuscriptRULE_structInitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1189)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1190)
			p.StructFieldList()
		}

	}
	{
		p.SetState(1193)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldListContext is an interface to support dynamic dispatch.
type IStructFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStructFieldListContext differentiates from other interfaces.
	IsStructFieldListContext()
}

type StructFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldListContext() *StructFieldListContext {
	var p = new(StructFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
	return p
}

func InitEmptyStructFieldListContext(p *StructFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
}

func (*StructFieldListContext) IsStructFieldListContext() {}

func NewStructFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldListContext {
	var p = new(StructFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structFieldList

	return p
}

func (s *StructFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldListContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *StructFieldListContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *StructFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *StructFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *StructFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructFieldList(s)
	}
}

func (s *StructFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructFieldList(s)
	}
}

func (s *StructFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructFieldList() (localctx IStructFieldListContext) {
	localctx = NewStructFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ManuscriptRULE_structFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.StructField()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1196)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1197)
				p.StructField()
			}

		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1204)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1203)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *StructFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ManuscriptRULE_structField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1206)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1207)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1208)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) CopyAll(ctx *TypeAnnotationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LabelTypeAnnVoidContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnVoidContext {
	var p = new(LabelTypeAnnVoidContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LabelTypeAnnVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnVoid(s)
	}
}

func (s *LabelTypeAnnVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnArrayContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnArrayContext {
	var p = new(LabelTypeAnnArrayContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnArrayContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *LabelTypeAnnArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnArray(s)
	}
}

func (s *LabelTypeAnnArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnTupleContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnTupleContext {
	var p = new(LabelTypeAnnTupleContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnTupleContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *LabelTypeAnnTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnTuple(s)
	}
}

func (s *LabelTypeAnnTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnFnContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnFnContext {
	var p = new(LabelTypeAnnFnContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnFnContext) FnType() IFnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnTypeContext)
}

func (s *LabelTypeAnnFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnFn(s)
	}
}

func (s *LabelTypeAnnFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type LabelTypeAnnIDContext struct {
	TypeAnnotationContext
}

func NewLabelTypeAnnIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LabelTypeAnnIDContext {
	var p = new(LabelTypeAnnIDContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *LabelTypeAnnIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelTypeAnnIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *LabelTypeAnnIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLabelTypeAnnID(s)
	}
}

func (s *LabelTypeAnnIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLabelTypeAnnID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ManuscriptRULE_typeAnnotation)
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLabelTypeAnnIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1210)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewLabelTypeAnnArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1211)
			p.ArrayType()
		}

	case 3:
		localctx = NewLabelTypeAnnTupleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1212)
			p.TupleType()
		}

	case 4:
		localctx = NewLabelTypeAnnFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1213)
			p.FnType()
		}

	case 5:
		localctx = NewLabelTypeAnnVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1214)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(1218)
			p.TypeList()
		}

	}
	{
		p.SetState(1221)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ArrayTypeContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayTypeContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ManuscriptRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1223)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1224)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1225)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnTypeContext is an interface to support dynamic dispatch.
type IFnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnTypeContext differentiates from other interfaces.
	IsFnTypeContext()
}

type FnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnTypeContext() *FnTypeContext {
	var p = new(FnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
	return p
}

func InitEmptyFnTypeContext(p *FnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
}

func (*FnTypeContext) IsFnTypeContext() {}

func NewFnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnTypeContext {
	var p = new(FnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnType

	return p
}

func (s *FnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FnTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnTypeContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnTypeContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnType(s)
	}
}

func (s *FnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnType(s)
	}
}

func (s *FnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnType() (localctx IFnTypeContext) {
	localctx = NewFnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ManuscriptRULE_fnType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1227)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1228)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1229)
			p.Parameters()
		}

	}
	{
		p.SetState(1232)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1234)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1233)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_sepContext is an interface to support dynamic dispatch.
type IStmt_sepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	NEWLINE() antlr.TerminalNode

	// IsStmt_sepContext differentiates from other interfaces.
	IsStmt_sepContext()
}

type Stmt_sepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_sepContext() *Stmt_sepContext {
	var p = new(Stmt_sepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
	return p
}

func InitEmptyStmt_sepContext(p *Stmt_sepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
}

func (*Stmt_sepContext) IsStmt_sepContext() {}

func NewStmt_sepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_sepContext {
	var p = new(Stmt_sepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt_sep

	return p
}

func (s *Stmt_sepContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_sepContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *Stmt_sepContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEWLINE, 0)
}

func (s *Stmt_sepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_sepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt_sep(s)
	}
}

func (s *Stmt_sepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt_sep(s)
	}
}

func (s *Stmt_sepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt_sep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt_sep() (localctx IStmt_sepContext) {
	localctx = NewStmt_sepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, ManuscriptRULE_stmt_sep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1236)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Manuscript) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 61:
		var t *LogicalOrExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalOrExprContext)
		}
		return p.LogicalOrExpr_Sempred(t, predIndex)

	case 62:
		var t *LogicalAndExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalAndExprContext)
		}
		return p.LogicalAndExpr_Sempred(t, predIndex)

	case 63:
		var t *BitwiseXorExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseXorExprContext)
		}
		return p.BitwiseXorExpr_Sempred(t, predIndex)

	case 64:
		var t *BitwiseAndExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseAndExprContext)
		}
		return p.BitwiseAndExpr_Sempred(t, predIndex)

	case 65:
		var t *EqualityExprContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExprContext)
		}
		return p.EqualityExpr_Sempred(t, predIndex)

	case 67:
		var t *ComparisonExprContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonExprContext)
		}
		return p.ComparisonExpr_Sempred(t, predIndex)

	case 69:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 70:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 73:
		var t *PostfixExprContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExprContext)
		}
		return p.PostfixExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Manuscript) LogicalOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) LogicalAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseXorExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) EqualityExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ComparisonExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) PostfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
