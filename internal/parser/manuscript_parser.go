// Code generated from Manuscript.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // Manuscript

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Manuscript struct {
	*antlr.BaseParser
}

var ManuscriptParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func manuscriptParserInit() {
	staticData := &ManuscriptParserStaticData
	staticData.LiteralNames = []string{
		"", "'\\n'", "", "", "", "'let'", "'fn'", "'return'", "'yield'", "'type'",
		"'interface'", "'import'", "'export'", "'extern'", "'void'", "'check'",
		"'try'", "'catch'", "'in'", "'as'", "'is'", "'extends'", "'from'", "'null'",
		"'if'", "'else'", "'for'", "'while'", "'true'", "'false'", "'match'",
		"'case'", "'async'", "'await'", "'methods'", "'break'", "'continue'",
		"'default'", "'defer'", "'go'", "", "", "'['", "']'", "'('", "')'",
		"'<'", "'>'", "'<='", "'>='", "':'", "';'", "','", "'='", "'=='", "'+'",
		"'-'", "'++'", "'--'", "'||'", "'&&'", "'*'", "'/'", "'%'", "'!'", "'?'",
		"'.'", "'!='", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", "'|'",
		"'&'", "'^'", "'<<'", "'>>'",
	}
	staticData.SymbolicNames = []string{
		"", "NEWLINE", "WS", "COMMENT", "MULTI_LINE_COMMENT", "LET", "FN", "RETURN",
		"YIELD", "TYPE", "INTERFACE", "IMPORT", "EXPORT", "EXTERN", "VOID",
		"CHECK", "TRY", "CATCH", "IN", "AS", "IS", "EXTENDS", "FROM", "NULL",
		"IF", "ELSE", "FOR", "WHILE", "TRUE", "FALSE", "MATCH", "CASE", "ASYNC",
		"AWAIT", "METHODS", "BREAK", "CONTINUE", "DEFAULT", "DEFER", "GO", "LBRACE",
		"RBRACE", "LSQBR", "RSQBR", "LPAREN", "RPAREN", "LT", "GT", "LT_EQUALS",
		"GT_EQUALS", "COLON", "SEMICOLON", "COMMA", "EQUALS", "EQUALS_EQUALS",
		"PLUS", "MINUS", "PLUS_PLUS", "MINUS_MINUS", "PIPE_PIPE", "AMP_AMP",
		"STAR", "SLASH", "MOD", "EXCLAMATION", "QUESTION", "DOT", "NEQ", "PLUS_EQUALS",
		"MINUS_EQUALS", "STAR_EQUALS", "SLASH_EQUALS", "MOD_EQUALS", "CARET_EQUALS",
		"PIPE", "AMP", "CARET", "LSHIFT", "RSHIFT", "HEX_LITERAL", "BINARY_LITERAL",
		"OCTAL_LITERAL", "FLOAT", "INTEGER", "ID", "SINGLE_QUOTE_START", "MULTI_QUOTE_START",
		"DOUBLE_QUOTE_START", "MULTI_DOUBLE_QUOTE_START", "SINGLE_STR_INTERP_START",
		"SINGLE_STR_CONTENT", "SINGLE_STR_END", "MULTI_STR_INTERP_START", "MULTI_STR_CONTENT",
		"MULTI_STR_END", "DOUBLE_STR_INTERP_START", "DOUBLE_STR_CONTENT", "DOUBLE_STR_END",
		"MULTI_DOUBLE_STR_INTERP_START", "MULTI_DOUBLE_STR_CONTENT", "MULTI_DOUBLE_STR_END",
		"INTERP_LBRACE", "INTERP_RBRACE", "INTERP_WS",
	}
	staticData.RuleNames = []string{
		"program", "declaration", "importDecl", "exportDecl", "externDecl",
		"exportedItem", "moduleImport", "destructuredImport", "targetImport",
		"importItemList", "importItem", "importStr", "letDecl", "letSingle",
		"letBlock", "letBlockItemList", "letBlockItemSep", "letBlockItem", "letDestructuredObj",
		"letDestructuredArray", "typedIDList", "typedID", "typeDecl", "typeDefBody",
		"typeAlias", "fieldList", "fieldDecl", "typeList", "interfaceDecl",
		"interfaceMethod", "fnDecl", "fnSignature", "parameters", "param", "methodsDecl",
		"methodImplList", "methodImplSep", "methodImpl", "stmt", "returnStmt",
		"yieldStmt", "deferStmt", "exprList", "ifStmt", "forStmt", "forLoopType",
		"forTrinity", "forInit", "forCond", "forPost", "whileStmt", "loopBody",
		"codeBlock", "breakStmt", "continueStmt", "checkStmt", "expr", "assignmentExpr",
		"assignmentOp", "ternaryExpr", "logicalOrExpr", "logicalAndExpr", "bitwiseOrExpr",
		"bitwiseXorExpr", "bitwiseAndExpr", "equalityExpr", "comparisonOp",
		"comparisonExpr", "shiftExpr", "additiveExpr", "multiplicativeExpr",
		"unaryExpr", "awaitExpr", "postfixExpr", "postfixOp", "primaryExpr",
		"fnExpr", "matchExpr", "caseClause", "defaultClause", "singleQuotedString",
		"multiQuotedString", "doubleQuotedString", "multiDoubleQuotedString",
		"stringPart", "interpolation", "literal", "stringLiteral", "numberLiteral",
		"booleanLiteral", "arrayLiteral", "objectLiteral", "objectFieldList",
		"objectField", "objectFieldName", "mapLiteral", "mapFieldList", "mapField",
		"setLiteral", "taggedBlockString", "structInitExpr", "structFieldList",
		"structField", "typeAnnotation", "tupleType", "arrayType", "fnType",
		"stmt_sep",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 103, 1217, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 1, 0, 5, 0,
		218, 8, 0, 10, 0, 12, 0, 221, 9, 0, 1, 0, 5, 0, 224, 8, 0, 10, 0, 12, 0,
		227, 9, 0, 1, 0, 5, 0, 230, 8, 0, 10, 0, 12, 0, 233, 9, 0, 1, 0, 1, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 245, 8, 1, 1, 2,
		1, 2, 1, 2, 3, 2, 250, 8, 2, 1, 3, 1, 3, 1, 3, 3, 3, 255, 8, 3, 1, 4, 1,
		4, 1, 4, 3, 4, 260, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 266, 8, 5, 1, 6,
		1, 6, 3, 6, 270, 8, 6, 1, 7, 1, 7, 3, 7, 274, 8, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 5, 9, 287, 8, 9, 10, 9, 12,
		9, 290, 9, 9, 1, 9, 3, 9, 293, 8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 298, 8,
		10, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 3, 12, 305, 8, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 310, 8, 12, 1, 12, 1, 12, 1, 12, 3, 12, 315, 8, 12, 1, 12,
		1, 12, 1, 12, 3, 12, 320, 8, 12, 3, 12, 322, 8, 12, 1, 13, 1, 13, 1, 13,
		3, 13, 327, 8, 13, 1, 14, 1, 14, 3, 14, 331, 8, 14, 1, 14, 1, 14, 1, 15,
		5, 15, 336, 8, 15, 10, 15, 12, 15, 339, 9, 15, 1, 15, 1, 15, 4, 15, 343,
		8, 15, 11, 15, 12, 15, 344, 1, 15, 1, 15, 5, 15, 349, 8, 15, 10, 15, 12,
		15, 352, 9, 15, 1, 15, 5, 15, 355, 8, 15, 10, 15, 12, 15, 358, 9, 15, 1,
		16, 1, 16, 3, 16, 362, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3,
		17, 380, 8, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 5, 20, 397, 8, 20, 10,
		20, 12, 20, 400, 9, 20, 1, 20, 3, 20, 403, 8, 20, 1, 21, 1, 21, 3, 21,
		407, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 413, 8, 22, 1, 23, 1, 23,
		3, 23, 417, 8, 23, 1, 23, 1, 23, 5, 23, 421, 8, 23, 10, 23, 12, 23, 424,
		9, 23, 1, 23, 1, 23, 5, 23, 428, 8, 23, 10, 23, 12, 23, 431, 9, 23, 1,
		23, 1, 23, 5, 23, 435, 8, 23, 10, 23, 12, 23, 438, 9, 23, 1, 23, 5, 23,
		441, 8, 23, 10, 23, 12, 23, 444, 9, 23, 1, 23, 5, 23, 447, 8, 23, 10, 23,
		12, 23, 450, 9, 23, 1, 23, 3, 23, 453, 8, 23, 1, 23, 5, 23, 456, 8, 23,
		10, 23, 12, 23, 459, 9, 23, 3, 23, 461, 8, 23, 1, 23, 1, 23, 1, 24, 1,
		24, 1, 24, 1, 24, 3, 24, 469, 8, 24, 1, 25, 1, 25, 1, 25, 5, 25, 474, 8,
		25, 10, 25, 12, 25, 477, 9, 25, 1, 25, 3, 25, 480, 8, 25, 1, 26, 1, 26,
		3, 26, 484, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 5, 27, 491, 8, 27,
		10, 27, 12, 27, 494, 9, 27, 1, 27, 3, 27, 497, 8, 27, 1, 28, 1, 28, 1,
		28, 1, 28, 3, 28, 503, 8, 28, 1, 28, 1, 28, 5, 28, 507, 8, 28, 10, 28,
		12, 28, 510, 9, 28, 1, 28, 1, 28, 5, 28, 514, 8, 28, 10, 28, 12, 28, 517,
		9, 28, 4, 28, 519, 8, 28, 11, 28, 12, 28, 520, 1, 28, 1, 28, 1, 29, 1,
		29, 1, 29, 3, 29, 528, 8, 29, 1, 29, 1, 29, 3, 29, 532, 8, 29, 1, 29, 3,
		29, 535, 8, 29, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31,
		544, 8, 31, 1, 31, 1, 31, 3, 31, 548, 8, 31, 1, 31, 3, 31, 551, 8, 31,
		1, 32, 1, 32, 1, 32, 5, 32, 556, 8, 32, 10, 32, 12, 32, 559, 9, 32, 1,
		32, 3, 32, 562, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 3, 33, 568, 8, 33, 1,
		34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 576, 8, 34, 1, 34, 1, 34,
		1, 35, 5, 35, 581, 8, 35, 10, 35, 12, 35, 584, 9, 35, 1, 35, 1, 35, 4,
		35, 588, 8, 35, 11, 35, 12, 35, 589, 1, 35, 1, 35, 5, 35, 594, 8, 35, 10,
		35, 12, 35, 597, 9, 35, 1, 35, 5, 35, 600, 8, 35, 10, 35, 12, 35, 603,
		9, 35, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 3, 38, 613,
		8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 3, 38, 625, 8, 38, 1, 39, 1, 39, 3, 39, 629, 8, 39, 1, 39, 3, 39, 632,
		8, 39, 1, 40, 1, 40, 3, 40, 636, 8, 40, 1, 40, 3, 40, 639, 8, 40, 1, 41,
		1, 41, 1, 41, 3, 41, 644, 8, 41, 1, 42, 1, 42, 1, 42, 5, 42, 649, 8, 42,
		10, 42, 12, 42, 652, 9, 42, 1, 42, 3, 42, 655, 8, 42, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 3, 43, 662, 8, 43, 1, 44, 1, 44, 1, 44, 1, 45, 1, 45,
		1, 45, 1, 45, 3, 45, 671, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45, 3, 45, 677,
		8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3,
		47, 688, 8, 47, 1, 48, 1, 48, 3, 48, 692, 8, 48, 1, 49, 1, 49, 3, 49, 696,
		8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 5, 51, 704, 8, 51, 10,
		51, 12, 51, 707, 9, 51, 1, 51, 5, 51, 710, 8, 51, 10, 51, 12, 51, 713,
		9, 51, 1, 51, 5, 51, 716, 8, 51, 10, 51, 12, 51, 719, 9, 51, 1, 51, 1,
		51, 1, 52, 1, 52, 5, 52, 725, 8, 52, 10, 52, 12, 52, 728, 9, 52, 1, 52,
		5, 52, 731, 8, 52, 10, 52, 12, 52, 734, 9, 52, 1, 52, 5, 52, 737, 8, 52,
		10, 52, 12, 52, 740, 9, 52, 1, 52, 1, 52, 1, 53, 1, 53, 3, 53, 746, 8,
		53, 1, 54, 1, 54, 3, 54, 750, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		3, 55, 757, 8, 55, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3,
		57, 766, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58,
		775, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 784,
		8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 792, 8, 60, 10,
		60, 12, 60, 795, 9, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61,
		803, 8, 61, 10, 61, 12, 61, 806, 9, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1,
		62, 1, 62, 5, 62, 814, 8, 62, 10, 62, 12, 62, 817, 9, 62, 1, 63, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 825, 8, 63, 10, 63, 12, 63, 828, 9,
		63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 5, 64, 836, 8, 64, 10, 64,
		12, 64, 839, 9, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 5, 65, 847,
		8, 65, 10, 65, 12, 65, 850, 9, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 5, 67, 861, 8, 67, 10, 67, 12, 67, 864, 9, 67,
		1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 5, 68, 872, 8, 68, 10, 68, 12,
		68, 875, 9, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 883, 8,
		69, 10, 69, 12, 69, 886, 9, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70,
		5, 70, 894, 8, 70, 10, 70, 12, 70, 897, 9, 70, 1, 71, 1, 71, 1, 71, 3,
		71, 902, 8, 71, 1, 72, 3, 72, 905, 8, 72, 1, 72, 3, 72, 908, 8, 72, 1,
		72, 3, 72, 911, 8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73,
		5, 73, 920, 8, 73, 10, 73, 12, 73, 923, 9, 73, 1, 74, 1, 74, 3, 74, 927,
		8, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 936, 8,
		74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75,
		1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 954, 8, 75, 1, 76, 1,
		76, 1, 76, 3, 76, 959, 8, 76, 1, 76, 1, 76, 3, 76, 963, 8, 76, 1, 76, 1,
		76, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 971, 8, 77, 10, 77, 12, 77, 974,
		9, 77, 1, 77, 1, 77, 4, 77, 978, 8, 77, 11, 77, 12, 77, 979, 1, 77, 1,
		77, 5, 77, 984, 8, 77, 10, 77, 12, 77, 987, 9, 77, 1, 77, 5, 77, 990, 8,
		77, 10, 77, 12, 77, 993, 9, 77, 1, 77, 3, 77, 996, 8, 77, 1, 77, 1, 77,
		1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 1004, 8, 78, 1, 78, 3, 78, 1007, 8,
		78, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1013, 8, 79, 1, 79, 3, 79, 1016,
		8, 79, 1, 80, 1, 80, 5, 80, 1020, 8, 80, 10, 80, 12, 80, 1023, 9, 80, 1,
		80, 1, 80, 1, 81, 1, 81, 5, 81, 1029, 8, 81, 10, 81, 12, 81, 1032, 9, 81,
		1, 81, 1, 81, 1, 82, 1, 82, 5, 82, 1038, 8, 82, 10, 82, 12, 82, 1041, 9,
		82, 1, 82, 1, 82, 1, 83, 1, 83, 5, 83, 1047, 8, 83, 10, 83, 12, 83, 1050,
		9, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1059, 8,
		84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86,
		1070, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1076, 8, 87, 1, 88, 1,
		88, 1, 88, 1, 88, 1, 88, 3, 88, 1083, 8, 88, 1, 89, 1, 89, 3, 89, 1087,
		8, 89, 1, 90, 1, 90, 3, 90, 1091, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 3,
		91, 1097, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 5, 92, 1104, 8, 92,
		10, 92, 12, 92, 1107, 9, 92, 1, 92, 3, 92, 1110, 8, 92, 1, 93, 1, 93, 1,
		93, 3, 93, 1115, 8, 93, 1, 94, 1, 94, 3, 94, 1119, 8, 94, 1, 95, 1, 95,
		1, 95, 1, 95, 1, 95, 3, 95, 1126, 8, 95, 1, 95, 3, 95, 1129, 8, 95, 1,
		96, 1, 96, 1, 96, 5, 96, 1134, 8, 96, 10, 96, 12, 96, 1137, 9, 96, 1, 96,
		3, 96, 1140, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1,
		98, 5, 98, 1150, 8, 98, 10, 98, 12, 98, 1153, 9, 98, 1, 98, 3, 98, 1156,
		8, 98, 3, 98, 1158, 8, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 3, 99, 1165,
		8, 99, 1, 100, 1, 100, 1, 100, 3, 100, 1170, 8, 100, 1, 100, 1, 100, 1,
		101, 1, 101, 1, 101, 5, 101, 1177, 8, 101, 10, 101, 12, 101, 1180, 9, 101,
		1, 101, 3, 101, 1183, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 103, 1,
		103, 1, 103, 1, 103, 1, 103, 3, 103, 1194, 8, 103, 1, 104, 1, 104, 3, 104,
		1198, 8, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1,
		106, 1, 106, 3, 106, 1209, 8, 106, 1, 106, 1, 106, 3, 106, 1213, 8, 106,
		1, 107, 1, 107, 1, 107, 0, 11, 120, 122, 124, 126, 128, 130, 134, 136,
		138, 140, 146, 108, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
		130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
		160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
		190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 0, 7,
		2, 0, 54, 54, 67, 67, 1, 0, 46, 49, 1, 0, 55, 56, 1, 0, 61, 63, 3, 0, 16,
		16, 55, 56, 64, 64, 4, 0, 89, 89, 92, 92, 95, 95, 98, 98, 2, 0, 1, 1, 51,
		51, 1309, 0, 225, 1, 0, 0, 0, 2, 244, 1, 0, 0, 0, 4, 246, 1, 0, 0, 0, 6,
		251, 1, 0, 0, 0, 8, 256, 1, 0, 0, 0, 10, 265, 1, 0, 0, 0, 12, 269, 1, 0,
		0, 0, 14, 271, 1, 0, 0, 0, 16, 279, 1, 0, 0, 0, 18, 283, 1, 0, 0, 0, 20,
		294, 1, 0, 0, 0, 22, 299, 1, 0, 0, 0, 24, 321, 1, 0, 0, 0, 26, 323, 1,
		0, 0, 0, 28, 328, 1, 0, 0, 0, 30, 337, 1, 0, 0, 0, 32, 361, 1, 0, 0, 0,
		34, 379, 1, 0, 0, 0, 36, 381, 1, 0, 0, 0, 38, 387, 1, 0, 0, 0, 40, 393,
		1, 0, 0, 0, 42, 404, 1, 0, 0, 0, 44, 408, 1, 0, 0, 0, 46, 416, 1, 0, 0,
		0, 48, 464, 1, 0, 0, 0, 50, 470, 1, 0, 0, 0, 52, 481, 1, 0, 0, 0, 54, 487,
		1, 0, 0, 0, 56, 498, 1, 0, 0, 0, 58, 524, 1, 0, 0, 0, 60, 536, 1, 0, 0,
		0, 62, 539, 1, 0, 0, 0, 64, 552, 1, 0, 0, 0, 66, 563, 1, 0, 0, 0, 68, 569,
		1, 0, 0, 0, 70, 582, 1, 0, 0, 0, 72, 604, 1, 0, 0, 0, 74, 606, 1, 0, 0,
		0, 76, 624, 1, 0, 0, 0, 78, 626, 1, 0, 0, 0, 80, 633, 1, 0, 0, 0, 82, 640,
		1, 0, 0, 0, 84, 645, 1, 0, 0, 0, 86, 656, 1, 0, 0, 0, 88, 663, 1, 0, 0,
		0, 90, 676, 1, 0, 0, 0, 92, 678, 1, 0, 0, 0, 94, 687, 1, 0, 0, 0, 96, 691,
		1, 0, 0, 0, 98, 695, 1, 0, 0, 0, 100, 697, 1, 0, 0, 0, 102, 701, 1, 0,
		0, 0, 104, 722, 1, 0, 0, 0, 106, 743, 1, 0, 0, 0, 108, 747, 1, 0, 0, 0,
		110, 751, 1, 0, 0, 0, 112, 758, 1, 0, 0, 0, 114, 765, 1, 0, 0, 0, 116,
		774, 1, 0, 0, 0, 118, 783, 1, 0, 0, 0, 120, 785, 1, 0, 0, 0, 122, 796,
		1, 0, 0, 0, 124, 807, 1, 0, 0, 0, 126, 818, 1, 0, 0, 0, 128, 829, 1, 0,
		0, 0, 130, 840, 1, 0, 0, 0, 132, 851, 1, 0, 0, 0, 134, 853, 1, 0, 0, 0,
		136, 865, 1, 0, 0, 0, 138, 876, 1, 0, 0, 0, 140, 887, 1, 0, 0, 0, 142,
		901, 1, 0, 0, 0, 144, 904, 1, 0, 0, 0, 146, 914, 1, 0, 0, 0, 148, 935,
		1, 0, 0, 0, 150, 953, 1, 0, 0, 0, 152, 955, 1, 0, 0, 0, 154, 966, 1, 0,
		0, 0, 156, 999, 1, 0, 0, 0, 158, 1008, 1, 0, 0, 0, 160, 1017, 1, 0, 0,
		0, 162, 1026, 1, 0, 0, 0, 164, 1035, 1, 0, 0, 0, 166, 1044, 1, 0, 0, 0,
		168, 1058, 1, 0, 0, 0, 170, 1060, 1, 0, 0, 0, 172, 1069, 1, 0, 0, 0, 174,
		1075, 1, 0, 0, 0, 176, 1082, 1, 0, 0, 0, 178, 1086, 1, 0, 0, 0, 180, 1088,
		1, 0, 0, 0, 182, 1094, 1, 0, 0, 0, 184, 1100, 1, 0, 0, 0, 186, 1111, 1,
		0, 0, 0, 188, 1118, 1, 0, 0, 0, 190, 1128, 1, 0, 0, 0, 192, 1130, 1, 0,
		0, 0, 194, 1141, 1, 0, 0, 0, 196, 1145, 1, 0, 0, 0, 198, 1161, 1, 0, 0,
		0, 200, 1166, 1, 0, 0, 0, 202, 1173, 1, 0, 0, 0, 204, 1184, 1, 0, 0, 0,
		206, 1193, 1, 0, 0, 0, 208, 1195, 1, 0, 0, 0, 210, 1201, 1, 0, 0, 0, 212,
		1205, 1, 0, 0, 0, 214, 1214, 1, 0, 0, 0, 216, 218, 3, 214, 107, 0, 217,
		216, 1, 0, 0, 0, 218, 221, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 219, 220,
		1, 0, 0, 0, 220, 222, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 222, 224, 3, 2,
		1, 0, 223, 219, 1, 0, 0, 0, 224, 227, 1, 0, 0, 0, 225, 223, 1, 0, 0, 0,
		225, 226, 1, 0, 0, 0, 226, 231, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 228,
		230, 3, 214, 107, 0, 229, 228, 1, 0, 0, 0, 230, 233, 1, 0, 0, 0, 231, 229,
		1, 0, 0, 0, 231, 232, 1, 0, 0, 0, 232, 234, 1, 0, 0, 0, 233, 231, 1, 0,
		0, 0, 234, 235, 5, 0, 0, 1, 235, 1, 1, 0, 0, 0, 236, 245, 3, 4, 2, 0, 237,
		245, 3, 6, 3, 0, 238, 245, 3, 8, 4, 0, 239, 245, 3, 24, 12, 0, 240, 245,
		3, 44, 22, 0, 241, 245, 3, 56, 28, 0, 242, 245, 3, 60, 30, 0, 243, 245,
		3, 68, 34, 0, 244, 236, 1, 0, 0, 0, 244, 237, 1, 0, 0, 0, 244, 238, 1,
		0, 0, 0, 244, 239, 1, 0, 0, 0, 244, 240, 1, 0, 0, 0, 244, 241, 1, 0, 0,
		0, 244, 242, 1, 0, 0, 0, 244, 243, 1, 0, 0, 0, 245, 3, 1, 0, 0, 0, 246,
		247, 5, 11, 0, 0, 247, 249, 3, 12, 6, 0, 248, 250, 5, 51, 0, 0, 249, 248,
		1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 5, 1, 0, 0, 0, 251, 252, 5, 12,
		0, 0, 252, 254, 3, 10, 5, 0, 253, 255, 5, 51, 0, 0, 254, 253, 1, 0, 0,
		0, 254, 255, 1, 0, 0, 0, 255, 7, 1, 0, 0, 0, 256, 257, 5, 13, 0, 0, 257,
		259, 3, 12, 6, 0, 258, 260, 5, 51, 0, 0, 259, 258, 1, 0, 0, 0, 259, 260,
		1, 0, 0, 0, 260, 9, 1, 0, 0, 0, 261, 266, 3, 60, 30, 0, 262, 266, 3, 24,
		12, 0, 263, 266, 3, 44, 22, 0, 264, 266, 3, 56, 28, 0, 265, 261, 1, 0,
		0, 0, 265, 262, 1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 265, 264, 1, 0, 0, 0,
		266, 11, 1, 0, 0, 0, 267, 270, 3, 14, 7, 0, 268, 270, 3, 16, 8, 0, 269,
		267, 1, 0, 0, 0, 269, 268, 1, 0, 0, 0, 270, 13, 1, 0, 0, 0, 271, 273, 5,
		40, 0, 0, 272, 274, 3, 18, 9, 0, 273, 272, 1, 0, 0, 0, 273, 274, 1, 0,
		0, 0, 274, 275, 1, 0, 0, 0, 275, 276, 5, 41, 0, 0, 276, 277, 5, 22, 0,
		0, 277, 278, 3, 22, 11, 0, 278, 15, 1, 0, 0, 0, 279, 280, 5, 84, 0, 0,
		280, 281, 5, 22, 0, 0, 281, 282, 3, 22, 11, 0, 282, 17, 1, 0, 0, 0, 283,
		288, 3, 20, 10, 0, 284, 285, 5, 52, 0, 0, 285, 287, 3, 20, 10, 0, 286,
		284, 1, 0, 0, 0, 287, 290, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 288, 289,
		1, 0, 0, 0, 289, 292, 1, 0, 0, 0, 290, 288, 1, 0, 0, 0, 291, 293, 5, 52,
		0, 0, 292, 291, 1, 0, 0, 0, 292, 293, 1, 0, 0, 0, 293, 19, 1, 0, 0, 0,
		294, 297, 5, 84, 0, 0, 295, 296, 5, 19, 0, 0, 296, 298, 5, 84, 0, 0, 297,
		295, 1, 0, 0, 0, 297, 298, 1, 0, 0, 0, 298, 21, 1, 0, 0, 0, 299, 300, 3,
		160, 80, 0, 300, 23, 1, 0, 0, 0, 301, 302, 5, 5, 0, 0, 302, 304, 3, 26,
		13, 0, 303, 305, 5, 51, 0, 0, 304, 303, 1, 0, 0, 0, 304, 305, 1, 0, 0,
		0, 305, 322, 1, 0, 0, 0, 306, 307, 5, 5, 0, 0, 307, 309, 3, 28, 14, 0,
		308, 310, 5, 51, 0, 0, 309, 308, 1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310,
		322, 1, 0, 0, 0, 311, 312, 5, 5, 0, 0, 312, 314, 3, 36, 18, 0, 313, 315,
		5, 51, 0, 0, 314, 313, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 322, 1, 0,
		0, 0, 316, 317, 5, 5, 0, 0, 317, 319, 3, 38, 19, 0, 318, 320, 5, 51, 0,
		0, 319, 318, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 322, 1, 0, 0, 0, 321,
		301, 1, 0, 0, 0, 321, 306, 1, 0, 0, 0, 321, 311, 1, 0, 0, 0, 321, 316,
		1, 0, 0, 0, 322, 25, 1, 0, 0, 0, 323, 326, 3, 42, 21, 0, 324, 325, 5, 53,
		0, 0, 325, 327, 3, 112, 56, 0, 326, 324, 1, 0, 0, 0, 326, 327, 1, 0, 0,
		0, 327, 27, 1, 0, 0, 0, 328, 330, 5, 44, 0, 0, 329, 331, 3, 30, 15, 0,
		330, 329, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332,
		333, 5, 45, 0, 0, 333, 29, 1, 0, 0, 0, 334, 336, 3, 32, 16, 0, 335, 334,
		1, 0, 0, 0, 336, 339, 1, 0, 0, 0, 337, 335, 1, 0, 0, 0, 337, 338, 1, 0,
		0, 0, 338, 340, 1, 0, 0, 0, 339, 337, 1, 0, 0, 0, 340, 350, 3, 34, 17,
		0, 341, 343, 3, 32, 16, 0, 342, 341, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0,
		344, 342, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346,
		347, 3, 34, 17, 0, 347, 349, 1, 0, 0, 0, 348, 342, 1, 0, 0, 0, 349, 352,
		1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 356, 1, 0,
		0, 0, 352, 350, 1, 0, 0, 0, 353, 355, 3, 32, 16, 0, 354, 353, 1, 0, 0,
		0, 355, 358, 1, 0, 0, 0, 356, 354, 1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357,
		31, 1, 0, 0, 0, 358, 356, 1, 0, 0, 0, 359, 362, 5, 52, 0, 0, 360, 362,
		3, 214, 107, 0, 361, 359, 1, 0, 0, 0, 361, 360, 1, 0, 0, 0, 362, 33, 1,
		0, 0, 0, 363, 364, 3, 42, 21, 0, 364, 365, 5, 53, 0, 0, 365, 366, 3, 112,
		56, 0, 366, 380, 1, 0, 0, 0, 367, 368, 5, 40, 0, 0, 368, 369, 3, 40, 20,
		0, 369, 370, 5, 41, 0, 0, 370, 371, 5, 53, 0, 0, 371, 372, 3, 112, 56,
		0, 372, 380, 1, 0, 0, 0, 373, 374, 5, 42, 0, 0, 374, 375, 3, 40, 20, 0,
		375, 376, 5, 43, 0, 0, 376, 377, 5, 53, 0, 0, 377, 378, 3, 112, 56, 0,
		378, 380, 1, 0, 0, 0, 379, 363, 1, 0, 0, 0, 379, 367, 1, 0, 0, 0, 379,
		373, 1, 0, 0, 0, 380, 35, 1, 0, 0, 0, 381, 382, 5, 40, 0, 0, 382, 383,
		3, 40, 20, 0, 383, 384, 5, 41, 0, 0, 384, 385, 5, 53, 0, 0, 385, 386, 3,
		112, 56, 0, 386, 37, 1, 0, 0, 0, 387, 388, 5, 42, 0, 0, 388, 389, 3, 40,
		20, 0, 389, 390, 5, 43, 0, 0, 390, 391, 5, 53, 0, 0, 391, 392, 3, 112,
		56, 0, 392, 39, 1, 0, 0, 0, 393, 398, 3, 42, 21, 0, 394, 395, 5, 52, 0,
		0, 395, 397, 3, 42, 21, 0, 396, 394, 1, 0, 0, 0, 397, 400, 1, 0, 0, 0,
		398, 396, 1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 402, 1, 0, 0, 0, 400,
		398, 1, 0, 0, 0, 401, 403, 5, 52, 0, 0, 402, 401, 1, 0, 0, 0, 402, 403,
		1, 0, 0, 0, 403, 41, 1, 0, 0, 0, 404, 406, 5, 84, 0, 0, 405, 407, 3, 206,
		103, 0, 406, 405, 1, 0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 43, 1, 0, 0, 0,
		408, 409, 5, 9, 0, 0, 409, 412, 5, 84, 0, 0, 410, 413, 3, 46, 23, 0, 411,
		413, 3, 48, 24, 0, 412, 410, 1, 0, 0, 0, 412, 411, 1, 0, 0, 0, 413, 45,
		1, 0, 0, 0, 414, 415, 5, 21, 0, 0, 415, 417, 3, 54, 27, 0, 416, 414, 1,
		0, 0, 0, 416, 417, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 460, 5, 40, 0,
		0, 419, 421, 3, 214, 107, 0, 420, 419, 1, 0, 0, 0, 421, 424, 1, 0, 0, 0,
		422, 420, 1, 0, 0, 0, 422, 423, 1, 0, 0, 0, 423, 425, 1, 0, 0, 0, 424,
		422, 1, 0, 0, 0, 425, 442, 3, 52, 26, 0, 426, 428, 3, 214, 107, 0, 427,
		426, 1, 0, 0, 0, 428, 431, 1, 0, 0, 0, 429, 427, 1, 0, 0, 0, 429, 430,
		1, 0, 0, 0, 430, 432, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 432, 436, 5, 52,
		0, 0, 433, 435, 3, 214, 107, 0, 434, 433, 1, 0, 0, 0, 435, 438, 1, 0, 0,
		0, 436, 434, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 437, 439, 1, 0, 0, 0, 438,
		436, 1, 0, 0, 0, 439, 441, 3, 52, 26, 0, 440, 429, 1, 0, 0, 0, 441, 444,
		1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 442, 443, 1, 0, 0, 0, 443, 452, 1, 0,
		0, 0, 444, 442, 1, 0, 0, 0, 445, 447, 3, 214, 107, 0, 446, 445, 1, 0, 0,
		0, 447, 450, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449,
		451, 1, 0, 0, 0, 450, 448, 1, 0, 0, 0, 451, 453, 5, 52, 0, 0, 452, 448,
		1, 0, 0, 0, 452, 453, 1, 0, 0, 0, 453, 457, 1, 0, 0, 0, 454, 456, 3, 214,
		107, 0, 455, 454, 1, 0, 0, 0, 456, 459, 1, 0, 0, 0, 457, 455, 1, 0, 0,
		0, 457, 458, 1, 0, 0, 0, 458, 461, 1, 0, 0, 0, 459, 457, 1, 0, 0, 0, 460,
		422, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 462, 1, 0, 0, 0, 462, 463,
		5, 41, 0, 0, 463, 47, 1, 0, 0, 0, 464, 465, 5, 53, 0, 0, 465, 468, 3, 206,
		103, 0, 466, 467, 5, 21, 0, 0, 467, 469, 3, 54, 27, 0, 468, 466, 1, 0,
		0, 0, 468, 469, 1, 0, 0, 0, 469, 49, 1, 0, 0, 0, 470, 475, 3, 52, 26, 0,
		471, 472, 5, 52, 0, 0, 472, 474, 3, 52, 26, 0, 473, 471, 1, 0, 0, 0, 474,
		477, 1, 0, 0, 0, 475, 473, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 479,
		1, 0, 0, 0, 477, 475, 1, 0, 0, 0, 478, 480, 5, 52, 0, 0, 479, 478, 1, 0,
		0, 0, 479, 480, 1, 0, 0, 0, 480, 51, 1, 0, 0, 0, 481, 483, 5, 84, 0, 0,
		482, 484, 5, 65, 0, 0, 483, 482, 1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484,
		485, 1, 0, 0, 0, 485, 486, 3, 206, 103, 0, 486, 53, 1, 0, 0, 0, 487, 492,
		3, 206, 103, 0, 488, 489, 5, 52, 0, 0, 489, 491, 3, 206, 103, 0, 490, 488,
		1, 0, 0, 0, 491, 494, 1, 0, 0, 0, 492, 490, 1, 0, 0, 0, 492, 493, 1, 0,
		0, 0, 493, 496, 1, 0, 0, 0, 494, 492, 1, 0, 0, 0, 495, 497, 5, 52, 0, 0,
		496, 495, 1, 0, 0, 0, 496, 497, 1, 0, 0, 0, 497, 55, 1, 0, 0, 0, 498, 499,
		5, 10, 0, 0, 499, 502, 5, 84, 0, 0, 500, 501, 5, 21, 0, 0, 501, 503, 3,
		54, 27, 0, 502, 500, 1, 0, 0, 0, 502, 503, 1, 0, 0, 0, 503, 504, 1, 0,
		0, 0, 504, 518, 5, 40, 0, 0, 505, 507, 3, 214, 107, 0, 506, 505, 1, 0,
		0, 0, 507, 510, 1, 0, 0, 0, 508, 506, 1, 0, 0, 0, 508, 509, 1, 0, 0, 0,
		509, 511, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 511, 515, 3, 58, 29, 0, 512,
		514, 3, 214, 107, 0, 513, 512, 1, 0, 0, 0, 514, 517, 1, 0, 0, 0, 515, 513,
		1, 0, 0, 0, 515, 516, 1, 0, 0, 0, 516, 519, 1, 0, 0, 0, 517, 515, 1, 0,
		0, 0, 518, 508, 1, 0, 0, 0, 519, 520, 1, 0, 0, 0, 520, 518, 1, 0, 0, 0,
		520, 521, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 523, 5, 41, 0, 0, 523,
		57, 1, 0, 0, 0, 524, 525, 5, 84, 0, 0, 525, 527, 5, 44, 0, 0, 526, 528,
		3, 64, 32, 0, 527, 526, 1, 0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 529, 1,
		0, 0, 0, 529, 531, 5, 45, 0, 0, 530, 532, 3, 206, 103, 0, 531, 530, 1,
		0, 0, 0, 531, 532, 1, 0, 0, 0, 532, 534, 1, 0, 0, 0, 533, 535, 5, 64, 0,
		0, 534, 533, 1, 0, 0, 0, 534, 535, 1, 0, 0, 0, 535, 59, 1, 0, 0, 0, 536,
		537, 3, 62, 31, 0, 537, 538, 3, 104, 52, 0, 538, 61, 1, 0, 0, 0, 539, 540,
		5, 6, 0, 0, 540, 541, 5, 84, 0, 0, 541, 543, 5, 44, 0, 0, 542, 544, 3,
		64, 32, 0, 543, 542, 1, 0, 0, 0, 543, 544, 1, 0, 0, 0, 544, 545, 1, 0,
		0, 0, 545, 547, 5, 45, 0, 0, 546, 548, 3, 206, 103, 0, 547, 546, 1, 0,
		0, 0, 547, 548, 1, 0, 0, 0, 548, 550, 1, 0, 0, 0, 549, 551, 5, 64, 0, 0,
		550, 549, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 63, 1, 0, 0, 0, 552, 557,
		3, 66, 33, 0, 553, 554, 5, 52, 0, 0, 554, 556, 3, 66, 33, 0, 555, 553,
		1, 0, 0, 0, 556, 559, 1, 0, 0, 0, 557, 555, 1, 0, 0, 0, 557, 558, 1, 0,
		0, 0, 558, 561, 1, 0, 0, 0, 559, 557, 1, 0, 0, 0, 560, 562, 5, 52, 0, 0,
		561, 560, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 65, 1, 0, 0, 0, 563, 564,
		5, 84, 0, 0, 564, 567, 3, 206, 103, 0, 565, 566, 5, 53, 0, 0, 566, 568,
		3, 112, 56, 0, 567, 565, 1, 0, 0, 0, 567, 568, 1, 0, 0, 0, 568, 67, 1,
		0, 0, 0, 569, 570, 5, 34, 0, 0, 570, 571, 5, 84, 0, 0, 571, 572, 5, 19,
		0, 0, 572, 573, 5, 84, 0, 0, 573, 575, 5, 40, 0, 0, 574, 576, 3, 70, 35,
		0, 575, 574, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 577, 1, 0, 0, 0, 577,
		578, 5, 41, 0, 0, 578, 69, 1, 0, 0, 0, 579, 581, 3, 72, 36, 0, 580, 579,
		1, 0, 0, 0, 581, 584, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 582, 583, 1, 0,
		0, 0, 583, 585, 1, 0, 0, 0, 584, 582, 1, 0, 0, 0, 585, 595, 3, 74, 37,
		0, 586, 588, 3, 72, 36, 0, 587, 586, 1, 0, 0, 0, 588, 589, 1, 0, 0, 0,
		589, 587, 1, 0, 0, 0, 589, 590, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591,
		592, 3, 74, 37, 0, 592, 594, 1, 0, 0, 0, 593, 587, 1, 0, 0, 0, 594, 597,
		1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 601, 1, 0,
		0, 0, 597, 595, 1, 0, 0, 0, 598, 600, 3, 72, 36, 0, 599, 598, 1, 0, 0,
		0, 600, 603, 1, 0, 0, 0, 601, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602,
		71, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 604, 605, 3, 214, 107, 0, 605, 73,
		1, 0, 0, 0, 606, 607, 3, 58, 29, 0, 607, 608, 3, 104, 52, 0, 608, 75, 1,
		0, 0, 0, 609, 625, 3, 24, 12, 0, 610, 612, 3, 112, 56, 0, 611, 613, 5,
		51, 0, 0, 612, 611, 1, 0, 0, 0, 612, 613, 1, 0, 0, 0, 613, 625, 1, 0, 0,
		0, 614, 625, 3, 78, 39, 0, 615, 625, 3, 80, 40, 0, 616, 625, 3, 86, 43,
		0, 617, 625, 3, 88, 44, 0, 618, 625, 3, 100, 50, 0, 619, 625, 3, 104, 52,
		0, 620, 625, 3, 106, 53, 0, 621, 625, 3, 108, 54, 0, 622, 625, 3, 110,
		55, 0, 623, 625, 3, 82, 41, 0, 624, 609, 1, 0, 0, 0, 624, 610, 1, 0, 0,
		0, 624, 614, 1, 0, 0, 0, 624, 615, 1, 0, 0, 0, 624, 616, 1, 0, 0, 0, 624,
		617, 1, 0, 0, 0, 624, 618, 1, 0, 0, 0, 624, 619, 1, 0, 0, 0, 624, 620,
		1, 0, 0, 0, 624, 621, 1, 0, 0, 0, 624, 622, 1, 0, 0, 0, 624, 623, 1, 0,
		0, 0, 625, 77, 1, 0, 0, 0, 626, 628, 5, 7, 0, 0, 627, 629, 3, 84, 42, 0,
		628, 627, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 631, 1, 0, 0, 0, 630,
		632, 5, 51, 0, 0, 631, 630, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 79,
		1, 0, 0, 0, 633, 635, 5, 8, 0, 0, 634, 636, 3, 84, 42, 0, 635, 634, 1,
		0, 0, 0, 635, 636, 1, 0, 0, 0, 636, 638, 1, 0, 0, 0, 637, 639, 5, 51, 0,
		0, 638, 637, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 81, 1, 0, 0, 0, 640,
		641, 5, 38, 0, 0, 641, 643, 3, 112, 56, 0, 642, 644, 5, 51, 0, 0, 643,
		642, 1, 0, 0, 0, 643, 644, 1, 0, 0, 0, 644, 83, 1, 0, 0, 0, 645, 650, 3,
		112, 56, 0, 646, 647, 5, 52, 0, 0, 647, 649, 3, 112, 56, 0, 648, 646, 1,
		0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650, 651, 1, 0, 0,
		0, 651, 654, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 653, 655, 5, 52, 0, 0, 654,
		653, 1, 0, 0, 0, 654, 655, 1, 0, 0, 0, 655, 85, 1, 0, 0, 0, 656, 657, 5,
		24, 0, 0, 657, 658, 3, 112, 56, 0, 658, 661, 3, 104, 52, 0, 659, 660, 5,
		25, 0, 0, 660, 662, 3, 104, 52, 0, 661, 659, 1, 0, 0, 0, 661, 662, 1, 0,
		0, 0, 662, 87, 1, 0, 0, 0, 663, 664, 5, 26, 0, 0, 664, 665, 3, 90, 45,
		0, 665, 89, 1, 0, 0, 0, 666, 677, 3, 92, 46, 0, 667, 670, 5, 84, 0, 0,
		668, 669, 5, 52, 0, 0, 669, 671, 5, 84, 0, 0, 670, 668, 1, 0, 0, 0, 670,
		671, 1, 0, 0, 0, 671, 672, 1, 0, 0, 0, 672, 673, 5, 18, 0, 0, 673, 674,
		3, 112, 56, 0, 674, 675, 3, 102, 51, 0, 675, 677, 1, 0, 0, 0, 676, 666,
		1, 0, 0, 0, 676, 667, 1, 0, 0, 0, 677, 91, 1, 0, 0, 0, 678, 679, 3, 94,
		47, 0, 679, 680, 5, 51, 0, 0, 680, 681, 3, 96, 48, 0, 681, 682, 5, 51,
		0, 0, 682, 683, 3, 98, 49, 0, 683, 684, 3, 102, 51, 0, 684, 93, 1, 0, 0,
		0, 685, 688, 3, 26, 13, 0, 686, 688, 1, 0, 0, 0, 687, 685, 1, 0, 0, 0,
		687, 686, 1, 0, 0, 0, 688, 95, 1, 0, 0, 0, 689, 692, 3, 112, 56, 0, 690,
		692, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 691, 690, 1, 0, 0, 0, 692, 97, 1,
		0, 0, 0, 693, 696, 3, 112, 56, 0, 694, 696, 1, 0, 0, 0, 695, 693, 1, 0,
		0, 0, 695, 694, 1, 0, 0, 0, 696, 99, 1, 0, 0, 0, 697, 698, 5, 27, 0, 0,
		698, 699, 3, 112, 56, 0, 699, 700, 3, 102, 51, 0, 700, 101, 1, 0, 0, 0,
		701, 711, 5, 40, 0, 0, 702, 704, 3, 214, 107, 0, 703, 702, 1, 0, 0, 0,
		704, 707, 1, 0, 0, 0, 705, 703, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706,
		708, 1, 0, 0, 0, 707, 705, 1, 0, 0, 0, 708, 710, 3, 76, 38, 0, 709, 705,
		1, 0, 0, 0, 710, 713, 1, 0, 0, 0, 711, 709, 1, 0, 0, 0, 711, 712, 1, 0,
		0, 0, 712, 717, 1, 0, 0, 0, 713, 711, 1, 0, 0, 0, 714, 716, 3, 214, 107,
		0, 715, 714, 1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717,
		718, 1, 0, 0, 0, 718, 720, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 720, 721,
		5, 41, 0, 0, 721, 103, 1, 0, 0, 0, 722, 732, 5, 40, 0, 0, 723, 725, 3,
		214, 107, 0, 724, 723, 1, 0, 0, 0, 725, 728, 1, 0, 0, 0, 726, 724, 1, 0,
		0, 0, 726, 727, 1, 0, 0, 0, 727, 729, 1, 0, 0, 0, 728, 726, 1, 0, 0, 0,
		729, 731, 3, 76, 38, 0, 730, 726, 1, 0, 0, 0, 731, 734, 1, 0, 0, 0, 732,
		730, 1, 0, 0, 0, 732, 733, 1, 0, 0, 0, 733, 738, 1, 0, 0, 0, 734, 732,
		1, 0, 0, 0, 735, 737, 3, 214, 107, 0, 736, 735, 1, 0, 0, 0, 737, 740, 1,
		0, 0, 0, 738, 736, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 741, 1, 0, 0,
		0, 740, 738, 1, 0, 0, 0, 741, 742, 5, 41, 0, 0, 742, 105, 1, 0, 0, 0, 743,
		745, 5, 35, 0, 0, 744, 746, 5, 51, 0, 0, 745, 744, 1, 0, 0, 0, 745, 746,
		1, 0, 0, 0, 746, 107, 1, 0, 0, 0, 747, 749, 5, 36, 0, 0, 748, 750, 5, 51,
		0, 0, 749, 748, 1, 0, 0, 0, 749, 750, 1, 0, 0, 0, 750, 109, 1, 0, 0, 0,
		751, 752, 5, 15, 0, 0, 752, 753, 3, 112, 56, 0, 753, 754, 5, 52, 0, 0,
		754, 756, 3, 174, 87, 0, 755, 757, 5, 51, 0, 0, 756, 755, 1, 0, 0, 0, 756,
		757, 1, 0, 0, 0, 757, 111, 1, 0, 0, 0, 758, 759, 3, 114, 57, 0, 759, 113,
		1, 0, 0, 0, 760, 766, 3, 118, 59, 0, 761, 762, 3, 118, 59, 0, 762, 763,
		3, 116, 58, 0, 763, 764, 3, 114, 57, 0, 764, 766, 1, 0, 0, 0, 765, 760,
		1, 0, 0, 0, 765, 761, 1, 0, 0, 0, 766, 115, 1, 0, 0, 0, 767, 775, 5, 53,
		0, 0, 768, 775, 5, 68, 0, 0, 769, 775, 5, 69, 0, 0, 770, 775, 5, 70, 0,
		0, 771, 775, 5, 71, 0, 0, 772, 775, 5, 72, 0, 0, 773, 775, 5, 73, 0, 0,
		774, 767, 1, 0, 0, 0, 774, 768, 1, 0, 0, 0, 774, 769, 1, 0, 0, 0, 774,
		770, 1, 0, 0, 0, 774, 771, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 774, 773,
		1, 0, 0, 0, 775, 117, 1, 0, 0, 0, 776, 784, 3, 120, 60, 0, 777, 778, 3,
		120, 60, 0, 778, 779, 5, 65, 0, 0, 779, 780, 3, 112, 56, 0, 780, 781, 5,
		50, 0, 0, 781, 782, 3, 118, 59, 0, 782, 784, 1, 0, 0, 0, 783, 776, 1, 0,
		0, 0, 783, 777, 1, 0, 0, 0, 784, 119, 1, 0, 0, 0, 785, 786, 6, 60, -1,
		0, 786, 787, 3, 122, 61, 0, 787, 793, 1, 0, 0, 0, 788, 789, 10, 1, 0, 0,
		789, 790, 5, 59, 0, 0, 790, 792, 3, 122, 61, 0, 791, 788, 1, 0, 0, 0, 792,
		795, 1, 0, 0, 0, 793, 791, 1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794, 121,
		1, 0, 0, 0, 795, 793, 1, 0, 0, 0, 796, 797, 6, 61, -1, 0, 797, 798, 3,
		124, 62, 0, 798, 804, 1, 0, 0, 0, 799, 800, 10, 1, 0, 0, 800, 801, 5, 60,
		0, 0, 801, 803, 3, 124, 62, 0, 802, 799, 1, 0, 0, 0, 803, 806, 1, 0, 0,
		0, 804, 802, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 123, 1, 0, 0, 0, 806,
		804, 1, 0, 0, 0, 807, 808, 6, 62, -1, 0, 808, 809, 3, 126, 63, 0, 809,
		815, 1, 0, 0, 0, 810, 811, 10, 1, 0, 0, 811, 812, 5, 74, 0, 0, 812, 814,
		3, 126, 63, 0, 813, 810, 1, 0, 0, 0, 814, 817, 1, 0, 0, 0, 815, 813, 1,
		0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 125, 1, 0, 0, 0, 817, 815, 1, 0, 0,
		0, 818, 819, 6, 63, -1, 0, 819, 820, 3, 128, 64, 0, 820, 826, 1, 0, 0,
		0, 821, 822, 10, 1, 0, 0, 822, 823, 5, 76, 0, 0, 823, 825, 3, 128, 64,
		0, 824, 821, 1, 0, 0, 0, 825, 828, 1, 0, 0, 0, 826, 824, 1, 0, 0, 0, 826,
		827, 1, 0, 0, 0, 827, 127, 1, 0, 0, 0, 828, 826, 1, 0, 0, 0, 829, 830,
		6, 64, -1, 0, 830, 831, 3, 130, 65, 0, 831, 837, 1, 0, 0, 0, 832, 833,
		10, 1, 0, 0, 833, 834, 5, 75, 0, 0, 834, 836, 3, 130, 65, 0, 835, 832,
		1, 0, 0, 0, 836, 839, 1, 0, 0, 0, 837, 835, 1, 0, 0, 0, 837, 838, 1, 0,
		0, 0, 838, 129, 1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 840, 841, 6, 65, -1,
		0, 841, 842, 3, 134, 67, 0, 842, 848, 1, 0, 0, 0, 843, 844, 10, 1, 0, 0,
		844, 845, 7, 0, 0, 0, 845, 847, 3, 134, 67, 0, 846, 843, 1, 0, 0, 0, 847,
		850, 1, 0, 0, 0, 848, 846, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 131,
		1, 0, 0, 0, 850, 848, 1, 0, 0, 0, 851, 852, 7, 1, 0, 0, 852, 133, 1, 0,
		0, 0, 853, 854, 6, 67, -1, 0, 854, 855, 3, 136, 68, 0, 855, 862, 1, 0,
		0, 0, 856, 857, 10, 1, 0, 0, 857, 858, 3, 132, 66, 0, 858, 859, 3, 136,
		68, 0, 859, 861, 1, 0, 0, 0, 860, 856, 1, 0, 0, 0, 861, 864, 1, 0, 0, 0,
		862, 860, 1, 0, 0, 0, 862, 863, 1, 0, 0, 0, 863, 135, 1, 0, 0, 0, 864,
		862, 1, 0, 0, 0, 865, 866, 6, 68, -1, 0, 866, 867, 3, 138, 69, 0, 867,
		873, 1, 0, 0, 0, 868, 869, 10, 1, 0, 0, 869, 870, 7, 2, 0, 0, 870, 872,
		3, 138, 69, 0, 871, 868, 1, 0, 0, 0, 872, 875, 1, 0, 0, 0, 873, 871, 1,
		0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 137, 1, 0, 0, 0, 875, 873, 1, 0, 0,
		0, 876, 877, 6, 69, -1, 0, 877, 878, 3, 140, 70, 0, 878, 884, 1, 0, 0,
		0, 879, 880, 10, 1, 0, 0, 880, 881, 7, 2, 0, 0, 881, 883, 3, 140, 70, 0,
		882, 879, 1, 0, 0, 0, 883, 886, 1, 0, 0, 0, 884, 882, 1, 0, 0, 0, 884,
		885, 1, 0, 0, 0, 885, 139, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 887, 888,
		6, 70, -1, 0, 888, 889, 3, 142, 71, 0, 889, 895, 1, 0, 0, 0, 890, 891,
		10, 1, 0, 0, 891, 892, 7, 3, 0, 0, 892, 894, 3, 142, 71, 0, 893, 890, 1,
		0, 0, 0, 894, 897, 1, 0, 0, 0, 895, 893, 1, 0, 0, 0, 895, 896, 1, 0, 0,
		0, 896, 141, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 898, 899, 7, 4, 0, 0, 899,
		902, 3, 142, 71, 0, 900, 902, 3, 144, 72, 0, 901, 898, 1, 0, 0, 0, 901,
		900, 1, 0, 0, 0, 902, 143, 1, 0, 0, 0, 903, 905, 5, 16, 0, 0, 904, 903,
		1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 908, 5, 33,
		0, 0, 907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 910, 1, 0, 0, 0,
		909, 911, 5, 32, 0, 0, 910, 909, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911,
		912, 1, 0, 0, 0, 912, 913, 3, 146, 73, 0, 913, 145, 1, 0, 0, 0, 914, 915,
		6, 73, -1, 0, 915, 916, 3, 150, 75, 0, 916, 921, 1, 0, 0, 0, 917, 918,
		10, 1, 0, 0, 918, 920, 3, 148, 74, 0, 919, 917, 1, 0, 0, 0, 920, 923, 1,
		0, 0, 0, 921, 919, 1, 0, 0, 0, 921, 922, 1, 0, 0, 0, 922, 147, 1, 0, 0,
		0, 923, 921, 1, 0, 0, 0, 924, 926, 5, 44, 0, 0, 925, 927, 3, 84, 42, 0,
		926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 928, 1, 0, 0, 0, 928,
		936, 5, 45, 0, 0, 929, 930, 5, 66, 0, 0, 930, 936, 5, 84, 0, 0, 931, 932,
		5, 42, 0, 0, 932, 933, 3, 112, 56, 0, 933, 934, 5, 43, 0, 0, 934, 936,
		1, 0, 0, 0, 935, 924, 1, 0, 0, 0, 935, 929, 1, 0, 0, 0, 935, 931, 1, 0,
		0, 0, 936, 149, 1, 0, 0, 0, 937, 954, 3, 172, 86, 0, 938, 954, 5, 84, 0,
		0, 939, 940, 5, 44, 0, 0, 940, 941, 3, 112, 56, 0, 941, 942, 5, 45, 0,
		0, 942, 954, 1, 0, 0, 0, 943, 954, 3, 180, 90, 0, 944, 954, 3, 182, 91,
		0, 945, 954, 3, 190, 95, 0, 946, 954, 3, 196, 98, 0, 947, 954, 3, 152,
		76, 0, 948, 954, 3, 154, 77, 0, 949, 954, 5, 14, 0, 0, 950, 954, 5, 23,
		0, 0, 951, 954, 3, 198, 99, 0, 952, 954, 3, 200, 100, 0, 953, 937, 1, 0,
		0, 0, 953, 938, 1, 0, 0, 0, 953, 939, 1, 0, 0, 0, 953, 943, 1, 0, 0, 0,
		953, 944, 1, 0, 0, 0, 953, 945, 1, 0, 0, 0, 953, 946, 1, 0, 0, 0, 953,
		947, 1, 0, 0, 0, 953, 948, 1, 0, 0, 0, 953, 949, 1, 0, 0, 0, 953, 950,
		1, 0, 0, 0, 953, 951, 1, 0, 0, 0, 953, 952, 1, 0, 0, 0, 954, 151, 1, 0,
		0, 0, 955, 956, 5, 6, 0, 0, 956, 958, 5, 44, 0, 0, 957, 959, 3, 64, 32,
		0, 958, 957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960,
		962, 5, 45, 0, 0, 961, 963, 3, 206, 103, 0, 962, 961, 1, 0, 0, 0, 962,
		963, 1, 0, 0, 0, 963, 964, 1, 0, 0, 0, 964, 965, 3, 104, 52, 0, 965, 153,
		1, 0, 0, 0, 966, 967, 5, 30, 0, 0, 967, 968, 3, 112, 56, 0, 968, 972, 5,
		40, 0, 0, 969, 971, 3, 214, 107, 0, 970, 969, 1, 0, 0, 0, 971, 974, 1,
		0, 0, 0, 972, 970, 1, 0, 0, 0, 972, 973, 1, 0, 0, 0, 973, 975, 1, 0, 0,
		0, 974, 972, 1, 0, 0, 0, 975, 985, 3, 156, 78, 0, 976, 978, 3, 214, 107,
		0, 977, 976, 1, 0, 0, 0, 978, 979, 1, 0, 0, 0, 979, 977, 1, 0, 0, 0, 979,
		980, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 982, 3, 156, 78, 0, 982, 984,
		1, 0, 0, 0, 983, 977, 1, 0, 0, 0, 984, 987, 1, 0, 0, 0, 985, 983, 1, 0,
		0, 0, 985, 986, 1, 0, 0, 0, 986, 991, 1, 0, 0, 0, 987, 985, 1, 0, 0, 0,
		988, 990, 3, 214, 107, 0, 989, 988, 1, 0, 0, 0, 990, 993, 1, 0, 0, 0, 991,
		989, 1, 0, 0, 0, 991, 992, 1, 0, 0, 0, 992, 995, 1, 0, 0, 0, 993, 991,
		1, 0, 0, 0, 994, 996, 3, 158, 79, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1,
		0, 0, 0, 996, 997, 1, 0, 0, 0, 997, 998, 5, 41, 0, 0, 998, 155, 1, 0, 0,
		0, 999, 1003, 3, 112, 56, 0, 1000, 1001, 5, 50, 0, 0, 1001, 1004, 3, 112,
		56, 0, 1002, 1004, 3, 104, 52, 0, 1003, 1000, 1, 0, 0, 0, 1003, 1002, 1,
		0, 0, 0, 1004, 1006, 1, 0, 0, 0, 1005, 1007, 5, 51, 0, 0, 1006, 1005, 1,
		0, 0, 0, 1006, 1007, 1, 0, 0, 0, 1007, 157, 1, 0, 0, 0, 1008, 1012, 5,
		37, 0, 0, 1009, 1010, 5, 50, 0, 0, 1010, 1013, 3, 112, 56, 0, 1011, 1013,
		3, 104, 52, 0, 1012, 1009, 1, 0, 0, 0, 1012, 1011, 1, 0, 0, 0, 1013, 1015,
		1, 0, 0, 0, 1014, 1016, 5, 51, 0, 0, 1015, 1014, 1, 0, 0, 0, 1015, 1016,
		1, 0, 0, 0, 1016, 159, 1, 0, 0, 0, 1017, 1021, 5, 85, 0, 0, 1018, 1020,
		3, 168, 84, 0, 1019, 1018, 1, 0, 0, 0, 1020, 1023, 1, 0, 0, 0, 1021, 1019,
		1, 0, 0, 0, 1021, 1022, 1, 0, 0, 0, 1022, 1024, 1, 0, 0, 0, 1023, 1021,
		1, 0, 0, 0, 1024, 1025, 5, 91, 0, 0, 1025, 161, 1, 0, 0, 0, 1026, 1030,
		5, 86, 0, 0, 1027, 1029, 3, 168, 84, 0, 1028, 1027, 1, 0, 0, 0, 1029, 1032,
		1, 0, 0, 0, 1030, 1028, 1, 0, 0, 0, 1030, 1031, 1, 0, 0, 0, 1031, 1033,
		1, 0, 0, 0, 1032, 1030, 1, 0, 0, 0, 1033, 1034, 5, 94, 0, 0, 1034, 163,
		1, 0, 0, 0, 1035, 1039, 5, 87, 0, 0, 1036, 1038, 3, 168, 84, 0, 1037, 1036,
		1, 0, 0, 0, 1038, 1041, 1, 0, 0, 0, 1039, 1037, 1, 0, 0, 0, 1039, 1040,
		1, 0, 0, 0, 1040, 1042, 1, 0, 0, 0, 1041, 1039, 1, 0, 0, 0, 1042, 1043,
		5, 97, 0, 0, 1043, 165, 1, 0, 0, 0, 1044, 1048, 5, 88, 0, 0, 1045, 1047,
		3, 168, 84, 0, 1046, 1045, 1, 0, 0, 0, 1047, 1050, 1, 0, 0, 0, 1048, 1046,
		1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 1051, 1, 0, 0, 0, 1050, 1048,
		1, 0, 0, 0, 1051, 1052, 5, 100, 0, 0, 1052, 167, 1, 0, 0, 0, 1053, 1059,
		5, 90, 0, 0, 1054, 1059, 5, 93, 0, 0, 1055, 1059, 5, 96, 0, 0, 1056, 1059,
		5, 99, 0, 0, 1057, 1059, 3, 170, 85, 0, 1058, 1053, 1, 0, 0, 0, 1058, 1054,
		1, 0, 0, 0, 1058, 1055, 1, 0, 0, 0, 1058, 1056, 1, 0, 0, 0, 1058, 1057,
		1, 0, 0, 0, 1059, 169, 1, 0, 0, 0, 1060, 1061, 7, 5, 0, 0, 1061, 1062,
		3, 112, 56, 0, 1062, 1063, 5, 102, 0, 0, 1063, 171, 1, 0, 0, 0, 1064, 1070,
		3, 174, 87, 0, 1065, 1070, 3, 176, 88, 0, 1066, 1070, 3, 178, 89, 0, 1067,
		1070, 5, 23, 0, 0, 1068, 1070, 5, 14, 0, 0, 1069, 1064, 1, 0, 0, 0, 1069,
		1065, 1, 0, 0, 0, 1069, 1066, 1, 0, 0, 0, 1069, 1067, 1, 0, 0, 0, 1069,
		1068, 1, 0, 0, 0, 1070, 173, 1, 0, 0, 0, 1071, 1076, 3, 160, 80, 0, 1072,
		1076, 3, 162, 81, 0, 1073, 1076, 3, 164, 82, 0, 1074, 1076, 3, 166, 83,
		0, 1075, 1071, 1, 0, 0, 0, 1075, 1072, 1, 0, 0, 0, 1075, 1073, 1, 0, 0,
		0, 1075, 1074, 1, 0, 0, 0, 1076, 175, 1, 0, 0, 0, 1077, 1083, 5, 83, 0,
		0, 1078, 1083, 5, 82, 0, 0, 1079, 1083, 5, 79, 0, 0, 1080, 1083, 5, 80,
		0, 0, 1081, 1083, 5, 81, 0, 0, 1082, 1077, 1, 0, 0, 0, 1082, 1078, 1, 0,
		0, 0, 1082, 1079, 1, 0, 0, 0, 1082, 1080, 1, 0, 0, 0, 1082, 1081, 1, 0,
		0, 0, 1083, 177, 1, 0, 0, 0, 1084, 1087, 5, 28, 0, 0, 1085, 1087, 5, 29,
		0, 0, 1086, 1084, 1, 0, 0, 0, 1086, 1085, 1, 0, 0, 0, 1087, 179, 1, 0,
		0, 0, 1088, 1090, 5, 42, 0, 0, 1089, 1091, 3, 84, 42, 0, 1090, 1089, 1,
		0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1093, 5,
		43, 0, 0, 1093, 181, 1, 0, 0, 0, 1094, 1096, 5, 40, 0, 0, 1095, 1097, 3,
		184, 92, 0, 1096, 1095, 1, 0, 0, 0, 1096, 1097, 1, 0, 0, 0, 1097, 1098,
		1, 0, 0, 0, 1098, 1099, 5, 41, 0, 0, 1099, 183, 1, 0, 0, 0, 1100, 1105,
		3, 186, 93, 0, 1101, 1102, 5, 52, 0, 0, 1102, 1104, 3, 186, 93, 0, 1103,
		1101, 1, 0, 0, 0, 1104, 1107, 1, 0, 0, 0, 1105, 1103, 1, 0, 0, 0, 1105,
		1106, 1, 0, 0, 0, 1106, 1109, 1, 0, 0, 0, 1107, 1105, 1, 0, 0, 0, 1108,
		1110, 5, 52, 0, 0, 1109, 1108, 1, 0, 0, 0, 1109, 1110, 1, 0, 0, 0, 1110,
		185, 1, 0, 0, 0, 1111, 1114, 3, 188, 94, 0, 1112, 1113, 5, 50, 0, 0, 1113,
		1115, 3, 112, 56, 0, 1114, 1112, 1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115,
		187, 1, 0, 0, 0, 1116, 1119, 5, 84, 0, 0, 1117, 1119, 3, 174, 87, 0, 1118,
		1116, 1, 0, 0, 0, 1118, 1117, 1, 0, 0, 0, 1119, 189, 1, 0, 0, 0, 1120,
		1121, 5, 42, 0, 0, 1121, 1122, 5, 50, 0, 0, 1122, 1129, 5, 43, 0, 0, 1123,
		1125, 5, 42, 0, 0, 1124, 1126, 3, 192, 96, 0, 1125, 1124, 1, 0, 0, 0, 1125,
		1126, 1, 0, 0, 0, 1126, 1127, 1, 0, 0, 0, 1127, 1129, 5, 43, 0, 0, 1128,
		1120, 1, 0, 0, 0, 1128, 1123, 1, 0, 0, 0, 1129, 191, 1, 0, 0, 0, 1130,
		1135, 3, 194, 97, 0, 1131, 1132, 5, 52, 0, 0, 1132, 1134, 3, 194, 97, 0,
		1133, 1131, 1, 0, 0, 0, 1134, 1137, 1, 0, 0, 0, 1135, 1133, 1, 0, 0, 0,
		1135, 1136, 1, 0, 0, 0, 1136, 1139, 1, 0, 0, 0, 1137, 1135, 1, 0, 0, 0,
		1138, 1140, 5, 52, 0, 0, 1139, 1138, 1, 0, 0, 0, 1139, 1140, 1, 0, 0, 0,
		1140, 193, 1, 0, 0, 0, 1141, 1142, 3, 112, 56, 0, 1142, 1143, 5, 50, 0,
		0, 1143, 1144, 3, 112, 56, 0, 1144, 195, 1, 0, 0, 0, 1145, 1157, 5, 46,
		0, 0, 1146, 1151, 3, 112, 56, 0, 1147, 1148, 5, 52, 0, 0, 1148, 1150, 3,
		112, 56, 0, 1149, 1147, 1, 0, 0, 0, 1150, 1153, 1, 0, 0, 0, 1151, 1149,
		1, 0, 0, 0, 1151, 1152, 1, 0, 0, 0, 1152, 1155, 1, 0, 0, 0, 1153, 1151,
		1, 0, 0, 0, 1154, 1156, 5, 52, 0, 0, 1155, 1154, 1, 0, 0, 0, 1155, 1156,
		1, 0, 0, 0, 1156, 1158, 1, 0, 0, 0, 1157, 1146, 1, 0, 0, 0, 1157, 1158,
		1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1160, 5, 47, 0, 0, 1160, 197,
		1, 0, 0, 0, 1161, 1164, 5, 84, 0, 0, 1162, 1165, 3, 162, 81, 0, 1163, 1165,
		3, 166, 83, 0, 1164, 1162, 1, 0, 0, 0, 1164, 1163, 1, 0, 0, 0, 1165, 199,
		1, 0, 0, 0, 1166, 1167, 5, 84, 0, 0, 1167, 1169, 5, 44, 0, 0, 1168, 1170,
		3, 202, 101, 0, 1169, 1168, 1, 0, 0, 0, 1169, 1170, 1, 0, 0, 0, 1170, 1171,
		1, 0, 0, 0, 1171, 1172, 5, 45, 0, 0, 1172, 201, 1, 0, 0, 0, 1173, 1178,
		3, 204, 102, 0, 1174, 1175, 5, 52, 0, 0, 1175, 1177, 3, 204, 102, 0, 1176,
		1174, 1, 0, 0, 0, 1177, 1180, 1, 0, 0, 0, 1178, 1176, 1, 0, 0, 0, 1178,
		1179, 1, 0, 0, 0, 1179, 1182, 1, 0, 0, 0, 1180, 1178, 1, 0, 0, 0, 1181,
		1183, 5, 52, 0, 0, 1182, 1181, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183,
		203, 1, 0, 0, 0, 1184, 1185, 5, 84, 0, 0, 1185, 1186, 5, 50, 0, 0, 1186,
		1187, 3, 112, 56, 0, 1187, 205, 1, 0, 0, 0, 1188, 1194, 5, 84, 0, 0, 1189,
		1194, 3, 210, 105, 0, 1190, 1194, 3, 208, 104, 0, 1191, 1194, 3, 212, 106,
		0, 1192, 1194, 5, 14, 0, 0, 1193, 1188, 1, 0, 0, 0, 1193, 1189, 1, 0, 0,
		0, 1193, 1190, 1, 0, 0, 0, 1193, 1191, 1, 0, 0, 0, 1193, 1192, 1, 0, 0,
		0, 1194, 207, 1, 0, 0, 0, 1195, 1197, 5, 44, 0, 0, 1196, 1198, 3, 54, 27,
		0, 1197, 1196, 1, 0, 0, 0, 1197, 1198, 1, 0, 0, 0, 1198, 1199, 1, 0, 0,
		0, 1199, 1200, 5, 45, 0, 0, 1200, 209, 1, 0, 0, 0, 1201, 1202, 5, 84, 0,
		0, 1202, 1203, 5, 42, 0, 0, 1203, 1204, 5, 43, 0, 0, 1204, 211, 1, 0, 0,
		0, 1205, 1206, 5, 6, 0, 0, 1206, 1208, 5, 44, 0, 0, 1207, 1209, 3, 64,
		32, 0, 1208, 1207, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209, 1210, 1, 0,
		0, 0, 1210, 1212, 5, 45, 0, 0, 1211, 1213, 3, 206, 103, 0, 1212, 1211,
		1, 0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 213, 1, 0, 0, 0, 1214, 1215,
		7, 6, 0, 0, 1215, 215, 1, 0, 0, 0, 149, 219, 225, 231, 244, 249, 254, 259,
		265, 269, 273, 288, 292, 297, 304, 309, 314, 319, 321, 326, 330, 337, 344,
		350, 356, 361, 379, 398, 402, 406, 412, 416, 422, 429, 436, 442, 448, 452,
		457, 460, 468, 475, 479, 483, 492, 496, 502, 508, 515, 520, 527, 531, 534,
		543, 547, 550, 557, 561, 567, 575, 582, 589, 595, 601, 612, 624, 628, 631,
		635, 638, 643, 650, 654, 661, 670, 676, 687, 691, 695, 705, 711, 717, 726,
		732, 738, 745, 749, 756, 765, 774, 783, 793, 804, 815, 826, 837, 848, 862,
		873, 884, 895, 901, 904, 907, 910, 921, 926, 935, 953, 958, 962, 972, 979,
		985, 991, 995, 1003, 1006, 1012, 1015, 1021, 1030, 1039, 1048, 1058, 1069,
		1075, 1082, 1086, 1090, 1096, 1105, 1109, 1114, 1118, 1125, 1128, 1135,
		1139, 1151, 1155, 1157, 1164, 1169, 1178, 1182, 1193, 1197, 1208, 1212,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ManuscriptInit initializes any static state used to implement Manuscript. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewManuscript(). You can call this function if you wish to initialize the static state ahead
// of time.
func ManuscriptInit() {
	staticData := &ManuscriptParserStaticData
	staticData.once.Do(manuscriptParserInit)
}

// NewManuscript produces a new parser instance for the optional input antlr.TokenStream.
func NewManuscript(input antlr.TokenStream) *Manuscript {
	ManuscriptInit()
	this := new(Manuscript)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &ManuscriptParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Manuscript.g4"

	return this
}

// Manuscript tokens.
const (
	ManuscriptEOF                           = antlr.TokenEOF
	ManuscriptNEWLINE                       = 1
	ManuscriptWS                            = 2
	ManuscriptCOMMENT                       = 3
	ManuscriptMULTI_LINE_COMMENT            = 4
	ManuscriptLET                           = 5
	ManuscriptFN                            = 6
	ManuscriptRETURN                        = 7
	ManuscriptYIELD                         = 8
	ManuscriptTYPE                          = 9
	ManuscriptINTERFACE                     = 10
	ManuscriptIMPORT                        = 11
	ManuscriptEXPORT                        = 12
	ManuscriptEXTERN                        = 13
	ManuscriptVOID                          = 14
	ManuscriptCHECK                         = 15
	ManuscriptTRY                           = 16
	ManuscriptCATCH                         = 17
	ManuscriptIN                            = 18
	ManuscriptAS                            = 19
	ManuscriptIS                            = 20
	ManuscriptEXTENDS                       = 21
	ManuscriptFROM                          = 22
	ManuscriptNULL                          = 23
	ManuscriptIF                            = 24
	ManuscriptELSE                          = 25
	ManuscriptFOR                           = 26
	ManuscriptWHILE                         = 27
	ManuscriptTRUE                          = 28
	ManuscriptFALSE                         = 29
	ManuscriptMATCH                         = 30
	ManuscriptCASE                          = 31
	ManuscriptASYNC                         = 32
	ManuscriptAWAIT                         = 33
	ManuscriptMETHODS                       = 34
	ManuscriptBREAK                         = 35
	ManuscriptCONTINUE                      = 36
	ManuscriptDEFAULT                       = 37
	ManuscriptDEFER                         = 38
	ManuscriptGO                            = 39
	ManuscriptLBRACE                        = 40
	ManuscriptRBRACE                        = 41
	ManuscriptLSQBR                         = 42
	ManuscriptRSQBR                         = 43
	ManuscriptLPAREN                        = 44
	ManuscriptRPAREN                        = 45
	ManuscriptLT                            = 46
	ManuscriptGT                            = 47
	ManuscriptLT_EQUALS                     = 48
	ManuscriptGT_EQUALS                     = 49
	ManuscriptCOLON                         = 50
	ManuscriptSEMICOLON                     = 51
	ManuscriptCOMMA                         = 52
	ManuscriptEQUALS                        = 53
	ManuscriptEQUALS_EQUALS                 = 54
	ManuscriptPLUS                          = 55
	ManuscriptMINUS                         = 56
	ManuscriptPLUS_PLUS                     = 57
	ManuscriptMINUS_MINUS                   = 58
	ManuscriptPIPE_PIPE                     = 59
	ManuscriptAMP_AMP                       = 60
	ManuscriptSTAR                          = 61
	ManuscriptSLASH                         = 62
	ManuscriptMOD                           = 63
	ManuscriptEXCLAMATION                   = 64
	ManuscriptQUESTION                      = 65
	ManuscriptDOT                           = 66
	ManuscriptNEQ                           = 67
	ManuscriptPLUS_EQUALS                   = 68
	ManuscriptMINUS_EQUALS                  = 69
	ManuscriptSTAR_EQUALS                   = 70
	ManuscriptSLASH_EQUALS                  = 71
	ManuscriptMOD_EQUALS                    = 72
	ManuscriptCARET_EQUALS                  = 73
	ManuscriptPIPE                          = 74
	ManuscriptAMP                           = 75
	ManuscriptCARET                         = 76
	ManuscriptLSHIFT                        = 77
	ManuscriptRSHIFT                        = 78
	ManuscriptHEX_LITERAL                   = 79
	ManuscriptBINARY_LITERAL                = 80
	ManuscriptOCTAL_LITERAL                 = 81
	ManuscriptFLOAT                         = 82
	ManuscriptINTEGER                       = 83
	ManuscriptID                            = 84
	ManuscriptSINGLE_QUOTE_START            = 85
	ManuscriptMULTI_QUOTE_START             = 86
	ManuscriptDOUBLE_QUOTE_START            = 87
	ManuscriptMULTI_DOUBLE_QUOTE_START      = 88
	ManuscriptSINGLE_STR_INTERP_START       = 89
	ManuscriptSINGLE_STR_CONTENT            = 90
	ManuscriptSINGLE_STR_END                = 91
	ManuscriptMULTI_STR_INTERP_START        = 92
	ManuscriptMULTI_STR_CONTENT             = 93
	ManuscriptMULTI_STR_END                 = 94
	ManuscriptDOUBLE_STR_INTERP_START       = 95
	ManuscriptDOUBLE_STR_CONTENT            = 96
	ManuscriptDOUBLE_STR_END                = 97
	ManuscriptMULTI_DOUBLE_STR_INTERP_START = 98
	ManuscriptMULTI_DOUBLE_STR_CONTENT      = 99
	ManuscriptMULTI_DOUBLE_STR_END          = 100
	ManuscriptINTERP_LBRACE                 = 101
	ManuscriptINTERP_RBRACE                 = 102
	ManuscriptINTERP_WS                     = 103
)

// Manuscript rules.
const (
	ManuscriptRULE_program                 = 0
	ManuscriptRULE_declaration             = 1
	ManuscriptRULE_importDecl              = 2
	ManuscriptRULE_exportDecl              = 3
	ManuscriptRULE_externDecl              = 4
	ManuscriptRULE_exportedItem            = 5
	ManuscriptRULE_moduleImport            = 6
	ManuscriptRULE_destructuredImport      = 7
	ManuscriptRULE_targetImport            = 8
	ManuscriptRULE_importItemList          = 9
	ManuscriptRULE_importItem              = 10
	ManuscriptRULE_importStr               = 11
	ManuscriptRULE_letDecl                 = 12
	ManuscriptRULE_letSingle               = 13
	ManuscriptRULE_letBlock                = 14
	ManuscriptRULE_letBlockItemList        = 15
	ManuscriptRULE_letBlockItemSep         = 16
	ManuscriptRULE_letBlockItem            = 17
	ManuscriptRULE_letDestructuredObj      = 18
	ManuscriptRULE_letDestructuredArray    = 19
	ManuscriptRULE_typedIDList             = 20
	ManuscriptRULE_typedID                 = 21
	ManuscriptRULE_typeDecl                = 22
	ManuscriptRULE_typeDefBody             = 23
	ManuscriptRULE_typeAlias               = 24
	ManuscriptRULE_fieldList               = 25
	ManuscriptRULE_fieldDecl               = 26
	ManuscriptRULE_typeList                = 27
	ManuscriptRULE_interfaceDecl           = 28
	ManuscriptRULE_interfaceMethod         = 29
	ManuscriptRULE_fnDecl                  = 30
	ManuscriptRULE_fnSignature             = 31
	ManuscriptRULE_parameters              = 32
	ManuscriptRULE_param                   = 33
	ManuscriptRULE_methodsDecl             = 34
	ManuscriptRULE_methodImplList          = 35
	ManuscriptRULE_methodImplSep           = 36
	ManuscriptRULE_methodImpl              = 37
	ManuscriptRULE_stmt                    = 38
	ManuscriptRULE_returnStmt              = 39
	ManuscriptRULE_yieldStmt               = 40
	ManuscriptRULE_deferStmt               = 41
	ManuscriptRULE_exprList                = 42
	ManuscriptRULE_ifStmt                  = 43
	ManuscriptRULE_forStmt                 = 44
	ManuscriptRULE_forLoopType             = 45
	ManuscriptRULE_forTrinity              = 46
	ManuscriptRULE_forInit                 = 47
	ManuscriptRULE_forCond                 = 48
	ManuscriptRULE_forPost                 = 49
	ManuscriptRULE_whileStmt               = 50
	ManuscriptRULE_loopBody                = 51
	ManuscriptRULE_codeBlock               = 52
	ManuscriptRULE_breakStmt               = 53
	ManuscriptRULE_continueStmt            = 54
	ManuscriptRULE_checkStmt               = 55
	ManuscriptRULE_expr                    = 56
	ManuscriptRULE_assignmentExpr          = 57
	ManuscriptRULE_assignmentOp            = 58
	ManuscriptRULE_ternaryExpr             = 59
	ManuscriptRULE_logicalOrExpr           = 60
	ManuscriptRULE_logicalAndExpr          = 61
	ManuscriptRULE_bitwiseOrExpr           = 62
	ManuscriptRULE_bitwiseXorExpr          = 63
	ManuscriptRULE_bitwiseAndExpr          = 64
	ManuscriptRULE_equalityExpr            = 65
	ManuscriptRULE_comparisonOp            = 66
	ManuscriptRULE_comparisonExpr          = 67
	ManuscriptRULE_shiftExpr               = 68
	ManuscriptRULE_additiveExpr            = 69
	ManuscriptRULE_multiplicativeExpr      = 70
	ManuscriptRULE_unaryExpr               = 71
	ManuscriptRULE_awaitExpr               = 72
	ManuscriptRULE_postfixExpr             = 73
	ManuscriptRULE_postfixOp               = 74
	ManuscriptRULE_primaryExpr             = 75
	ManuscriptRULE_fnExpr                  = 76
	ManuscriptRULE_matchExpr               = 77
	ManuscriptRULE_caseClause              = 78
	ManuscriptRULE_defaultClause           = 79
	ManuscriptRULE_singleQuotedString      = 80
	ManuscriptRULE_multiQuotedString       = 81
	ManuscriptRULE_doubleQuotedString      = 82
	ManuscriptRULE_multiDoubleQuotedString = 83
	ManuscriptRULE_stringPart              = 84
	ManuscriptRULE_interpolation           = 85
	ManuscriptRULE_literal                 = 86
	ManuscriptRULE_stringLiteral           = 87
	ManuscriptRULE_numberLiteral           = 88
	ManuscriptRULE_booleanLiteral          = 89
	ManuscriptRULE_arrayLiteral            = 90
	ManuscriptRULE_objectLiteral           = 91
	ManuscriptRULE_objectFieldList         = 92
	ManuscriptRULE_objectField             = 93
	ManuscriptRULE_objectFieldName         = 94
	ManuscriptRULE_mapLiteral              = 95
	ManuscriptRULE_mapFieldList            = 96
	ManuscriptRULE_mapField                = 97
	ManuscriptRULE_setLiteral              = 98
	ManuscriptRULE_taggedBlockString       = 99
	ManuscriptRULE_structInitExpr          = 100
	ManuscriptRULE_structFieldList         = 101
	ManuscriptRULE_structField             = 102
	ManuscriptRULE_typeAnnotation          = 103
	ManuscriptRULE_tupleType               = 104
	ManuscriptRULE_arrayType               = 105
	ManuscriptRULE_fnType                  = 106
	ManuscriptRULE_stmt_sep                = 107
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(ManuscriptEOF, 0)
}

func (s *ProgramContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ProgramContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ManuscriptRULE_program)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(216)
					p.Stmt_sep()
				}

				p.SetState(221)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(222)
				p.Declaration()
			}

		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(231)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(228)
			p.Stmt_sep()
		}

		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(234)
		p.Match(ManuscriptEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) CopyAll(ctx *DeclarationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DeclImportContext struct {
	DeclarationContext
}

func NewDeclImportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclImportContext {
	var p = new(DeclImportContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclImportContext) ImportDecl() IImportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportDeclContext)
}

func (s *DeclImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclImport(s)
	}
}

func (s *DeclImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclImport(s)
	}
}

func (s *DeclImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclImport(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclMethodsContext struct {
	DeclarationContext
}

func NewDeclMethodsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclMethodsContext {
	var p = new(DeclMethodsContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclMethodsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclMethodsContext) MethodsDecl() IMethodsDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodsDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodsDeclContext)
}

func (s *DeclMethodsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclMethods(s)
	}
}

func (s *DeclMethodsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclMethods(s)
	}
}

func (s *DeclMethodsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclMethods(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclFnContext struct {
	DeclarationContext
}

func NewDeclFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclFnContext {
	var p = new(DeclFnContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclFnContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *DeclFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclFn(s)
	}
}

func (s *DeclFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclFn(s)
	}
}

func (s *DeclFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclLetContext struct {
	DeclarationContext
}

func NewDeclLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclLetContext {
	var p = new(DeclLetContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *DeclLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclLet(s)
	}
}

func (s *DeclLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclLet(s)
	}
}

func (s *DeclLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclInterfaceContext struct {
	DeclarationContext
}

func NewDeclInterfaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclInterfaceContext {
	var p = new(DeclInterfaceContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclInterfaceContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *DeclInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclInterface(s)
	}
}

func (s *DeclInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclInterface(s)
	}
}

func (s *DeclInterfaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclInterface(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclTypeContext struct {
	DeclarationContext
}

func NewDeclTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclTypeContext {
	var p = new(DeclTypeContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *DeclTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclType(s)
	}
}

func (s *DeclTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclType(s)
	}
}

func (s *DeclTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclType(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclExportContext struct {
	DeclarationContext
}

func NewDeclExportContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclExportContext {
	var p = new(DeclExportContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclExportContext) ExportDecl() IExportDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportDeclContext)
}

func (s *DeclExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclExport(s)
	}
}

func (s *DeclExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclExport(s)
	}
}

func (s *DeclExportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclExport(s)

	default:
		return t.VisitChildren(s)
	}
}

type DeclExternContext struct {
	DeclarationContext
}

func NewDeclExternContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DeclExternContext {
	var p = new(DeclExternContext)

	InitEmptyDeclarationContext(&p.DeclarationContext)
	p.parser = parser
	p.CopyAll(ctx.(*DeclarationContext))

	return p
}

func (s *DeclExternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclExternContext) ExternDecl() IExternDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternDeclContext)
}

func (s *DeclExternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeclExtern(s)
	}
}

func (s *DeclExternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeclExtern(s)
	}
}

func (s *DeclExternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeclExtern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ManuscriptRULE_declaration)
	p.SetState(244)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptIMPORT:
		localctx = NewDeclImportContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(236)
			p.ImportDecl()
		}

	case ManuscriptEXPORT:
		localctx = NewDeclExportContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(237)
			p.ExportDecl()
		}

	case ManuscriptEXTERN:
		localctx = NewDeclExternContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(238)
			p.ExternDecl()
		}

	case ManuscriptLET:
		localctx = NewDeclLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(239)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		localctx = NewDeclTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(240)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		localctx = NewDeclInterfaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(241)
			p.InterfaceDecl()
		}

	case ManuscriptFN:
		localctx = NewDeclFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(242)
			p.FnDecl()
		}

	case ManuscriptMETHODS:
		localctx = NewDeclMethodsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(243)
			p.MethodsDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportDeclContext is an interface to support dynamic dispatch.
type IImportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsImportDeclContext differentiates from other interfaces.
	IsImportDeclContext()
}

type ImportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportDeclContext() *ImportDeclContext {
	var p = new(ImportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
	return p
}

func InitEmptyImportDeclContext(p *ImportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importDecl
}

func (*ImportDeclContext) IsImportDeclContext() {}

func NewImportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportDeclContext {
	var p = new(ImportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importDecl

	return p
}

func (s *ImportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportDeclContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptIMPORT, 0)
}

func (s *ImportDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ImportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ImportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportDecl(s)
	}
}

func (s *ImportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportDecl(s)
	}
}

func (s *ImportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportDecl() (localctx IImportDeclContext) {
	localctx = NewImportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ManuscriptRULE_importDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.Match(ManuscriptIMPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(247)
		p.ModuleImport()
	}
	p.SetState(249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(248)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportDeclContext is an interface to support dynamic dispatch.
type IExportDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	ExportedItem() IExportedItemContext
	SEMICOLON() antlr.TerminalNode

	// IsExportDeclContext differentiates from other interfaces.
	IsExportDeclContext()
}

type ExportDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportDeclContext() *ExportDeclContext {
	var p = new(ExportDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
	return p
}

func InitEmptyExportDeclContext(p *ExportDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportDecl
}

func (*ExportDeclContext) IsExportDeclContext() {}

func NewExportDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportDeclContext {
	var p = new(ExportDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportDecl

	return p
}

func (s *ExportDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportDeclContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXPORT, 0)
}

func (s *ExportDeclContext) ExportedItem() IExportedItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportedItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportedItemContext)
}

func (s *ExportDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExportDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportDecl(s)
	}
}

func (s *ExportDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportDecl(s)
	}
}

func (s *ExportDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportDecl() (localctx IExportDeclContext) {
	localctx = NewExportDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ManuscriptRULE_exportDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(251)
		p.Match(ManuscriptEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(252)
		p.ExportedItem()
	}
	p.SetState(254)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(253)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternDeclContext is an interface to support dynamic dispatch.
type IExternDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	ModuleImport() IModuleImportContext
	SEMICOLON() antlr.TerminalNode

	// IsExternDeclContext differentiates from other interfaces.
	IsExternDeclContext()
}

type ExternDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternDeclContext() *ExternDeclContext {
	var p = new(ExternDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
	return p
}

func InitEmptyExternDeclContext(p *ExternDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_externDecl
}

func (*ExternDeclContext) IsExternDeclContext() {}

func NewExternDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternDeclContext {
	var p = new(ExternDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_externDecl

	return p
}

func (s *ExternDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternDeclContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTERN, 0)
}

func (s *ExternDeclContext) ModuleImport() IModuleImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleImportContext)
}

func (s *ExternDeclContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ExternDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExternDecl(s)
	}
}

func (s *ExternDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExternDecl(s)
	}
}

func (s *ExternDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExternDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExternDecl() (localctx IExternDeclContext) {
	localctx = NewExternDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ManuscriptRULE_externDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.Match(ManuscriptEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(257)
		p.ModuleImport()
	}
	p.SetState(259)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(258)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportedItemContext is an interface to support dynamic dispatch.
type IExportedItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExportedItemContext differentiates from other interfaces.
	IsExportedItemContext()
}

type ExportedItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportedItemContext() *ExportedItemContext {
	var p = new(ExportedItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
	return p
}

func InitEmptyExportedItemContext(p *ExportedItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exportedItem
}

func (*ExportedItemContext) IsExportedItemContext() {}

func NewExportedItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportedItemContext {
	var p = new(ExportedItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exportedItem

	return p
}

func (s *ExportedItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportedItemContext) CopyAll(ctx *ExportedItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExportedItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExportedLetContext struct {
	ExportedItemContext
}

func NewExportedLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportedLetContext {
	var p = new(ExportedLetContext)

	InitEmptyExportedItemContext(&p.ExportedItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportedItemContext))

	return p
}

func (s *ExportedLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *ExportedLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedLet(s)
	}
}

func (s *ExportedLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedLet(s)
	}
}

func (s *ExportedLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportedTypeContext struct {
	ExportedItemContext
}

func NewExportedTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportedTypeContext {
	var p = new(ExportedTypeContext)

	InitEmptyExportedItemContext(&p.ExportedItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportedItemContext))

	return p
}

func (s *ExportedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedTypeContext) TypeDecl() ITypeDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclContext)
}

func (s *ExportedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedType(s)
	}
}

func (s *ExportedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedType(s)
	}
}

func (s *ExportedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedType(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportedFnContext struct {
	ExportedItemContext
}

func NewExportedFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportedFnContext {
	var p = new(ExportedFnContext)

	InitEmptyExportedItemContext(&p.ExportedItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportedItemContext))

	return p
}

func (s *ExportedFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedFnContext) FnDecl() IFnDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnDeclContext)
}

func (s *ExportedFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedFn(s)
	}
}

func (s *ExportedFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedFn(s)
	}
}

func (s *ExportedFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExportedInterfaceContext struct {
	ExportedItemContext
}

func NewExportedInterfaceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExportedInterfaceContext {
	var p = new(ExportedInterfaceContext)

	InitEmptyExportedItemContext(&p.ExportedItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExportedItemContext))

	return p
}

func (s *ExportedInterfaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportedInterfaceContext) InterfaceDecl() IInterfaceDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclContext)
}

func (s *ExportedInterfaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExportedInterface(s)
	}
}

func (s *ExportedInterfaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExportedInterface(s)
	}
}

func (s *ExportedInterfaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExportedInterface(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExportedItem() (localctx IExportedItemContext) {
	localctx = NewExportedItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ManuscriptRULE_exportedItem)
	p.SetState(265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN:
		localctx = NewExportedFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(261)
			p.FnDecl()
		}

	case ManuscriptLET:
		localctx = NewExportedLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(262)
			p.LetDecl()
		}

	case ManuscriptTYPE:
		localctx = NewExportedTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(263)
			p.TypeDecl()
		}

	case ManuscriptINTERFACE:
		localctx = NewExportedInterfaceContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(264)
			p.InterfaceDecl()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleImportContext is an interface to support dynamic dispatch.
type IModuleImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsModuleImportContext differentiates from other interfaces.
	IsModuleImportContext()
}

type ModuleImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleImportContext() *ModuleImportContext {
	var p = new(ModuleImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
	return p
}

func InitEmptyModuleImportContext(p *ModuleImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_moduleImport
}

func (*ModuleImportContext) IsModuleImportContext() {}

func NewModuleImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleImportContext {
	var p = new(ModuleImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_moduleImport

	return p
}

func (s *ModuleImportContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleImportContext) CopyAll(ctx *ModuleImportContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ModuleImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ModuleImportDestructuredContext struct {
	ModuleImportContext
}

func NewModuleImportDestructuredContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleImportDestructuredContext {
	var p = new(ModuleImportDestructuredContext)

	InitEmptyModuleImportContext(&p.ModuleImportContext)
	p.parser = parser
	p.CopyAll(ctx.(*ModuleImportContext))

	return p
}

func (s *ModuleImportDestructuredContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportDestructuredContext) DestructuredImport() IDestructuredImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestructuredImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestructuredImportContext)
}

func (s *ModuleImportDestructuredContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterModuleImportDestructured(s)
	}
}

func (s *ModuleImportDestructuredContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitModuleImportDestructured(s)
	}
}

func (s *ModuleImportDestructuredContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitModuleImportDestructured(s)

	default:
		return t.VisitChildren(s)
	}
}

type ModuleImportTargetContext struct {
	ModuleImportContext
}

func NewModuleImportTargetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ModuleImportTargetContext {
	var p = new(ModuleImportTargetContext)

	InitEmptyModuleImportContext(&p.ModuleImportContext)
	p.parser = parser
	p.CopyAll(ctx.(*ModuleImportContext))

	return p
}

func (s *ModuleImportTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleImportTargetContext) TargetImport() ITargetImportContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITargetImportContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITargetImportContext)
}

func (s *ModuleImportTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterModuleImportTarget(s)
	}
}

func (s *ModuleImportTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitModuleImportTarget(s)
	}
}

func (s *ModuleImportTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitModuleImportTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ModuleImport() (localctx IModuleImportContext) {
	localctx = NewModuleImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ManuscriptRULE_moduleImport)
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLBRACE:
		localctx = NewModuleImportDestructuredContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.DestructuredImport()
		}

	case ManuscriptID:
		localctx = NewModuleImportTargetContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(268)
			p.TargetImport()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDestructuredImportContext is an interface to support dynamic dispatch.
type IDestructuredImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	ImportStr() IImportStrContext
	ImportItemList() IImportItemListContext

	// IsDestructuredImportContext differentiates from other interfaces.
	IsDestructuredImportContext()
}

type DestructuredImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestructuredImportContext() *DestructuredImportContext {
	var p = new(DestructuredImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
	return p
}

func InitEmptyDestructuredImportContext(p *DestructuredImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_destructuredImport
}

func (*DestructuredImportContext) IsDestructuredImportContext() {}

func NewDestructuredImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestructuredImportContext {
	var p = new(DestructuredImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_destructuredImport

	return p
}

func (s *DestructuredImportContext) GetParser() antlr.Parser { return s.parser }

func (s *DestructuredImportContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *DestructuredImportContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *DestructuredImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *DestructuredImportContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *DestructuredImportContext) ImportItemList() IImportItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemListContext)
}

func (s *DestructuredImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestructuredImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestructuredImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDestructuredImport(s)
	}
}

func (s *DestructuredImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDestructuredImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DestructuredImport() (localctx IDestructuredImportContext) {
	localctx = NewDestructuredImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ManuscriptRULE_destructuredImport)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(271)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(272)
			p.ImportItemList()
		}

	}
	{
		p.SetState(275)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(276)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(277)
		p.ImportStr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITargetImportContext is an interface to support dynamic dispatch.
type ITargetImportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	FROM() antlr.TerminalNode
	ImportStr() IImportStrContext

	// IsTargetImportContext differentiates from other interfaces.
	IsTargetImportContext()
}

type TargetImportContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTargetImportContext() *TargetImportContext {
	var p = new(TargetImportContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
	return p
}

func InitEmptyTargetImportContext(p *TargetImportContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_targetImport
}

func (*TargetImportContext) IsTargetImportContext() {}

func NewTargetImportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TargetImportContext {
	var p = new(TargetImportContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_targetImport

	return p
}

func (s *TargetImportContext) GetParser() antlr.Parser { return s.parser }

func (s *TargetImportContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TargetImportContext) FROM() antlr.TerminalNode {
	return s.GetToken(ManuscriptFROM, 0)
}

func (s *TargetImportContext) ImportStr() IImportStrContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStrContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStrContext)
}

func (s *TargetImportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TargetImportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TargetImportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTargetImport(s)
	}
}

func (s *TargetImportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTargetImport(s)
	}
}

func (s *TargetImportContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTargetImport(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TargetImport() (localctx ITargetImportContext) {
	localctx = NewTargetImportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ManuscriptRULE_targetImport)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(279)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(280)
		p.Match(ManuscriptFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(281)
		p.ImportStr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemListContext is an interface to support dynamic dispatch.
type IImportItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllImportItem() []IImportItemContext
	ImportItem(i int) IImportItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsImportItemListContext differentiates from other interfaces.
	IsImportItemListContext()
}

type ImportItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemListContext() *ImportItemListContext {
	var p = new(ImportItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
	return p
}

func InitEmptyImportItemListContext(p *ImportItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItemList
}

func (*ImportItemListContext) IsImportItemListContext() {}

func NewImportItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemListContext {
	var p = new(ImportItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItemList

	return p
}

func (s *ImportItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemListContext) AllImportItem() []IImportItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IImportItemContext); ok {
			len++
		}
	}

	tst := make([]IImportItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IImportItemContext); ok {
			tst[i] = t.(IImportItemContext)
			i++
		}
	}

	return tst
}

func (s *ImportItemListContext) ImportItem(i int) IImportItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportItemContext)
}

func (s *ImportItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ImportItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ImportItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItemList(s)
	}
}

func (s *ImportItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItemList(s)
	}
}

func (s *ImportItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItemList() (localctx IImportItemListContext) {
	localctx = NewImportItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ManuscriptRULE_importItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.ImportItem()
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(284)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(285)
				p.ImportItem()
			}

		}
		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(291)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportItemContext is an interface to support dynamic dispatch.
type IImportItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsImportItemContext differentiates from other interfaces.
	IsImportItemContext()
}

type ImportItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportItemContext() *ImportItemContext {
	var p = new(ImportItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
	return p
}

func InitEmptyImportItemContext(p *ImportItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importItem
}

func (*ImportItemContext) IsImportItemContext() {}

func NewImportItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportItemContext {
	var p = new(ImportItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importItem

	return p
}

func (s *ImportItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportItemContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ImportItemContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ImportItemContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *ImportItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportItem(s)
	}
}

func (s *ImportItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportItem(s)
	}
}

func (s *ImportItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportItem() (localctx IImportItemContext) {
	localctx = NewImportItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ManuscriptRULE_importItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(294)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAS {
		{
			p.SetState(295)
			p.Match(ManuscriptAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(296)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStrContext is an interface to support dynamic dispatch.
type IImportStrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleQuotedString() ISingleQuotedStringContext

	// IsImportStrContext differentiates from other interfaces.
	IsImportStrContext()
}

type ImportStrContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStrContext() *ImportStrContext {
	var p = new(ImportStrContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
	return p
}

func InitEmptyImportStrContext(p *ImportStrContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_importStr
}

func (*ImportStrContext) IsImportStrContext() {}

func NewImportStrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStrContext {
	var p = new(ImportStrContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_importStr

	return p
}

func (s *ImportStrContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStrContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *ImportStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterImportStr(s)
	}
}

func (s *ImportStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitImportStr(s)
	}
}

func (s *ImportStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitImportStr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ImportStr() (localctx IImportStrContext) {
	localctx = NewImportStrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ManuscriptRULE_importStr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(299)
		p.SingleQuotedString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDeclContext is an interface to support dynamic dispatch.
type ILetDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetDeclContext differentiates from other interfaces.
	IsLetDeclContext()
}

type LetDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDeclContext() *LetDeclContext {
	var p = new(LetDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
	return p
}

func InitEmptyLetDeclContext(p *LetDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDecl
}

func (*LetDeclContext) IsLetDeclContext() {}

func NewLetDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDeclContext {
	var p = new(LetDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDecl

	return p
}

func (s *LetDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDeclContext) CopyAll(ctx *LetDeclContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LetDeclBlockContext struct {
	LetDeclContext
}

func NewLetDeclBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetDeclBlockContext {
	var p = new(LetDeclBlockContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LetDeclBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclBlockContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclBlockContext) LetBlock() ILetBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockContext)
}

func (s *LetDeclBlockContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDeclBlock(s)
	}
}

func (s *LetDeclBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDeclBlock(s)
	}
}

func (s *LetDeclBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDeclBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetDeclDestructuredObjContext struct {
	LetDeclContext
}

func NewLetDeclDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetDeclDestructuredObjContext {
	var p = new(LetDeclDestructuredObjContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LetDeclDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclDestructuredObjContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclDestructuredObjContext) LetDestructuredObj() ILetDestructuredObjContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredObjContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredObjContext)
}

func (s *LetDeclDestructuredObjContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDeclDestructuredObj(s)
	}
}

func (s *LetDeclDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDeclDestructuredObj(s)
	}
}

func (s *LetDeclDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDeclDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetDeclDestructuredArrayContext struct {
	LetDeclContext
}

func NewLetDeclDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetDeclDestructuredArrayContext {
	var p = new(LetDeclDestructuredArrayContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LetDeclDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclDestructuredArrayContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclDestructuredArrayContext) LetDestructuredArray() ILetDestructuredArrayContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDestructuredArrayContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDestructuredArrayContext)
}

func (s *LetDeclDestructuredArrayContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDeclDestructuredArray(s)
	}
}

func (s *LetDeclDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDeclDestructuredArray(s)
	}
}

func (s *LetDeclDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDeclDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetDeclSingleContext struct {
	LetDeclContext
}

func NewLetDeclSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetDeclSingleContext {
	var p = new(LetDeclSingleContext)

	InitEmptyLetDeclContext(&p.LetDeclContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetDeclContext))

	return p
}

func (s *LetDeclSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDeclSingleContext) LET() antlr.TerminalNode {
	return s.GetToken(ManuscriptLET, 0)
}

func (s *LetDeclSingleContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *LetDeclSingleContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *LetDeclSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDeclSingle(s)
	}
}

func (s *LetDeclSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDeclSingle(s)
	}
}

func (s *LetDeclSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDeclSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDecl() (localctx ILetDeclContext) {
	localctx = NewLetDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ManuscriptRULE_letDecl)
	p.SetState(321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLetDeclSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(301)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(302)
			p.LetSingle()
		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(303)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewLetDeclBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(306)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(307)
			p.LetBlock()
		}
		p.SetState(309)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(308)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewLetDeclDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(311)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(312)
			p.LetDestructuredObj()
		}
		p.SetState(314)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(313)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewLetDeclDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(316)
			p.Match(ManuscriptLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(317)
			p.LetDestructuredArray()
		}
		p.SetState(319)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(318)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetSingleContext is an interface to support dynamic dispatch.
type ILetSingleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypedID() ITypedIDContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetSingleContext differentiates from other interfaces.
	IsLetSingleContext()
}

type LetSingleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetSingleContext() *LetSingleContext {
	var p = new(LetSingleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
	return p
}

func InitEmptyLetSingleContext(p *LetSingleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letSingle
}

func (*LetSingleContext) IsLetSingleContext() {}

func NewLetSingleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetSingleContext {
	var p = new(LetSingleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letSingle

	return p
}

func (s *LetSingleContext) GetParser() antlr.Parser { return s.parser }

func (s *LetSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetSingleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetSingle(s)
	}
}

func (s *LetSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetSingle(s)
	}
}

func (s *LetSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetSingle() (localctx ILetSingleContext) {
	localctx = NewLetSingleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ManuscriptRULE_letSingle)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(323)
		p.TypedID()
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(324)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(325)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockContext is an interface to support dynamic dispatch.
type ILetBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LetBlockItemList() ILetBlockItemListContext

	// IsLetBlockContext differentiates from other interfaces.
	IsLetBlockContext()
}

type LetBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockContext() *LetBlockContext {
	var p = new(LetBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
	return p
}

func InitEmptyLetBlockContext(p *LetBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlock
}

func (*LetBlockContext) IsLetBlockContext() {}

func NewLetBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockContext {
	var p = new(LetBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlock

	return p
}

func (s *LetBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *LetBlockContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *LetBlockContext) LetBlockItemList() ILetBlockItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemListContext)
}

func (s *LetBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlock(s)
	}
}

func (s *LetBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlock(s)
	}
}

func (s *LetBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlock() (localctx ILetBlockContext) {
	localctx = NewLetBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ManuscriptRULE_letBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(328)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6760896999194626) != 0) || _la == ManuscriptID {
		{
			p.SetState(329)
			p.LetBlockItemList()
		}

	}
	{
		p.SetState(332)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemListContext is an interface to support dynamic dispatch.
type ILetBlockItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetBlockItem() []ILetBlockItemContext
	LetBlockItem(i int) ILetBlockItemContext
	AllLetBlockItemSep() []ILetBlockItemSepContext
	LetBlockItemSep(i int) ILetBlockItemSepContext

	// IsLetBlockItemListContext differentiates from other interfaces.
	IsLetBlockItemListContext()
}

type LetBlockItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemListContext() *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
	return p
}

func InitEmptyLetBlockItemListContext(p *LetBlockItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemList
}

func (*LetBlockItemListContext) IsLetBlockItemListContext() {}

func NewLetBlockItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemListContext {
	var p = new(LetBlockItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemList

	return p
}

func (s *LetBlockItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemListContext) AllLetBlockItem() []ILetBlockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemContext); ok {
			tst[i] = t.(ILetBlockItemContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItem(i int) ILetBlockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemContext)
}

func (s *LetBlockItemListContext) AllLetBlockItemSep() []ILetBlockItemSepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			len++
		}
	}

	tst := make([]ILetBlockItemSepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetBlockItemSepContext); ok {
			tst[i] = t.(ILetBlockItemSepContext)
			i++
		}
	}

	return tst
}

func (s *LetBlockItemListContext) LetBlockItemSep(i int) ILetBlockItemSepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetBlockItemSepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetBlockItemSepContext)
}

func (s *LetBlockItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemList(s)
	}
}

func (s *LetBlockItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemList() (localctx ILetBlockItemListContext) {
	localctx = NewLetBlockItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ManuscriptRULE_letBlockItemList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(334)
			p.LetBlockItemSep()
		}

		p.SetState(339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(340)
		p.LetBlockItem()
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(342)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0) {
				{
					p.SetState(341)
					p.LetBlockItemSep()
				}

				p.SetState(344)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(346)
				p.LetBlockItem()
			}

		}
		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&6755399441055746) != 0 {
		{
			p.SetState(353)
			p.LetBlockItemSep()
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemSepContext is an interface to support dynamic dispatch.
type ILetBlockItemSepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMA() antlr.TerminalNode
	Stmt_sep() IStmt_sepContext

	// IsLetBlockItemSepContext differentiates from other interfaces.
	IsLetBlockItemSepContext()
}

type LetBlockItemSepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemSepContext() *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
	return p
}

func InitEmptyLetBlockItemSepContext(p *LetBlockItemSepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItemSep
}

func (*LetBlockItemSepContext) IsLetBlockItemSepContext() {}

func NewLetBlockItemSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemSepContext {
	var p = new(LetBlockItemSepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItemSep

	return p
}

func (s *LetBlockItemSepContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemSepContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *LetBlockItemSepContext) Stmt_sep() IStmt_sepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LetBlockItemSepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetBlockItemSepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSep(s)
	}
}

func (s *LetBlockItemSepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItemSep() (localctx ILetBlockItemSepContext) {
	localctx = NewLetBlockItemSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ManuscriptRULE_letBlockItemSep)
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(359)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptNEWLINE, ManuscriptSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(360)
			p.Stmt_sep()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetBlockItemContext is an interface to support dynamic dispatch.
type ILetBlockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLetBlockItemContext differentiates from other interfaces.
	IsLetBlockItemContext()
}

type LetBlockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetBlockItemContext() *LetBlockItemContext {
	var p = new(LetBlockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
	return p
}

func InitEmptyLetBlockItemContext(p *LetBlockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letBlockItem
}

func (*LetBlockItemContext) IsLetBlockItemContext() {}

func NewLetBlockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetBlockItemContext {
	var p = new(LetBlockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letBlockItem

	return p
}

func (s *LetBlockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetBlockItemContext) CopyAll(ctx *LetBlockItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LetBlockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LetBlockItemDestructuredObjContext struct {
	LetBlockItemContext
}

func NewLetBlockItemDestructuredObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemDestructuredObjContext {
	var p = new(LetBlockItemDestructuredObjContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetBlockItemDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetBlockItemDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetBlockItemDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemDestructuredObj(s)
	}
}

func (s *LetBlockItemDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemDestructuredObj(s)
	}
}

func (s *LetBlockItemDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetBlockItemDestructuredArrayContext struct {
	LetBlockItemContext
}

func NewLetBlockItemDestructuredArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemDestructuredArrayContext {
	var p = new(LetBlockItemDestructuredArrayContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetBlockItemDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetBlockItemDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetBlockItemDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemDestructuredArray(s)
	}
}

func (s *LetBlockItemDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemDestructuredArray(s)
	}
}

func (s *LetBlockItemDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type LetBlockItemSingleContext struct {
	LetBlockItemContext
}

func NewLetBlockItemSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LetBlockItemSingleContext {
	var p = new(LetBlockItemSingleContext)

	InitEmptyLetBlockItemContext(&p.LetBlockItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*LetBlockItemContext))

	return p
}

func (s *LetBlockItemSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetBlockItemSingleContext) TypedID() ITypedIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *LetBlockItemSingleContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetBlockItemSingleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetBlockItemSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetBlockItemSingle(s)
	}
}

func (s *LetBlockItemSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetBlockItemSingle(s)
	}
}

func (s *LetBlockItemSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetBlockItemSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetBlockItem() (localctx ILetBlockItemContext) {
	localctx = NewLetBlockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ManuscriptRULE_letBlockItem)
	p.SetState(379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewLetBlockItemSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(363)
			p.TypedID()
		}
		{
			p.SetState(364)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(365)
			p.Expr()
		}

	case ManuscriptLBRACE:
		localctx = NewLetBlockItemDestructuredObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(367)
			p.Match(ManuscriptLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(368)
			p.TypedIDList()
		}
		{
			p.SetState(369)
			p.Match(ManuscriptRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(370)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(371)
			p.Expr()
		}

	case ManuscriptLSQBR:
		localctx = NewLetBlockItemDestructuredArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(373)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(374)
			p.TypedIDList()
		}
		{
			p.SetState(375)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(376)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Expr()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredObjContext is an interface to support dynamic dispatch.
type ILetDestructuredObjContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RBRACE() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredObjContext differentiates from other interfaces.
	IsLetDestructuredObjContext()
}

type LetDestructuredObjContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredObjContext() *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
	return p
}

func InitEmptyLetDestructuredObjContext(p *LetDestructuredObjContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredObj
}

func (*LetDestructuredObjContext) IsLetDestructuredObjContext() {}

func NewLetDestructuredObjContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredObjContext {
	var p = new(LetDestructuredObjContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredObj

	return p
}

func (s *LetDestructuredObjContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredObjContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LetDestructuredObjContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredObjContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LetDestructuredObjContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredObjContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredObjContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredObj(s)
	}
}

func (s *LetDestructuredObjContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredObj(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredObj() (localctx ILetDestructuredObjContext) {
	localctx = NewLetDestructuredObjContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ManuscriptRULE_letDestructuredObj)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(381)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(382)
		p.TypedIDList()
	}
	{
		p.SetState(383)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(384)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(385)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetDestructuredArrayContext is an interface to support dynamic dispatch.
type ILetDestructuredArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	TypedIDList() ITypedIDListContext
	RSQBR() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsLetDestructuredArrayContext differentiates from other interfaces.
	IsLetDestructuredArrayContext()
}

type LetDestructuredArrayContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetDestructuredArrayContext() *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
	return p
}

func InitEmptyLetDestructuredArrayContext(p *LetDestructuredArrayContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_letDestructuredArray
}

func (*LetDestructuredArrayContext) IsLetDestructuredArrayContext() {}

func NewLetDestructuredArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetDestructuredArrayContext {
	var p = new(LetDestructuredArrayContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_letDestructuredArray

	return p
}

func (s *LetDestructuredArrayContext) GetParser() antlr.Parser { return s.parser }

func (s *LetDestructuredArrayContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *LetDestructuredArrayContext) TypedIDList() ITypedIDListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDListContext)
}

func (s *LetDestructuredArrayContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *LetDestructuredArrayContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *LetDestructuredArrayContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LetDestructuredArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetDestructuredArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetDestructuredArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLetDestructuredArray(s)
	}
}

func (s *LetDestructuredArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLetDestructuredArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LetDestructuredArray() (localctx ILetDestructuredArrayContext) {
	localctx = NewLetDestructuredArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ManuscriptRULE_letDestructuredArray)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(387)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(388)
		p.TypedIDList()
	}
	{
		p.SetState(389)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(390)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(391)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDListContext is an interface to support dynamic dispatch.
type ITypedIDListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypedID() []ITypedIDContext
	TypedID(i int) ITypedIDContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypedIDListContext differentiates from other interfaces.
	IsTypedIDListContext()
}

type TypedIDListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDListContext() *TypedIDListContext {
	var p = new(TypedIDListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
	return p
}

func InitEmptyTypedIDListContext(p *TypedIDListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedIDList
}

func (*TypedIDListContext) IsTypedIDListContext() {}

func NewTypedIDListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDListContext {
	var p = new(TypedIDListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedIDList

	return p
}

func (s *TypedIDListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDListContext) AllTypedID() []ITypedIDContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypedIDContext); ok {
			len++
		}
	}

	tst := make([]ITypedIDContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypedIDContext); ok {
			tst[i] = t.(ITypedIDContext)
			i++
		}
	}

	return tst
}

func (s *TypedIDListContext) TypedID(i int) ITypedIDContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedIDContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedIDContext)
}

func (s *TypedIDListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypedIDListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypedIDListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedIDList(s)
	}
}

func (s *TypedIDListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedIDList(s)
	}
}

func (s *TypedIDListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedIDList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedIDList() (localctx ITypedIDListContext) {
	localctx = NewTypedIDListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ManuscriptRULE_typedIDList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.TypedID()
	}
	p.SetState(398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(394)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(395)
				p.TypedID()
			}

		}
		p.SetState(400)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(401)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedIDContext is an interface to support dynamic dispatch.
type ITypedIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext

	// IsTypedIDContext differentiates from other interfaces.
	IsTypedIDContext()
}

type TypedIDContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedIDContext() *TypedIDContext {
	var p = new(TypedIDContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
	return p
}

func InitEmptyTypedIDContext(p *TypedIDContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typedID
}

func (*TypedIDContext) IsTypedIDContext() {}

func NewTypedIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedIDContext {
	var p = new(TypedIDContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typedID

	return p
}

func (s *TypedIDContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypedIDContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypedIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypedID(s)
	}
}

func (s *TypedIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypedID(s)
	}
}

func (s *TypedIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypedID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypedID() (localctx ITypedIDContext) {
	localctx = NewTypedIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ManuscriptRULE_typedID)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(404)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(406)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(405)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclContext is an interface to support dynamic dispatch.
type ITypeDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	ID() antlr.TerminalNode
	TypeDefBody() ITypeDefBodyContext
	TypeAlias() ITypeAliasContext

	// IsTypeDeclContext differentiates from other interfaces.
	IsTypeDeclContext()
}

type TypeDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclContext() *TypeDeclContext {
	var p = new(TypeDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
	return p
}

func InitEmptyTypeDeclContext(p *TypeDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDecl
}

func (*TypeDeclContext) IsTypeDeclContext() {}

func NewTypeDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclContext {
	var p = new(TypeDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDecl

	return p
}

func (s *TypeDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclContext) TYPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTYPE, 0)
}

func (s *TypeDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeDeclContext) TypeDefBody() ITypeDefBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDefBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDefBodyContext)
}

func (s *TypeDeclContext) TypeAlias() ITypeAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAliasContext)
}

func (s *TypeDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDecl(s)
	}
}

func (s *TypeDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDecl(s)
	}
}

func (s *TypeDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDecl() (localctx ITypeDeclContext) {
	localctx = NewTypeDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ManuscriptRULE_typeDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(408)
		p.Match(ManuscriptTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(409)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(412)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEXTENDS, ManuscriptLBRACE:
		{
			p.SetState(410)
			p.TypeDefBody()
		}

	case ManuscriptEQUALS:
		{
			p.SetState(411)
			p.TypeAlias()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDefBodyContext is an interface to support dynamic dispatch.
type ITypeDefBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeDefBodyContext differentiates from other interfaces.
	IsTypeDefBodyContext()
}

type TypeDefBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDefBodyContext() *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
	return p
}

func InitEmptyTypeDefBodyContext(p *TypeDefBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeDefBody
}

func (*TypeDefBodyContext) IsTypeDefBodyContext() {}

func NewTypeDefBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDefBodyContext {
	var p = new(TypeDefBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeDefBody

	return p
}

func (s *TypeDefBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDefBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *TypeDefBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *TypeDefBodyContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeDefBodyContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeDefBodyContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *TypeDefBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *TypeDefBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *TypeDefBodyContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeDefBodyContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeDefBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDefBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDefBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeDefBody(s)
	}
}

func (s *TypeDefBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeDefBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeDefBody() (localctx ITypeDefBodyContext) {
	localctx = NewTypeDefBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ManuscriptRULE_typeDefBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(414)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(415)
			p.TypeList()
		}

	}
	{
		p.SetState(418)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(419)
				p.Stmt_sep()
			}

			p.SetState(424)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(425)
			p.FieldDecl()
		}
		p.SetState(442)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(429)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(426)
						p.Stmt_sep()
					}

					p.SetState(431)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(432)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(436)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
					{
						p.SetState(433)
						p.Stmt_sep()
					}

					p.SetState(438)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}
				{
					p.SetState(439)
					p.FieldDecl()
				}

			}
			p.SetState(444)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			p.SetState(448)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(445)
					p.Stmt_sep()
				}

				p.SetState(450)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(451)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(454)
				p.Stmt_sep()
			}

			p.SetState(459)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(462)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAliasContext is an interface to support dynamic dispatch.
type ITypeAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUALS() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTypeAliasContext differentiates from other interfaces.
	IsTypeAliasContext()
}

type TypeAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAliasContext() *TypeAliasContext {
	var p = new(TypeAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
	return p
}

func InitEmptyTypeAliasContext(p *TypeAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAlias
}

func (*TypeAliasContext) IsTypeAliasContext() {}

func NewTypeAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAliasContext {
	var p = new(TypeAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAlias

	return p
}

func (s *TypeAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAliasContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *TypeAliasContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeAliasContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *TypeAliasContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TypeAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAlias(s)
	}
}

func (s *TypeAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAlias(s)
	}
}

func (s *TypeAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAlias() (localctx ITypeAliasContext) {
	localctx = NewTypeAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ManuscriptRULE_typeAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(464)
		p.Match(ManuscriptEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(465)
		p.TypeAnnotation()
	}
	p.SetState(468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(466)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(467)
			p.TypeList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFieldDecl() []IFieldDeclContext
	FieldDecl(i int) IFieldDeclContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
	return p
}

func InitEmptyFieldListContext(p *FieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldList
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllFieldDecl() []IFieldDeclContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldDeclContext); ok {
			len++
		}
	}

	tst := make([]IFieldDeclContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldDeclContext); ok {
			tst[i] = t.(IFieldDeclContext)
			i++
		}
	}

	return tst
}

func (s *FieldListContext) FieldDecl(i int) IFieldDeclContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDeclContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDeclContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ManuscriptRULE_fieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(470)
		p.FieldDecl()
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(471)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(472)
				p.FieldDecl()
			}

		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(478)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDeclContext is an interface to support dynamic dispatch.
type IFieldDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	QUESTION() antlr.TerminalNode

	// IsFieldDeclContext differentiates from other interfaces.
	IsFieldDeclContext()
}

type FieldDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclContext() *FieldDeclContext {
	var p = new(FieldDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
	return p
}

func InitEmptyFieldDeclContext(p *FieldDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fieldDecl
}

func (*FieldDeclContext) IsFieldDeclContext() {}

func NewFieldDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclContext {
	var p = new(FieldDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fieldDecl

	return p
}

func (s *FieldDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FieldDeclContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FieldDeclContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *FieldDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFieldDecl(s)
	}
}

func (s *FieldDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFieldDecl(s)
	}
}

func (s *FieldDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFieldDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FieldDecl() (localctx IFieldDeclContext) {
	localctx = NewFieldDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ManuscriptRULE_fieldDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptQUESTION {
		{
			p.SetState(482)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(485)
		p.TypeAnnotation()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeAnnotation() []ITypeAnnotationContext
	TypeAnnotation(i int) ITypeAnnotationContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllTypeAnnotation() []ITypeAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			len++
		}
	}

	tst := make([]ITypeAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeAnnotationContext); ok {
			tst[i] = t.(ITypeAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) TypeAnnotation(i int) ITypeAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *TypeListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *TypeListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ManuscriptRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.TypeAnnotation()
	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(488)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(489)
				p.TypeAnnotation()
			}

		}
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(495)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclContext is an interface to support dynamic dispatch.
type IInterfaceDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTERFACE() antlr.TerminalNode
	ID() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	EXTENDS() antlr.TerminalNode
	TypeList() ITypeListContext
	AllInterfaceMethod() []IInterfaceMethodContext
	InterfaceMethod(i int) IInterfaceMethodContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsInterfaceDeclContext differentiates from other interfaces.
	IsInterfaceDeclContext()
}

type InterfaceDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclContext() *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
	return p
}

func InitEmptyInterfaceDeclContext(p *InterfaceDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceDecl
}

func (*InterfaceDeclContext) IsInterfaceDeclContext() {}

func NewInterfaceDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclContext {
	var p = new(InterfaceDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceDecl

	return p
}

func (s *InterfaceDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERFACE, 0)
}

func (s *InterfaceDeclContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *InterfaceDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *InterfaceDeclContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXTENDS, 0)
}

func (s *InterfaceDeclContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *InterfaceDeclContext) AllInterfaceMethod() []IInterfaceMethodContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceMethodContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceMethodContext); ok {
			tst[i] = t.(IInterfaceMethodContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) InterfaceMethod(i int) IInterfaceMethodContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *InterfaceDeclContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *InterfaceDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceDecl(s)
	}
}

func (s *InterfaceDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceDecl() (localctx IInterfaceDeclContext) {
	localctx = NewInterfaceDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ManuscriptRULE_interfaceDecl)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(ManuscriptINTERFACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(499)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXTENDS {
		{
			p.SetState(500)
			p.Match(ManuscriptEXTENDS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)
			p.TypeList()
		}

	}
	{
		p.SetState(504)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		p.SetState(508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
			{
				p.SetState(505)
				p.Stmt_sep()
			}

			p.SetState(510)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(511)
			p.InterfaceMethod()
		}
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(512)
					p.Stmt_sep()
				}

			}
			p.SetState(517)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

		p.SetState(520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(522)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceMethodContext is an interface to support dynamic dispatch.
type IInterfaceMethodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsInterfaceMethodContext differentiates from other interfaces.
	IsInterfaceMethodContext()
}

type InterfaceMethodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodContext() *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
	return p
}

func InitEmptyInterfaceMethodContext(p *InterfaceMethodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interfaceMethod
}

func (*InterfaceMethodContext) IsInterfaceMethodContext() {}

func NewInterfaceMethodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodContext {
	var p = new(InterfaceMethodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interfaceMethod

	return p
}

func (s *InterfaceMethodContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *InterfaceMethodContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *InterfaceMethodContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *InterfaceMethodContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *InterfaceMethodContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *InterfaceMethodContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *InterfaceMethodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterfaceMethod(s)
	}
}

func (s *InterfaceMethodContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterfaceMethod(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) InterfaceMethod() (localctx IInterfaceMethodContext) {
	localctx = NewInterfaceMethodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ManuscriptRULE_interfaceMethod)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(524)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(525)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(526)
			p.Parameters()
		}

	}
	{
		p.SetState(529)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(530)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(533)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnDeclContext is an interface to support dynamic dispatch.
type IFnDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FnSignature() IFnSignatureContext
	CodeBlock() ICodeBlockContext

	// IsFnDeclContext differentiates from other interfaces.
	IsFnDeclContext()
}

type FnDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnDeclContext() *FnDeclContext {
	var p = new(FnDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
	return p
}

func InitEmptyFnDeclContext(p *FnDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnDecl
}

func (*FnDeclContext) IsFnDeclContext() {}

func NewFnDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnDeclContext {
	var p = new(FnDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnDecl

	return p
}

func (s *FnDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *FnDeclContext) FnSignature() IFnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnSignatureContext)
}

func (s *FnDeclContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnDecl(s)
	}
}

func (s *FnDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnDecl(s)
	}
}

func (s *FnDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnDecl() (localctx IFnDeclContext) {
	localctx = NewFnDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ManuscriptRULE_fnDecl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(536)
		p.FnSignature()
	}
	{
		p.SetState(537)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnSignatureContext is an interface to support dynamic dispatch.
type IFnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext
	EXCLAMATION() antlr.TerminalNode

	// IsFnSignatureContext differentiates from other interfaces.
	IsFnSignatureContext()
}

type FnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnSignatureContext() *FnSignatureContext {
	var p = new(FnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
	return p
}

func InitEmptyFnSignatureContext(p *FnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnSignature
}

func (*FnSignatureContext) IsFnSignatureContext() {}

func NewFnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnSignatureContext {
	var p = new(FnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnSignature

	return p
}

func (s *FnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *FnSignatureContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnSignatureContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *FnSignatureContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnSignatureContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnSignatureContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnSignatureContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnSignatureContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *FnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnSignature(s)
	}
}

func (s *FnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnSignature(s)
	}
}

func (s *FnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnSignature() (localctx IFnSignatureContext) {
	localctx = NewFnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ManuscriptRULE_fnSignature)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(540)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(541)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(542)
			p.Parameters()
		}

	}
	{
		p.SetState(545)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(546)
			p.TypeAnnotation()
		}

	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEXCLAMATION {
		{
			p.SetState(549)
			p.Match(ManuscriptEXCLAMATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersContext is an interface to support dynamic dispatch.
type IParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParam() []IParamContext
	Param(i int) IParamContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParametersContext differentiates from other interfaces.
	IsParametersContext()
}

type ParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersContext() *ParametersContext {
	var p = new(ParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
	return p
}

func InitEmptyParametersContext(p *ParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_parameters
}

func (*ParametersContext) IsParametersContext() {}

func NewParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersContext {
	var p = new(ParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_parameters

	return p
}

func (s *ParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParametersContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParameters(s)
	}
}

func (s *ParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParameters(s)
	}
}

func (s *ParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Parameters() (localctx IParametersContext) {
	localctx = NewParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ManuscriptRULE_parameters)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Param()
	}
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(553)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(554)
				p.Param()
			}

		}
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(560)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	TypeAnnotation() ITypeAnnotationContext
	EQUALS() antlr.TerminalNode
	Expr() IExprContext

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
	return p
}

func InitEmptyParamContext(p *ParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_param
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ParamContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *ParamContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *ParamContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitParam(s)
	}
}

func (s *ParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ManuscriptRULE_param)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(564)
		p.TypeAnnotation()
	}
	p.SetState(567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptEQUALS {
		{
			p.SetState(565)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(566)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodsDeclContext is an interface to support dynamic dispatch.
type IMethodsDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	METHODS() antlr.TerminalNode
	AllID() []antlr.TerminalNode
	ID(i int) antlr.TerminalNode
	AS() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	MethodImplList() IMethodImplListContext

	// IsMethodsDeclContext differentiates from other interfaces.
	IsMethodsDeclContext()
}

type MethodsDeclContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodsDeclContext() *MethodsDeclContext {
	var p = new(MethodsDeclContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
	return p
}

func InitEmptyMethodsDeclContext(p *MethodsDeclContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodsDecl
}

func (*MethodsDeclContext) IsMethodsDeclContext() {}

func NewMethodsDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodsDeclContext {
	var p = new(MethodsDeclContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodsDecl

	return p
}

func (s *MethodsDeclContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodsDeclContext) METHODS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMETHODS, 0)
}

func (s *MethodsDeclContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *MethodsDeclContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *MethodsDeclContext) AS() antlr.TerminalNode {
	return s.GetToken(ManuscriptAS, 0)
}

func (s *MethodsDeclContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MethodsDeclContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MethodsDeclContext) MethodImplList() IMethodImplListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplListContext)
}

func (s *MethodsDeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodsDeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodsDeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodsDecl(s)
	}
}

func (s *MethodsDeclContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodsDecl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodsDecl() (localctx IMethodsDeclContext) {
	localctx = NewMethodsDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ManuscriptRULE_methodsDecl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(569)
		p.Match(ManuscriptMETHODS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(570)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(571)
		p.Match(ManuscriptAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(572)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(573)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON || _la == ManuscriptID {
		{
			p.SetState(574)
			p.MethodImplList()
		}

	}
	{
		p.SetState(577)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplListContext is an interface to support dynamic dispatch.
type IMethodImplListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMethodImpl() []IMethodImplContext
	MethodImpl(i int) IMethodImplContext
	AllMethodImplSep() []IMethodImplSepContext
	MethodImplSep(i int) IMethodImplSepContext

	// IsMethodImplListContext differentiates from other interfaces.
	IsMethodImplListContext()
}

type MethodImplListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplListContext() *MethodImplListContext {
	var p = new(MethodImplListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
	return p
}

func InitEmptyMethodImplListContext(p *MethodImplListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplList
}

func (*MethodImplListContext) IsMethodImplListContext() {}

func NewMethodImplListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplListContext {
	var p = new(MethodImplListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImplList

	return p
}

func (s *MethodImplListContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplListContext) AllMethodImpl() []IMethodImplContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplContext); ok {
			tst[i] = t.(IMethodImplContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) MethodImpl(i int) IMethodImplContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplContext)
}

func (s *MethodImplListContext) AllMethodImplSep() []IMethodImplSepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMethodImplSepContext); ok {
			len++
		}
	}

	tst := make([]IMethodImplSepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMethodImplSepContext); ok {
			tst[i] = t.(IMethodImplSepContext)
			i++
		}
	}

	return tst
}

func (s *MethodImplListContext) MethodImplSep(i int) IMethodImplSepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodImplSepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodImplSepContext)
}

func (s *MethodImplListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImplList(s)
	}
}

func (s *MethodImplListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImplList(s)
	}
}

func (s *MethodImplListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImplList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImplList() (localctx IMethodImplListContext) {
	localctx = NewMethodImplListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ManuscriptRULE_methodImplList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(579)
			p.MethodImplSep()
		}

		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(585)
		p.MethodImpl()
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(587)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(586)
					p.MethodImplSep()
				}

				p.SetState(589)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(591)
				p.MethodImpl()
			}

		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(598)
			p.MethodImplSep()
		}

		p.SetState(603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplSepContext is an interface to support dynamic dispatch.
type IMethodImplSepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Stmt_sep() IStmt_sepContext

	// IsMethodImplSepContext differentiates from other interfaces.
	IsMethodImplSepContext()
}

type MethodImplSepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplSepContext() *MethodImplSepContext {
	var p = new(MethodImplSepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplSep
	return p
}

func InitEmptyMethodImplSepContext(p *MethodImplSepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImplSep
}

func (*MethodImplSepContext) IsMethodImplSepContext() {}

func NewMethodImplSepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplSepContext {
	var p = new(MethodImplSepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImplSep

	return p
}

func (s *MethodImplSepContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplSepContext) Stmt_sep() IStmt_sepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MethodImplSepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplSepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplSepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImplSep(s)
	}
}

func (s *MethodImplSepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImplSep(s)
	}
}

func (s *MethodImplSepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImplSep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImplSep() (localctx IMethodImplSepContext) {
	localctx = NewMethodImplSepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ManuscriptRULE_methodImplSep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Stmt_sep()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMethodImplContext is an interface to support dynamic dispatch.
type IMethodImplContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceMethod() IInterfaceMethodContext
	CodeBlock() ICodeBlockContext

	// IsMethodImplContext differentiates from other interfaces.
	IsMethodImplContext()
}

type MethodImplContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodImplContext() *MethodImplContext {
	var p = new(MethodImplContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
	return p
}

func InitEmptyMethodImplContext(p *MethodImplContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_methodImpl
}

func (*MethodImplContext) IsMethodImplContext() {}

func NewMethodImplContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodImplContext {
	var p = new(MethodImplContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_methodImpl

	return p
}

func (s *MethodImplContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodImplContext) InterfaceMethod() IInterfaceMethodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceMethodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodContext)
}

func (s *MethodImplContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *MethodImplContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodImplContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodImplContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMethodImpl(s)
	}
}

func (s *MethodImplContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMethodImpl(s)
	}
}

func (s *MethodImplContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMethodImpl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MethodImpl() (localctx IMethodImplContext) {
	localctx = NewMethodImplContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ManuscriptRULE_methodImpl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.InterfaceMethod()
	}
	{
		p.SetState(607)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmtContext is an interface to support dynamic dispatch.
type IStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStmtContext differentiates from other interfaces.
	IsStmtContext()
}

type StmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmtContext() *StmtContext {
	var p = new(StmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
	return p
}

func InitEmptyStmtContext(p *StmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt
}

func (*StmtContext) IsStmtContext() {}

func NewStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StmtContext {
	var p = new(StmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt

	return p
}

func (s *StmtContext) GetParser() antlr.Parser { return s.parser }

func (s *StmtContext) CopyAll(ctx *StmtContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StmtReturnContext struct {
	StmtContext
}

func NewStmtReturnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtReturnContext {
	var p = new(StmtReturnContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtReturnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtReturnContext) ReturnStmt() IReturnStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStmtContext)
}

func (s *StmtReturnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtReturn(s)
	}
}

func (s *StmtReturnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtReturn(s)
	}
}

func (s *StmtReturnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtReturn(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtCheckContext struct {
	StmtContext
}

func NewStmtCheckContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtCheckContext {
	var p = new(StmtCheckContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtCheckContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtCheckContext) CheckStmt() ICheckStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckStmtContext)
}

func (s *StmtCheckContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtCheck(s)
	}
}

func (s *StmtCheckContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtCheck(s)
	}
}

func (s *StmtCheckContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtCheck(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBlockContext struct {
	StmtContext
}

func NewStmtBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBlockContext {
	var p = new(StmtBlockContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *StmtBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtBlock(s)
	}
}

func (s *StmtBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtBlock(s)
	}
}

func (s *StmtBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtContinueContext struct {
	StmtContext
}

func NewStmtContinueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtContinueContext {
	var p = new(StmtContinueContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtContinueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtContinueContext) ContinueStmt() IContinueStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStmtContext)
}

func (s *StmtContinueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtContinue(s)
	}
}

func (s *StmtContinueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtContinue(s)
	}
}

func (s *StmtContinueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtContinue(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtExprContext struct {
	StmtContext
}

func NewStmtExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtExprContext {
	var p = new(StmtExprContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StmtExprContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *StmtExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtExpr(s)
	}
}

func (s *StmtExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtExpr(s)
	}
}

func (s *StmtExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtWhileContext struct {
	StmtContext
}

func NewStmtWhileContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtWhileContext {
	var p = new(StmtWhileContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtWhileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtWhileContext) WhileStmt() IWhileStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStmtContext)
}

func (s *StmtWhileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtWhile(s)
	}
}

func (s *StmtWhileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtWhile(s)
	}
}

func (s *StmtWhileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtWhile(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtDeferContext struct {
	StmtContext
}

func NewStmtDeferContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtDeferContext {
	var p = new(StmtDeferContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtDeferContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtDeferContext) DeferStmt() IDeferStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeferStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeferStmtContext)
}

func (s *StmtDeferContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtDefer(s)
	}
}

func (s *StmtDeferContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtDefer(s)
	}
}

func (s *StmtDeferContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtDefer(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtYieldContext struct {
	StmtContext
}

func NewStmtYieldContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtYieldContext {
	var p = new(StmtYieldContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtYieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtYieldContext) YieldStmt() IYieldStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IYieldStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IYieldStmtContext)
}

func (s *StmtYieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtYield(s)
	}
}

func (s *StmtYieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtYield(s)
	}
}

func (s *StmtYieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtYield(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtForContext struct {
	StmtContext
}

func NewStmtForContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtForContext {
	var p = new(StmtForContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtForContext) ForStmt() IForStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStmtContext)
}

func (s *StmtForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtFor(s)
	}
}

func (s *StmtForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtFor(s)
	}
}

func (s *StmtForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtFor(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtIfContext struct {
	StmtContext
}

func NewStmtIfContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtIfContext {
	var p = new(StmtIfContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtIfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtIfContext) IfStmt() IIfStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStmtContext)
}

func (s *StmtIfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtIf(s)
	}
}

func (s *StmtIfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtIf(s)
	}
}

func (s *StmtIfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtIf(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtLetContext struct {
	StmtContext
}

func NewStmtLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtLetContext {
	var p = new(StmtLetContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtLetContext) LetDecl() ILetDeclContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetDeclContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetDeclContext)
}

func (s *StmtLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtLet(s)
	}
}

func (s *StmtLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtLet(s)
	}
}

func (s *StmtLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type StmtBreakContext struct {
	StmtContext
}

func NewStmtBreakContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StmtBreakContext {
	var p = new(StmtBreakContext)

	InitEmptyStmtContext(&p.StmtContext)
	p.parser = parser
	p.CopyAll(ctx.(*StmtContext))

	return p
}

func (s *StmtBreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StmtBreakContext) BreakStmt() IBreakStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStmtContext)
}

func (s *StmtBreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmtBreak(s)
	}
}

func (s *StmtBreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmtBreak(s)
	}
}

func (s *StmtBreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmtBreak(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt() (localctx IStmtContext) {
	localctx = NewStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ManuscriptRULE_stmt)
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		localctx = NewStmtLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(609)
			p.LetDecl()
		}

	case 2:
		localctx = NewStmtExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(610)
			p.Expr()
		}
		p.SetState(612)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(611)
				p.Match(ManuscriptSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewStmtReturnContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(614)
			p.ReturnStmt()
		}

	case 4:
		localctx = NewStmtYieldContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(615)
			p.YieldStmt()
		}

	case 5:
		localctx = NewStmtIfContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(616)
			p.IfStmt()
		}

	case 6:
		localctx = NewStmtForContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(617)
			p.ForStmt()
		}

	case 7:
		localctx = NewStmtWhileContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(618)
			p.WhileStmt()
		}

	case 8:
		localctx = NewStmtBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(619)
			p.CodeBlock()
		}

	case 9:
		localctx = NewStmtBreakContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(620)
			p.BreakStmt()
		}

	case 10:
		localctx = NewStmtContinueContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(621)
			p.ContinueStmt()
		}

	case 11:
		localctx = NewStmtCheckContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(622)
			p.CheckStmt()
		}

	case 12:
		localctx = NewStmtDeferContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(623)
			p.DeferStmt()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStmtContext is an interface to support dynamic dispatch.
type IReturnStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsReturnStmtContext differentiates from other interfaces.
	IsReturnStmtContext()
}

type ReturnStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStmtContext() *ReturnStmtContext {
	var p = new(ReturnStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
	return p
}

func InitEmptyReturnStmtContext(p *ReturnStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_returnStmt
}

func (*ReturnStmtContext) IsReturnStmtContext() {}

func NewReturnStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStmtContext {
	var p = new(ReturnStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_returnStmt

	return p
}

func (s *ReturnStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStmtContext) RETURN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRETURN, 0)
}

func (s *ReturnStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ReturnStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ReturnStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterReturnStmt(s)
	}
}

func (s *ReturnStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitReturnStmt(s)
	}
}

func (s *ReturnStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitReturnStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ReturnStmt() (localctx IReturnStmtContext) {
	localctx = NewReturnStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ManuscriptRULE_returnStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.Match(ManuscriptRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(627)
			p.ExprList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(631)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(630)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IYieldStmtContext is an interface to support dynamic dispatch.
type IYieldStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YIELD() antlr.TerminalNode
	ExprList() IExprListContext
	SEMICOLON() antlr.TerminalNode

	// IsYieldStmtContext differentiates from other interfaces.
	IsYieldStmtContext()
}

type YieldStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldStmtContext() *YieldStmtContext {
	var p = new(YieldStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
	return p
}

func InitEmptyYieldStmtContext(p *YieldStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_yieldStmt
}

func (*YieldStmtContext) IsYieldStmtContext() {}

func NewYieldStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldStmtContext {
	var p = new(YieldStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_yieldStmt

	return p
}

func (s *YieldStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldStmtContext) YIELD() antlr.TerminalNode {
	return s.GetToken(ManuscriptYIELD, 0)
}

func (s *YieldStmtContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *YieldStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *YieldStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterYieldStmt(s)
	}
}

func (s *YieldStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitYieldStmt(s)
	}
}

func (s *YieldStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitYieldStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) YieldStmt() (localctx IYieldStmtContext) {
	localctx = NewYieldStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ManuscriptRULE_yieldStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(633)
		p.Match(ManuscriptYIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(634)
			p.ExprList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(637)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeferStmtContext is an interface to support dynamic dispatch.
type IDeferStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFER() antlr.TerminalNode
	Expr() IExprContext
	SEMICOLON() antlr.TerminalNode

	// IsDeferStmtContext differentiates from other interfaces.
	IsDeferStmtContext()
}

type DeferStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeferStmtContext() *DeferStmtContext {
	var p = new(DeferStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
	return p
}

func InitEmptyDeferStmtContext(p *DeferStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_deferStmt
}

func (*DeferStmtContext) IsDeferStmtContext() {}

func NewDeferStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeferStmtContext {
	var p = new(DeferStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_deferStmt

	return p
}

func (s *DeferStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *DeferStmtContext) DEFER() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFER, 0)
}

func (s *DeferStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeferStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DeferStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeferStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeferStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDeferStmt(s)
	}
}

func (s *DeferStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDeferStmt(s)
	}
}

func (s *DeferStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDeferStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DeferStmt() (localctx IDeferStmtContext) {
	localctx = NewDeferStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ManuscriptRULE_deferStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Match(ManuscriptDEFER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(641)
		p.Expr()
	}
	p.SetState(643)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(642)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ExprListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ManuscriptRULE_exprList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Expr()
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(646)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(647)
				p.Expr()
			}

		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(653)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStmtContext is an interface to support dynamic dispatch.
type IIfStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllCodeBlock() []ICodeBlockContext
	CodeBlock(i int) ICodeBlockContext
	ELSE() antlr.TerminalNode

	// IsIfStmtContext differentiates from other interfaces.
	IsIfStmtContext()
}

type IfStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStmtContext() *IfStmtContext {
	var p = new(IfStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
	return p
}

func InitEmptyIfStmtContext(p *IfStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ifStmt
}

func (*IfStmtContext) IsIfStmtContext() {}

func NewIfStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStmtContext {
	var p = new(IfStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ifStmt

	return p
}

func (s *IfStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStmtContext) IF() antlr.TerminalNode {
	return s.GetToken(ManuscriptIF, 0)
}

func (s *IfStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfStmtContext) AllCodeBlock() []ICodeBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeBlockContext); ok {
			len++
		}
	}

	tst := make([]ICodeBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeBlockContext); ok {
			tst[i] = t.(ICodeBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStmtContext) CodeBlock(i int) ICodeBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfStmtContext) ELSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptELSE, 0)
}

func (s *IfStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterIfStmt(s)
	}
}

func (s *IfStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitIfStmt(s)
	}
}

func (s *IfStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitIfStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) IfStmt() (localctx IIfStmtContext) {
	localctx = NewIfStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ManuscriptRULE_ifStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(ManuscriptIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.Expr()
	}
	{
		p.SetState(658)
		p.CodeBlock()
	}
	p.SetState(661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptELSE {
		{
			p.SetState(659)
			p.Match(ManuscriptELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(660)
			p.CodeBlock()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStmtContext is an interface to support dynamic dispatch.
type IForStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR() antlr.TerminalNode
	ForLoopType() IForLoopTypeContext

	// IsForStmtContext differentiates from other interfaces.
	IsForStmtContext()
}

type ForStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStmtContext() *ForStmtContext {
	var p = new(ForStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
	return p
}

func InitEmptyForStmtContext(p *ForStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forStmt
}

func (*ForStmtContext) IsForStmtContext() {}

func NewForStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStmtContext {
	var p = new(ForStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forStmt

	return p
}

func (s *ForStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStmtContext) FOR() antlr.TerminalNode {
	return s.GetToken(ManuscriptFOR, 0)
}

func (s *ForStmtContext) ForLoopType() IForLoopTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForLoopTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForLoopTypeContext)
}

func (s *ForStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForStmt(s)
	}
}

func (s *ForStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForStmt(s)
	}
}

func (s *ForStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForStmt() (localctx IForStmtContext) {
	localctx = NewForStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ManuscriptRULE_forStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(ManuscriptFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(664)
		p.ForLoopType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForLoopTypeContext is an interface to support dynamic dispatch.
type IForLoopTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForLoopTypeContext differentiates from other interfaces.
	IsForLoopTypeContext()
}

type ForLoopTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForLoopTypeContext() *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
	return p
}

func InitEmptyForLoopTypeContext(p *ForLoopTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forLoopType
}

func (*ForLoopTypeContext) IsForLoopTypeContext() {}

func NewForLoopTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForLoopTypeContext {
	var p = new(ForLoopTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forLoopType

	return p
}

func (s *ForLoopTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ForLoopTypeContext) CopyAll(ctx *ForLoopTypeContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForLoopTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ForInLoopContext struct {
	ForLoopTypeContext
}

func NewForInLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInLoopContext {
	var p = new(ForInLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *ForInLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInLoopContext) IN() antlr.TerminalNode {
	return s.GetToken(ManuscriptIN, 0)
}

func (s *ForInLoopContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForInLoopContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForInLoopContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptID)
}

func (s *ForInLoopContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptID, i)
}

func (s *ForInLoopContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *ForInLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForInLoop(s)
	}
}

func (s *ForInLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForInLoop(s)
	}
}

func (s *ForInLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForInLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForLoopContext struct {
	ForLoopTypeContext
}

func NewForLoopContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForLoopContext {
	var p = new(ForLoopContext)

	InitEmptyForLoopTypeContext(&p.ForLoopTypeContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForLoopTypeContext))

	return p
}

func (s *ForLoopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForLoopContext) ForTrinity() IForTrinityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForTrinityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForTrinityContext)
}

func (s *ForLoopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForLoop(s)
	}
}

func (s *ForLoopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForLoop(s)
	}
}

func (s *ForLoopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForLoop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForLoopType() (localctx IForLoopTypeContext) {
	localctx = NewForLoopTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ManuscriptRULE_forLoopType)
	var _la int

	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		localctx = NewForLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(666)
			p.ForTrinity()
		}

	case 2:
		localctx = NewForInLoopContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(667)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(668)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(669)
				p.Match(ManuscriptID)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		{
			p.SetState(672)
			p.Match(ManuscriptIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(673)
			p.Expr()
		}
		{
			p.SetState(674)
			p.LoopBody()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForTrinityContext is an interface to support dynamic dispatch.
type IForTrinityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ForInit() IForInitContext
	AllSEMICOLON() []antlr.TerminalNode
	SEMICOLON(i int) antlr.TerminalNode
	ForCond() IForCondContext
	ForPost() IForPostContext
	LoopBody() ILoopBodyContext

	// IsForTrinityContext differentiates from other interfaces.
	IsForTrinityContext()
}

type ForTrinityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForTrinityContext() *ForTrinityContext {
	var p = new(ForTrinityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
	return p
}

func InitEmptyForTrinityContext(p *ForTrinityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forTrinity
}

func (*ForTrinityContext) IsForTrinityContext() {}

func NewForTrinityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForTrinityContext {
	var p = new(ForTrinityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forTrinity

	return p
}

func (s *ForTrinityContext) GetParser() antlr.Parser { return s.parser }

func (s *ForTrinityContext) ForInit() IForInitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForTrinityContext) AllSEMICOLON() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptSEMICOLON)
}

func (s *ForTrinityContext) SEMICOLON(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, i)
}

func (s *ForTrinityContext) ForCond() IForCondContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForCondContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForCondContext)
}

func (s *ForTrinityContext) ForPost() IForPostContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForPostContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForPostContext)
}

func (s *ForTrinityContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *ForTrinityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForTrinityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForTrinityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForTrinity(s)
	}
}

func (s *ForTrinityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForTrinity(s)
	}
}

func (s *ForTrinityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForTrinity(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForTrinity() (localctx IForTrinityContext) {
	localctx = NewForTrinityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ManuscriptRULE_forTrinity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.ForInit()
	}
	{
		p.SetState(679)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(680)
		p.ForCond()
	}
	{
		p.SetState(681)
		p.Match(ManuscriptSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(682)
		p.ForPost()
	}
	{
		p.SetState(683)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
	return p
}

func InitEmptyForInitContext(p *ForInitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forInit
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) CopyAll(ctx *ForInitContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ForInitLetContext struct {
	ForInitContext
}

func NewForInitLetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInitLetContext {
	var p = new(ForInitLetContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *ForInitLetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitLetContext) LetSingle() ILetSingleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetSingleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetSingleContext)
}

func (s *ForInitLetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForInitLet(s)
	}
}

func (s *ForInitLetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForInitLet(s)
	}
}

func (s *ForInitLetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForInitLet(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForInitEmptyContext struct {
	ForInitContext
}

func NewForInitEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForInitEmptyContext {
	var p = new(ForInitEmptyContext)

	InitEmptyForInitContext(&p.ForInitContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForInitContext))

	return p
}

func (s *ForInitEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForInitEmpty(s)
	}
}

func (s *ForInitEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForInitEmpty(s)
	}
}

func (s *ForInitEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForInitEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ManuscriptRULE_forInit)
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewForInitLetContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(685)
			p.LetSingle()
		}

	case ManuscriptSEMICOLON:
		localctx = NewForInitEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForCondContext is an interface to support dynamic dispatch.
type IForCondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForCondContext differentiates from other interfaces.
	IsForCondContext()
}

type ForCondContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForCondContext() *ForCondContext {
	var p = new(ForCondContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
	return p
}

func InitEmptyForCondContext(p *ForCondContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forCond
}

func (*ForCondContext) IsForCondContext() {}

func NewForCondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForCondContext {
	var p = new(ForCondContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forCond

	return p
}

func (s *ForCondContext) GetParser() antlr.Parser { return s.parser }

func (s *ForCondContext) CopyAll(ctx *ForCondContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForCondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ForCondExprContext struct {
	ForCondContext
}

func NewForCondExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForCondExprContext {
	var p = new(ForCondExprContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *ForCondExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForCondExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForCondExpr(s)
	}
}

func (s *ForCondExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForCondExpr(s)
	}
}

func (s *ForCondExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForCondExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForCondEmptyContext struct {
	ForCondContext
}

func NewForCondEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForCondEmptyContext {
	var p = new(ForCondEmptyContext)

	InitEmptyForCondContext(&p.ForCondContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForCondContext))

	return p
}

func (s *ForCondEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForCondEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForCondEmpty(s)
	}
}

func (s *ForCondEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForCondEmpty(s)
	}
}

func (s *ForCondEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForCondEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForCond() (localctx IForCondContext) {
	localctx = NewForCondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ManuscriptRULE_forCond)
	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptFN, ManuscriptVOID, ManuscriptTRY, ManuscriptNULL, ManuscriptTRUE, ManuscriptFALSE, ManuscriptMATCH, ManuscriptASYNC, ManuscriptAWAIT, ManuscriptLBRACE, ManuscriptLSQBR, ManuscriptLPAREN, ManuscriptLT, ManuscriptPLUS, ManuscriptMINUS, ManuscriptEXCLAMATION, ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER, ManuscriptID, ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewForCondExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(689)
			p.Expr()
		}

	case ManuscriptSEMICOLON:
		localctx = NewForCondEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForPostContext is an interface to support dynamic dispatch.
type IForPostContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsForPostContext differentiates from other interfaces.
	IsForPostContext()
}

type ForPostContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForPostContext() *ForPostContext {
	var p = new(ForPostContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
	return p
}

func InitEmptyForPostContext(p *ForPostContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_forPost
}

func (*ForPostContext) IsForPostContext() {}

func NewForPostContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForPostContext {
	var p = new(ForPostContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_forPost

	return p
}

func (s *ForPostContext) GetParser() antlr.Parser { return s.parser }

func (s *ForPostContext) CopyAll(ctx *ForPostContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ForPostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ForPostEmptyContext struct {
	ForPostContext
}

func NewForPostEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForPostEmptyContext {
	var p = new(ForPostEmptyContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *ForPostEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForPostEmpty(s)
	}
}

func (s *ForPostEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForPostEmpty(s)
	}
}

func (s *ForPostEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForPostEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type ForPostExprContext struct {
	ForPostContext
}

func NewForPostExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ForPostExprContext {
	var p = new(ForPostExprContext)

	InitEmptyForPostContext(&p.ForPostContext)
	p.parser = parser
	p.CopyAll(ctx.(*ForPostContext))

	return p
}

func (s *ForPostExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForPostExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForPostExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterForPostExpr(s)
	}
}

func (s *ForPostExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitForPostExpr(s)
	}
}

func (s *ForPostExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitForPostExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ForPost() (localctx IForPostContext) {
	localctx = NewForPostContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ManuscriptRULE_forPost)
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		localctx = NewForPostExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)
			p.Expr()
		}

	case 2:
		localctx = NewForPostEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStmtContext is an interface to support dynamic dispatch.
type IWhileStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	LoopBody() ILoopBodyContext

	// IsWhileStmtContext differentiates from other interfaces.
	IsWhileStmtContext()
}

type WhileStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStmtContext() *WhileStmtContext {
	var p = new(WhileStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
	return p
}

func InitEmptyWhileStmtContext(p *WhileStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_whileStmt
}

func (*WhileStmtContext) IsWhileStmtContext() {}

func NewWhileStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStmtContext {
	var p = new(WhileStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_whileStmt

	return p
}

func (s *WhileStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStmtContext) WHILE() antlr.TerminalNode {
	return s.GetToken(ManuscriptWHILE, 0)
}

func (s *WhileStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileStmtContext) LoopBody() ILoopBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBodyContext)
}

func (s *WhileStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterWhileStmt(s)
	}
}

func (s *WhileStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitWhileStmt(s)
	}
}

func (s *WhileStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitWhileStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) WhileStmt() (localctx IWhileStmtContext) {
	localctx = NewWhileStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ManuscriptRULE_whileStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.Match(ManuscriptWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)
		p.Expr()
	}
	{
		p.SetState(699)
		p.LoopBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBodyContext is an interface to support dynamic dispatch.
type ILoopBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsLoopBodyContext differentiates from other interfaces.
	IsLoopBodyContext()
}

type LoopBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopBodyContext() *LoopBodyContext {
	var p = new(LoopBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
	return p
}

func InitEmptyLoopBodyContext(p *LoopBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_loopBody
}

func (*LoopBodyContext) IsLoopBodyContext() {}

func NewLoopBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBodyContext {
	var p = new(LoopBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_loopBody

	return p
}

func (s *LoopBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBodyContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *LoopBodyContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *LoopBodyContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *LoopBodyContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *LoopBodyContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *LoopBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLoopBody(s)
	}
}

func (s *LoopBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLoopBody(s)
	}
}

func (s *LoopBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLoopBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LoopBody() (localctx ILoopBodyContext) {
	localctx = NewLoopBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ManuscriptRULE_loopBody)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(705)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(702)
					p.Stmt_sep()
				}

				p.SetState(707)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(708)
				p.Stmt()
			}

		}
		p.SetState(713)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(714)
			p.Stmt_sep()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(720)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStmt() []IStmtContext
	Stmt(i int) IStmtContext
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
	return p
}

func InitEmptyCodeBlockContext(p *CodeBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_codeBlock
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *CodeBlockContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *CodeBlockContext) AllStmt() []IStmtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmtContext); ok {
			len++
		}
	}

	tst := make([]IStmtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmtContext); ok {
			tst[i] = t.(IStmtContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt(i int) IStmtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmtContext)
}

func (s *CodeBlockContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (s *CodeBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCodeBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CodeBlock() (localctx ICodeBlockContext) {
	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ManuscriptRULE_codeBlock)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(722)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(726)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(723)
					p.Stmt_sep()
				}

				p.SetState(728)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(729)
				p.Stmt()
			}

		}
		p.SetState(734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(735)
			p.Stmt_sep()
		}

		p.SetState(740)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(741)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStmtContext is an interface to support dynamic dispatch.
type IBreakStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStmtContext differentiates from other interfaces.
	IsBreakStmtContext()
}

type BreakStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStmtContext() *BreakStmtContext {
	var p = new(BreakStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
	return p
}

func InitEmptyBreakStmtContext(p *BreakStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_breakStmt
}

func (*BreakStmtContext) IsBreakStmtContext() {}

func NewBreakStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStmtContext {
	var p = new(BreakStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_breakStmt

	return p
}

func (s *BreakStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStmtContext) BREAK() antlr.TerminalNode {
	return s.GetToken(ManuscriptBREAK, 0)
}

func (s *BreakStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *BreakStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBreakStmt(s)
	}
}

func (s *BreakStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBreakStmt(s)
	}
}

func (s *BreakStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBreakStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BreakStmt() (localctx IBreakStmtContext) {
	localctx = NewBreakStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ManuscriptRULE_breakStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.Match(ManuscriptBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(745)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(744)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStmtContext is an interface to support dynamic dispatch.
type IContinueStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStmtContext differentiates from other interfaces.
	IsContinueStmtContext()
}

type ContinueStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStmtContext() *ContinueStmtContext {
	var p = new(ContinueStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
	return p
}

func InitEmptyContinueStmtContext(p *ContinueStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_continueStmt
}

func (*ContinueStmtContext) IsContinueStmtContext() {}

func NewContinueStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStmtContext {
	var p = new(ContinueStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_continueStmt

	return p
}

func (s *ContinueStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStmtContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptCONTINUE, 0)
}

func (s *ContinueStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *ContinueStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterContinueStmt(s)
	}
}

func (s *ContinueStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitContinueStmt(s)
	}
}

func (s *ContinueStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitContinueStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ContinueStmt() (localctx IContinueStmtContext) {
	localctx = NewContinueStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ManuscriptRULE_continueStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(747)
		p.Match(ManuscriptCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(749)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(748)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckStmtContext is an interface to support dynamic dispatch.
type ICheckStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK() antlr.TerminalNode
	Expr() IExprContext
	COMMA() antlr.TerminalNode
	StringLiteral() IStringLiteralContext
	SEMICOLON() antlr.TerminalNode

	// IsCheckStmtContext differentiates from other interfaces.
	IsCheckStmtContext()
}

type CheckStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckStmtContext() *CheckStmtContext {
	var p = new(CheckStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
	return p
}

func InitEmptyCheckStmtContext(p *CheckStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_checkStmt
}

func (*CheckStmtContext) IsCheckStmtContext() {}

func NewCheckStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckStmtContext {
	var p = new(CheckStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_checkStmt

	return p
}

func (s *CheckStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckStmtContext) CHECK() antlr.TerminalNode {
	return s.GetToken(ManuscriptCHECK, 0)
}

func (s *CheckStmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CheckStmtContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, 0)
}

func (s *CheckStmtContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *CheckStmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CheckStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCheckStmt(s)
	}
}

func (s *CheckStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCheckStmt(s)
	}
}

func (s *CheckStmtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCheckStmt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CheckStmt() (localctx ICheckStmtContext) {
	localctx = NewCheckStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ManuscriptRULE_checkStmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.Match(ManuscriptCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(752)
		p.Expr()
	}
	{
		p.SetState(753)
		p.Match(ManuscriptCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(754)
		p.StringLiteral()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(755)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpr() IAssignmentExprContext

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (s *ExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Expr() (localctx IExprContext) {
	localctx = NewExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ManuscriptRULE_expr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.AssignmentExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExprContext is an interface to support dynamic dispatch.
type IAssignmentExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() ITernaryExprContext

	// GetOp returns the op rule contexts.
	GetOp() IAssignmentOpContext

	// GetRight returns the right rule contexts.
	GetRight() IAssignmentExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ITernaryExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IAssignmentOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IAssignmentExprContext)

	// Getter signatures
	TernaryExpr() ITernaryExprContext
	AssignmentOp() IAssignmentOpContext
	AssignmentExpr() IAssignmentExprContext

	// IsAssignmentExprContext differentiates from other interfaces.
	IsAssignmentExprContext()
}

type AssignmentExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ITernaryExprContext
	op     IAssignmentOpContext
	right  IAssignmentExprContext
}

func NewEmptyAssignmentExprContext() *AssignmentExprContext {
	var p = new(AssignmentExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
	return p
}

func InitEmptyAssignmentExprContext(p *AssignmentExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentExpr
}

func (*AssignmentExprContext) IsAssignmentExprContext() {}

func NewAssignmentExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExprContext {
	var p = new(AssignmentExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentExpr

	return p
}

func (s *AssignmentExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExprContext) GetLeft() ITernaryExprContext { return s.left }

func (s *AssignmentExprContext) GetOp() IAssignmentOpContext { return s.op }

func (s *AssignmentExprContext) GetRight() IAssignmentExprContext { return s.right }

func (s *AssignmentExprContext) SetLeft(v ITernaryExprContext) { s.left = v }

func (s *AssignmentExprContext) SetOp(v IAssignmentOpContext) { s.op = v }

func (s *AssignmentExprContext) SetRight(v IAssignmentExprContext) { s.right = v }

func (s *AssignmentExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *AssignmentExprContext) AssignmentOp() IAssignmentOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOpContext)
}

func (s *AssignmentExprContext) AssignmentExpr() IAssignmentExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExprContext)
}

func (s *AssignmentExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignmentExpr(s)
	}
}

func (s *AssignmentExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignmentExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentExpr() (localctx IAssignmentExprContext) {
	localctx = NewAssignmentExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ManuscriptRULE_assignmentExpr)
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(760)
			p.TernaryExpr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(761)

			var _x = p.TernaryExpr()

			localctx.(*AssignmentExprContext).left = _x
		}
		{
			p.SetState(762)

			var _x = p.AssignmentOp()

			localctx.(*AssignmentExprContext).op = _x
		}
		{
			p.SetState(763)

			var _x = p.AssignmentExpr()

			localctx.(*AssignmentExprContext).right = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOpContext is an interface to support dynamic dispatch.
type IAssignmentOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAssignmentOpContext differentiates from other interfaces.
	IsAssignmentOpContext()
}

type AssignmentOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOpContext() *AssignmentOpContext {
	var p = new(AssignmentOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
	return p
}

func InitEmptyAssignmentOpContext(p *AssignmentOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_assignmentOp
}

func (*AssignmentOpContext) IsAssignmentOpContext() {}

func NewAssignmentOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOpContext {
	var p = new(AssignmentOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_assignmentOp

	return p
}

func (s *AssignmentOpContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOpContext) CopyAll(ctx *AssignmentOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AssignmentOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssignStarEqContext struct {
	AssignmentOpContext
}

func NewAssignStarEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignStarEqContext {
	var p = new(AssignStarEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignStarEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignStarEqContext) STAR_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR_EQUALS, 0)
}

func (s *AssignStarEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignStarEq(s)
	}
}

func (s *AssignStarEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignStarEq(s)
	}
}

func (s *AssignStarEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignStarEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignMinusEqContext struct {
	AssignmentOpContext
}

func NewAssignMinusEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignMinusEqContext {
	var p = new(AssignMinusEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignMinusEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignMinusEqContext) MINUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS_EQUALS, 0)
}

func (s *AssignMinusEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignMinusEq(s)
	}
}

func (s *AssignMinusEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignMinusEq(s)
	}
}

func (s *AssignMinusEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignMinusEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignEqContext struct {
	AssignmentOpContext
}

func NewAssignEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignEqContext {
	var p = new(AssignEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignEqContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS, 0)
}

func (s *AssignEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignEq(s)
	}
}

func (s *AssignEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignEq(s)
	}
}

func (s *AssignEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignCaretEqContext struct {
	AssignmentOpContext
}

func NewAssignCaretEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignCaretEqContext {
	var p = new(AssignCaretEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignCaretEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignCaretEqContext) CARET_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET_EQUALS, 0)
}

func (s *AssignCaretEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignCaretEq(s)
	}
}

func (s *AssignCaretEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignCaretEq(s)
	}
}

func (s *AssignCaretEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignCaretEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignPlusEqContext struct {
	AssignmentOpContext
}

func NewAssignPlusEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignPlusEqContext {
	var p = new(AssignPlusEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignPlusEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignPlusEqContext) PLUS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS_EQUALS, 0)
}

func (s *AssignPlusEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignPlusEq(s)
	}
}

func (s *AssignPlusEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignPlusEq(s)
	}
}

func (s *AssignPlusEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignPlusEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignSlashEqContext struct {
	AssignmentOpContext
}

func NewAssignSlashEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignSlashEqContext {
	var p = new(AssignSlashEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignSlashEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignSlashEqContext) SLASH_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH_EQUALS, 0)
}

func (s *AssignSlashEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignSlashEq(s)
	}
}

func (s *AssignSlashEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignSlashEq(s)
	}
}

func (s *AssignSlashEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignSlashEq(s)

	default:
		return t.VisitChildren(s)
	}
}

type AssignModEqContext struct {
	AssignmentOpContext
}

func NewAssignModEqContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssignModEqContext {
	var p = new(AssignModEqContext)

	InitEmptyAssignmentOpContext(&p.AssignmentOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*AssignmentOpContext))

	return p
}

func (s *AssignModEqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignModEqContext) MOD_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD_EQUALS, 0)
}

func (s *AssignModEqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAssignModEq(s)
	}
}

func (s *AssignModEqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAssignModEq(s)
	}
}

func (s *AssignModEqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAssignModEq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AssignmentOp() (localctx IAssignmentOpContext) {
	localctx = NewAssignmentOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ManuscriptRULE_assignmentOp)
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptEQUALS:
		localctx = NewAssignEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(767)
			p.Match(ManuscriptEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptPLUS_EQUALS:
		localctx = NewAssignPlusEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(768)
			p.Match(ManuscriptPLUS_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMINUS_EQUALS:
		localctx = NewAssignMinusEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(769)
			p.Match(ManuscriptMINUS_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSTAR_EQUALS:
		localctx = NewAssignStarEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(770)
			p.Match(ManuscriptSTAR_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSLASH_EQUALS:
		localctx = NewAssignSlashEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(771)
			p.Match(ManuscriptSLASH_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMOD_EQUALS:
		localctx = NewAssignModEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(772)
			p.Match(ManuscriptMOD_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptCARET_EQUALS:
		localctx = NewAssignCaretEqContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(773)
			p.Match(ManuscriptCARET_EQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryExprContext is an interface to support dynamic dispatch.
type ITernaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCond returns the cond rule contexts.
	GetCond() ILogicalOrExprContext

	// GetThenBranch returns the thenBranch rule contexts.
	GetThenBranch() IExprContext

	// GetElseExpr returns the elseExpr rule contexts.
	GetElseExpr() ITernaryExprContext

	// SetCond sets the cond rule contexts.
	SetCond(ILogicalOrExprContext)

	// SetThenBranch sets the thenBranch rule contexts.
	SetThenBranch(IExprContext)

	// SetElseExpr sets the elseExpr rule contexts.
	SetElseExpr(ITernaryExprContext)

	// Getter signatures
	LogicalOrExpr() ILogicalOrExprContext
	QUESTION() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	TernaryExpr() ITernaryExprContext

	// IsTernaryExprContext differentiates from other interfaces.
	IsTernaryExprContext()
}

type TernaryExprContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	cond       ILogicalOrExprContext
	thenBranch IExprContext
	elseExpr   ITernaryExprContext
}

func NewEmptyTernaryExprContext() *TernaryExprContext {
	var p = new(TernaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
	return p
}

func InitEmptyTernaryExprContext(p *TernaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_ternaryExpr
}

func (*TernaryExprContext) IsTernaryExprContext() {}

func NewTernaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryExprContext {
	var p = new(TernaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_ternaryExpr

	return p
}

func (s *TernaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryExprContext) GetCond() ILogicalOrExprContext { return s.cond }

func (s *TernaryExprContext) GetThenBranch() IExprContext { return s.thenBranch }

func (s *TernaryExprContext) GetElseExpr() ITernaryExprContext { return s.elseExpr }

func (s *TernaryExprContext) SetCond(v ILogicalOrExprContext) { s.cond = v }

func (s *TernaryExprContext) SetThenBranch(v IExprContext) { s.thenBranch = v }

func (s *TernaryExprContext) SetElseExpr(v ITernaryExprContext) { s.elseExpr = v }

func (s *TernaryExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *TernaryExprContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ManuscriptQUESTION, 0)
}

func (s *TernaryExprContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *TernaryExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TernaryExprContext) TernaryExpr() ITernaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryExprContext)
}

func (s *TernaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTernaryExpr(s)
	}
}

func (s *TernaryExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTernaryExpr(s)
	}
}

func (s *TernaryExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTernaryExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TernaryExpr() (localctx ITernaryExprContext) {
	localctx = NewTernaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ManuscriptRULE_ternaryExpr)
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(776)
			p.logicalOrExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(777)

			var _x = p.logicalOrExpr(0)

			localctx.(*TernaryExprContext).cond = _x
		}
		{
			p.SetState(778)
			p.Match(ManuscriptQUESTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(779)

			var _x = p.Expr()

			localctx.(*TernaryExprContext).thenBranch = _x
		}
		{
			p.SetState(780)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)

			var _x = p.TernaryExpr()

			localctx.(*TernaryExprContext).elseExpr = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExprContext is an interface to support dynamic dispatch.
type ILogicalOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() ILogicalAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(ILogicalAndExprContext)

	// Getter signatures
	LogicalAndExpr() ILogicalAndExprContext
	LogicalOrExpr() ILogicalOrExprContext
	PIPE_PIPE() antlr.TerminalNode

	// IsLogicalOrExprContext differentiates from other interfaces.
	IsLogicalOrExprContext()
}

type LogicalOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalOrExprContext
	op     antlr.Token
	right  ILogicalAndExprContext
}

func NewEmptyLogicalOrExprContext() *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
	return p
}

func InitEmptyLogicalOrExprContext(p *LogicalOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalOrExpr
}

func (*LogicalOrExprContext) IsLogicalOrExprContext() {}

func NewLogicalOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExprContext {
	var p = new(LogicalOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalOrExpr

	return p
}

func (s *LogicalOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExprContext) GetLeft() ILogicalOrExprContext { return s.left }

func (s *LogicalOrExprContext) GetRight() ILogicalAndExprContext { return s.right }

func (s *LogicalOrExprContext) SetLeft(v ILogicalOrExprContext) { s.left = v }

func (s *LogicalOrExprContext) SetRight(v ILogicalAndExprContext) { s.right = v }

func (s *LogicalOrExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalOrExprContext) LogicalOrExpr() ILogicalOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExprContext)
}

func (s *LogicalOrExprContext) PIPE_PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE_PIPE, 0)
}

func (s *LogicalOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalOrExpr(s)
	}
}

func (s *LogicalOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalOrExpr() (localctx ILogicalOrExprContext) {
	return p.logicalOrExpr(0)
}

func (p *Manuscript) logicalOrExpr(_p int) (localctx ILogicalOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, ManuscriptRULE_logicalOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(786)
		p.logicalAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalOrExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalOrExpr)
			p.SetState(788)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(789)

				var _m = p.Match(ManuscriptPIPE_PIPE)

				localctx.(*LogicalOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(790)

				var _x = p.logicalAndExpr(0)

				localctx.(*LogicalOrExprContext).right = _x
			}

		}
		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExprContext is an interface to support dynamic dispatch.
type ILogicalAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() ILogicalAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseOrExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(ILogicalAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseOrExprContext)

	// Getter signatures
	BitwiseOrExpr() IBitwiseOrExprContext
	LogicalAndExpr() ILogicalAndExprContext
	AMP_AMP() antlr.TerminalNode

	// IsLogicalAndExprContext differentiates from other interfaces.
	IsLogicalAndExprContext()
}

type LogicalAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   ILogicalAndExprContext
	op     antlr.Token
	right  IBitwiseOrExprContext
}

func NewEmptyLogicalAndExprContext() *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
	return p
}

func InitEmptyLogicalAndExprContext(p *LogicalAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_logicalAndExpr
}

func (*LogicalAndExprContext) IsLogicalAndExprContext() {}

func NewLogicalAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExprContext {
	var p = new(LogicalAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_logicalAndExpr

	return p
}

func (s *LogicalAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExprContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExprContext) GetLeft() ILogicalAndExprContext { return s.left }

func (s *LogicalAndExprContext) GetRight() IBitwiseOrExprContext { return s.right }

func (s *LogicalAndExprContext) SetLeft(v ILogicalAndExprContext) { s.left = v }

func (s *LogicalAndExprContext) SetRight(v IBitwiseOrExprContext) { s.right = v }

func (s *LogicalAndExprContext) BitwiseOrExpr() IBitwiseOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExprContext)
}

func (s *LogicalAndExprContext) LogicalAndExpr() ILogicalAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExprContext)
}

func (s *LogicalAndExprContext) AMP_AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP_AMP, 0)
}

func (s *LogicalAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLogicalAndExpr(s)
	}
}

func (s *LogicalAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLogicalAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) LogicalAndExpr() (localctx ILogicalAndExprContext) {
	return p.logicalAndExpr(0)
}

func (p *Manuscript) logicalAndExpr(_p int) (localctx ILogicalAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewLogicalAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ILogicalAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, ManuscriptRULE_logicalAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(797)
		p.bitwiseOrExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewLogicalAndExprContext(p, _parentctx, _parentState)
			localctx.(*LogicalAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_logicalAndExpr)
			p.SetState(799)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(800)

				var _m = p.Match(ManuscriptAMP_AMP)

				localctx.(*LogicalAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(801)

				var _x = p.bitwiseOrExpr(0)

				localctx.(*LogicalAndExprContext).right = _x
			}

		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseOrExprContext is an interface to support dynamic dispatch.
type IBitwiseOrExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseOrExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseXorExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseOrExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseXorExprContext)

	// Getter signatures
	BitwiseXorExpr() IBitwiseXorExprContext
	BitwiseOrExpr() IBitwiseOrExprContext
	PIPE() antlr.TerminalNode

	// IsBitwiseOrExprContext differentiates from other interfaces.
	IsBitwiseOrExprContext()
}

type BitwiseOrExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseOrExprContext
	op     antlr.Token
	right  IBitwiseXorExprContext
}

func NewEmptyBitwiseOrExprContext() *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
	return p
}

func InitEmptyBitwiseOrExprContext(p *BitwiseOrExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr
}

func (*BitwiseOrExprContext) IsBitwiseOrExprContext() {}

func NewBitwiseOrExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseOrExprContext {
	var p = new(BitwiseOrExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseOrExpr

	return p
}

func (s *BitwiseOrExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseOrExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrExprContext) GetLeft() IBitwiseOrExprContext { return s.left }

func (s *BitwiseOrExprContext) GetRight() IBitwiseXorExprContext { return s.right }

func (s *BitwiseOrExprContext) SetLeft(v IBitwiseOrExprContext) { s.left = v }

func (s *BitwiseOrExprContext) SetRight(v IBitwiseXorExprContext) { s.right = v }

func (s *BitwiseOrExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseOrExprContext) BitwiseOrExpr() IBitwiseOrExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseOrExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseOrExprContext)
}

func (s *BitwiseOrExprContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ManuscriptPIPE, 0)
}

func (s *BitwiseOrExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseOrExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseOrExpr(s)
	}
}

func (s *BitwiseOrExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseOrExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseOrExpr() (localctx IBitwiseOrExprContext) {
	return p.bitwiseOrExpr(0)
}

func (p *Manuscript) bitwiseOrExpr(_p int) (localctx IBitwiseOrExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseOrExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseOrExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 124
	p.EnterRecursionRule(localctx, 124, ManuscriptRULE_bitwiseOrExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.bitwiseXorExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseOrExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseOrExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseOrExpr)
			p.SetState(810)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(811)

				var _m = p.Match(ManuscriptPIPE)

				localctx.(*BitwiseOrExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(812)

				var _x = p.bitwiseXorExpr(0)

				localctx.(*BitwiseOrExprContext).right = _x
			}

		}
		p.SetState(817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseXorExprContext is an interface to support dynamic dispatch.
type IBitwiseXorExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseXorExprContext

	// GetRight returns the right rule contexts.
	GetRight() IBitwiseAndExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseXorExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IBitwiseAndExprContext)

	// Getter signatures
	BitwiseAndExpr() IBitwiseAndExprContext
	BitwiseXorExpr() IBitwiseXorExprContext
	CARET() antlr.TerminalNode

	// IsBitwiseXorExprContext differentiates from other interfaces.
	IsBitwiseXorExprContext()
}

type BitwiseXorExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseXorExprContext
	op     antlr.Token
	right  IBitwiseAndExprContext
}

func NewEmptyBitwiseXorExprContext() *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
	return p
}

func InitEmptyBitwiseXorExprContext(p *BitwiseXorExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr
}

func (*BitwiseXorExprContext) IsBitwiseXorExprContext() {}

func NewBitwiseXorExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseXorExprContext {
	var p = new(BitwiseXorExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseXorExpr

	return p
}

func (s *BitwiseXorExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseXorExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExprContext) GetLeft() IBitwiseXorExprContext { return s.left }

func (s *BitwiseXorExprContext) GetRight() IBitwiseAndExprContext { return s.right }

func (s *BitwiseXorExprContext) SetLeft(v IBitwiseXorExprContext) { s.left = v }

func (s *BitwiseXorExprContext) SetRight(v IBitwiseAndExprContext) { s.right = v }

func (s *BitwiseXorExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseXorExprContext) BitwiseXorExpr() IBitwiseXorExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseXorExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseXorExprContext)
}

func (s *BitwiseXorExprContext) CARET() antlr.TerminalNode {
	return s.GetToken(ManuscriptCARET, 0)
}

func (s *BitwiseXorExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseXorExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseXorExpr(s)
	}
}

func (s *BitwiseXorExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseXorExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseXorExpr() (localctx IBitwiseXorExprContext) {
	return p.bitwiseXorExpr(0)
}

func (p *Manuscript) bitwiseXorExpr(_p int) (localctx IBitwiseXorExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseXorExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseXorExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, ManuscriptRULE_bitwiseXorExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(819)
		p.bitwiseAndExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseXorExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseXorExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseXorExpr)
			p.SetState(821)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(822)

				var _m = p.Match(ManuscriptCARET)

				localctx.(*BitwiseXorExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(823)

				var _x = p.bitwiseAndExpr(0)

				localctx.(*BitwiseXorExprContext).right = _x
			}

		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitwiseAndExprContext is an interface to support dynamic dispatch.
type IBitwiseAndExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IBitwiseAndExprContext

	// GetRight returns the right rule contexts.
	GetRight() IEqualityExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IBitwiseAndExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IEqualityExprContext)

	// Getter signatures
	EqualityExpr() IEqualityExprContext
	BitwiseAndExpr() IBitwiseAndExprContext
	AMP() antlr.TerminalNode

	// IsBitwiseAndExprContext differentiates from other interfaces.
	IsBitwiseAndExprContext()
}

type BitwiseAndExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IBitwiseAndExprContext
	op     antlr.Token
	right  IEqualityExprContext
}

func NewEmptyBitwiseAndExprContext() *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
	return p
}

func InitEmptyBitwiseAndExprContext(p *BitwiseAndExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr
}

func (*BitwiseAndExprContext) IsBitwiseAndExprContext() {}

func NewBitwiseAndExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitwiseAndExprContext {
	var p = new(BitwiseAndExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_bitwiseAndExpr

	return p
}

func (s *BitwiseAndExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitwiseAndExprContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExprContext) GetLeft() IBitwiseAndExprContext { return s.left }

func (s *BitwiseAndExprContext) GetRight() IEqualityExprContext { return s.right }

func (s *BitwiseAndExprContext) SetLeft(v IBitwiseAndExprContext) { s.left = v }

func (s *BitwiseAndExprContext) SetRight(v IEqualityExprContext) { s.right = v }

func (s *BitwiseAndExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *BitwiseAndExprContext) BitwiseAndExpr() IBitwiseAndExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitwiseAndExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitwiseAndExprContext)
}

func (s *BitwiseAndExprContext) AMP() antlr.TerminalNode {
	return s.GetToken(ManuscriptAMP, 0)
}

func (s *BitwiseAndExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitwiseAndExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBitwiseAndExpr(s)
	}
}

func (s *BitwiseAndExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBitwiseAndExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BitwiseAndExpr() (localctx IBitwiseAndExprContext) {
	return p.bitwiseAndExpr(0)
}

func (p *Manuscript) bitwiseAndExpr(_p int) (localctx IBitwiseAndExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitwiseAndExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitwiseAndExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 128
	p.EnterRecursionRule(localctx, 128, ManuscriptRULE_bitwiseAndExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.equalityExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewBitwiseAndExprContext(p, _parentctx, _parentState)
			localctx.(*BitwiseAndExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_bitwiseAndExpr)
			p.SetState(832)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(833)

				var _m = p.Match(ManuscriptAMP)

				localctx.(*BitwiseAndExprContext).op = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(834)

				var _x = p.equalityExpr(0)

				localctx.(*BitwiseAndExprContext).right = _x
			}

		}
		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExprContext is an interface to support dynamic dispatch.
type IEqualityExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IEqualityExprContext

	// GetRight returns the right rule contexts.
	GetRight() IComparisonExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IEqualityExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IComparisonExprContext)

	// Getter signatures
	ComparisonExpr() IComparisonExprContext
	EqualityExpr() IEqualityExprContext
	EQUALS_EQUALS() antlr.TerminalNode
	NEQ() antlr.TerminalNode

	// IsEqualityExprContext differentiates from other interfaces.
	IsEqualityExprContext()
}

type EqualityExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IEqualityExprContext
	op     antlr.Token
	right  IComparisonExprContext
}

func NewEmptyEqualityExprContext() *EqualityExprContext {
	var p = new(EqualityExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
	return p
}

func InitEmptyEqualityExprContext(p *EqualityExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_equalityExpr
}

func (*EqualityExprContext) IsEqualityExprContext() {}

func NewEqualityExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExprContext {
	var p = new(EqualityExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_equalityExpr

	return p
}

func (s *EqualityExprContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExprContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExprContext) GetLeft() IEqualityExprContext { return s.left }

func (s *EqualityExprContext) GetRight() IComparisonExprContext { return s.right }

func (s *EqualityExprContext) SetLeft(v IEqualityExprContext) { s.left = v }

func (s *EqualityExprContext) SetRight(v IComparisonExprContext) { s.right = v }

func (s *EqualityExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *EqualityExprContext) EqualityExpr() IEqualityExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExprContext)
}

func (s *EqualityExprContext) EQUALS_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptEQUALS_EQUALS, 0)
}

func (s *EqualityExprContext) NEQ() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEQ, 0)
}

func (s *EqualityExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterEqualityExpr(s)
	}
}

func (s *EqualityExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitEqualityExpr(s)
	}
}

func (s *EqualityExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitEqualityExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) EqualityExpr() (localctx IEqualityExprContext) {
	return p.equalityExpr(0)
}

func (p *Manuscript) equalityExpr(_p int) (localctx IEqualityExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewEqualityExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IEqualityExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 130
	p.EnterRecursionRule(localctx, 130, ManuscriptRULE_equalityExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.comparisonExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewEqualityExprContext(p, _parentctx, _parentState)
			localctx.(*EqualityExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_equalityExpr)
			p.SetState(843)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(844)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*EqualityExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptEQUALS_EQUALS || _la == ManuscriptNEQ) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*EqualityExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(845)

				var _x = p.comparisonExpr(0)

				localctx.(*EqualityExprContext).right = _x
			}

		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOpContext is an interface to support dynamic dispatch.
type IComparisonOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	LT_EQUALS() antlr.TerminalNode
	GT() antlr.TerminalNode
	GT_EQUALS() antlr.TerminalNode

	// IsComparisonOpContext differentiates from other interfaces.
	IsComparisonOpContext()
}

type ComparisonOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOpContext() *ComparisonOpContext {
	var p = new(ComparisonOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
	return p
}

func InitEmptyComparisonOpContext(p *ComparisonOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonOp
}

func (*ComparisonOpContext) IsComparisonOpContext() {}

func NewComparisonOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOpContext {
	var p = new(ComparisonOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonOp

	return p
}

func (s *ComparisonOpContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOpContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *ComparisonOpContext) LT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT_EQUALS, 0)
}

func (s *ComparisonOpContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *ComparisonOpContext) GT_EQUALS() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT_EQUALS, 0)
}

func (s *ComparisonOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonOp(s)
	}
}

func (s *ComparisonOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonOp(s)
	}
}

func (s *ComparisonOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonOp() (localctx IComparisonOpContext) {
	localctx = NewComparisonOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ManuscriptRULE_comparisonOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(851)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1055531162664960) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExprContext is an interface to support dynamic dispatch.
type IComparisonExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLeft returns the left rule contexts.
	GetLeft() IComparisonExprContext

	// GetOp returns the op rule contexts.
	GetOp() IComparisonOpContext

	// GetRight returns the right rule contexts.
	GetRight() IShiftExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IComparisonExprContext)

	// SetOp sets the op rule contexts.
	SetOp(IComparisonOpContext)

	// SetRight sets the right rule contexts.
	SetRight(IShiftExprContext)

	// Getter signatures
	ShiftExpr() IShiftExprContext
	ComparisonExpr() IComparisonExprContext
	ComparisonOp() IComparisonOpContext

	// IsComparisonExprContext differentiates from other interfaces.
	IsComparisonExprContext()
}

type ComparisonExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IComparisonExprContext
	op     IComparisonOpContext
	right  IShiftExprContext
}

func NewEmptyComparisonExprContext() *ComparisonExprContext {
	var p = new(ComparisonExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
	return p
}

func InitEmptyComparisonExprContext(p *ComparisonExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_comparisonExpr
}

func (*ComparisonExprContext) IsComparisonExprContext() {}

func NewComparisonExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExprContext {
	var p = new(ComparisonExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_comparisonExpr

	return p
}

func (s *ComparisonExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExprContext) GetLeft() IComparisonExprContext { return s.left }

func (s *ComparisonExprContext) GetOp() IComparisonOpContext { return s.op }

func (s *ComparisonExprContext) GetRight() IShiftExprContext { return s.right }

func (s *ComparisonExprContext) SetLeft(v IComparisonExprContext) { s.left = v }

func (s *ComparisonExprContext) SetOp(v IComparisonOpContext) { s.op = v }

func (s *ComparisonExprContext) SetRight(v IShiftExprContext) { s.right = v }

func (s *ComparisonExprContext) ShiftExpr() IShiftExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ComparisonExprContext) ComparisonExpr() IComparisonExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExprContext)
}

func (s *ComparisonExprContext) ComparisonOp() IComparisonOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOpContext)
}

func (s *ComparisonExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitComparisonExpr(s)
	}
}

func (s *ComparisonExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitComparisonExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ComparisonExpr() (localctx IComparisonExprContext) {
	return p.comparisonExpr(0)
}

func (p *Manuscript) comparisonExpr(_p int) (localctx IComparisonExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewComparisonExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IComparisonExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, ManuscriptRULE_comparisonExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(854)
		p.shiftExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewComparisonExprContext(p, _parentctx, _parentState)
			localctx.(*ComparisonExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_comparisonExpr)
			p.SetState(856)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(857)

				var _x = p.ComparisonOp()

				localctx.(*ComparisonExprContext).op = _x
			}
			{
				p.SetState(858)

				var _x = p.shiftExpr(0)

				localctx.(*ComparisonExprContext).right = _x
			}

		}
		p.SetState(864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExprContext is an interface to support dynamic dispatch.
type IShiftExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IShiftExprContext

	// GetRight returns the right rule contexts.
	GetRight() IAdditiveExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IShiftExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IAdditiveExprContext)

	// Getter signatures
	AdditiveExpr() IAdditiveExprContext
	ShiftExpr() IShiftExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsShiftExprContext differentiates from other interfaces.
	IsShiftExprContext()
}

type ShiftExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IShiftExprContext
	op     antlr.Token
	right  IAdditiveExprContext
}

func NewEmptyShiftExprContext() *ShiftExprContext {
	var p = new(ShiftExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
	return p
}

func InitEmptyShiftExprContext(p *ShiftExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_shiftExpr
}

func (*ShiftExprContext) IsShiftExprContext() {}

func NewShiftExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExprContext {
	var p = new(ShiftExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_shiftExpr

	return p
}

func (s *ShiftExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExprContext) GetOp() antlr.Token { return s.op }

func (s *ShiftExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ShiftExprContext) GetLeft() IShiftExprContext { return s.left }

func (s *ShiftExprContext) GetRight() IAdditiveExprContext { return s.right }

func (s *ShiftExprContext) SetLeft(v IShiftExprContext) { s.left = v }

func (s *ShiftExprContext) SetRight(v IAdditiveExprContext) { s.right = v }

func (s *ShiftExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *ShiftExprContext) ShiftExpr() IShiftExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExprContext)
}

func (s *ShiftExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *ShiftExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *ShiftExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterShiftExpr(s)
	}
}

func (s *ShiftExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitShiftExpr(s)
	}
}

func (s *ShiftExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitShiftExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ShiftExpr() (localctx IShiftExprContext) {
	return p.shiftExpr(0)
}

func (p *Manuscript) shiftExpr(_p int) (localctx IShiftExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewShiftExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IShiftExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 136
	p.EnterRecursionRule(localctx, 136, ManuscriptRULE_shiftExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.additiveExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewShiftExprContext(p, _parentctx, _parentState)
			localctx.(*ShiftExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_shiftExpr)
			p.SetState(868)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(869)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ShiftExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ShiftExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(870)

				var _x = p.additiveExpr(0)

				localctx.(*ShiftExprContext).right = _x
			}

		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExprContext is an interface to support dynamic dispatch.
type IAdditiveExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IAdditiveExprContext

	// GetRight returns the right rule contexts.
	GetRight() IMultiplicativeExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IAdditiveExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IMultiplicativeExprContext)

	// Getter signatures
	MultiplicativeExpr() IMultiplicativeExprContext
	AdditiveExpr() IAdditiveExprContext
	PLUS() antlr.TerminalNode
	MINUS() antlr.TerminalNode

	// IsAdditiveExprContext differentiates from other interfaces.
	IsAdditiveExprContext()
}

type AdditiveExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IAdditiveExprContext
	op     antlr.Token
	right  IMultiplicativeExprContext
}

func NewEmptyAdditiveExprContext() *AdditiveExprContext {
	var p = new(AdditiveExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
	return p
}

func InitEmptyAdditiveExprContext(p *AdditiveExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_additiveExpr
}

func (*AdditiveExprContext) IsAdditiveExprContext() {}

func NewAdditiveExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExprContext {
	var p = new(AdditiveExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_additiveExpr

	return p
}

func (s *AdditiveExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExprContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExprContext) GetLeft() IAdditiveExprContext { return s.left }

func (s *AdditiveExprContext) GetRight() IMultiplicativeExprContext { return s.right }

func (s *AdditiveExprContext) SetLeft(v IAdditiveExprContext) { s.left = v }

func (s *AdditiveExprContext) SetRight(v IMultiplicativeExprContext) { s.right = v }

func (s *AdditiveExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *AdditiveExprContext) AdditiveExpr() IAdditiveExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExprContext)
}

func (s *AdditiveExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *AdditiveExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *AdditiveExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAdditiveExpr(s)
	}
}

func (s *AdditiveExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAdditiveExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AdditiveExpr() (localctx IAdditiveExprContext) {
	return p.additiveExpr(0)
}

func (p *Manuscript) additiveExpr(_p int) (localctx IAdditiveExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewAdditiveExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IAdditiveExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 138
	p.EnterRecursionRule(localctx, 138, ManuscriptRULE_additiveExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.multiplicativeExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewAdditiveExprContext(p, _parentctx, _parentState)
			localctx.(*AdditiveExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_additiveExpr)
			p.SetState(879)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(880)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*AdditiveExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == ManuscriptPLUS || _la == ManuscriptMINUS) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*AdditiveExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(881)

				var _x = p.multiplicativeExpr(0)

				localctx.(*AdditiveExprContext).right = _x
			}

		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExprContext is an interface to support dynamic dispatch.
type IMultiplicativeExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IMultiplicativeExprContext

	// GetRight returns the right rule contexts.
	GetRight() IUnaryExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IMultiplicativeExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IUnaryExprContext)

	// Getter signatures
	UnaryExpr() IUnaryExprContext
	MultiplicativeExpr() IMultiplicativeExprContext
	STAR() antlr.TerminalNode
	SLASH() antlr.TerminalNode
	MOD() antlr.TerminalNode

	// IsMultiplicativeExprContext differentiates from other interfaces.
	IsMultiplicativeExprContext()
}

type MultiplicativeExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	left   IMultiplicativeExprContext
	op     antlr.Token
	right  IUnaryExprContext
}

func NewEmptyMultiplicativeExprContext() *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
	return p
}

func InitEmptyMultiplicativeExprContext(p *MultiplicativeExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr
}

func (*MultiplicativeExprContext) IsMultiplicativeExprContext() {}

func NewMultiplicativeExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExprContext {
	var p = new(MultiplicativeExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiplicativeExpr

	return p
}

func (s *MultiplicativeExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExprContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExprContext) GetLeft() IMultiplicativeExprContext { return s.left }

func (s *MultiplicativeExprContext) GetRight() IUnaryExprContext { return s.right }

func (s *MultiplicativeExprContext) SetLeft(v IMultiplicativeExprContext) { s.left = v }

func (s *MultiplicativeExprContext) SetRight(v IUnaryExprContext) { s.right = v }

func (s *MultiplicativeExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *MultiplicativeExprContext) MultiplicativeExpr() IMultiplicativeExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExprContext)
}

func (s *MultiplicativeExprContext) STAR() antlr.TerminalNode {
	return s.GetToken(ManuscriptSTAR, 0)
}

func (s *MultiplicativeExprContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ManuscriptSLASH, 0)
}

func (s *MultiplicativeExprContext) MOD() antlr.TerminalNode {
	return s.GetToken(ManuscriptMOD, 0)
}

func (s *MultiplicativeExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiplicativeExpr(s)
	}
}

func (s *MultiplicativeExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiplicativeExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiplicativeExpr() (localctx IMultiplicativeExprContext) {
	return p.multiplicativeExpr(0)
}

func (p *Manuscript) multiplicativeExpr(_p int) (localctx IMultiplicativeExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewMultiplicativeExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IMultiplicativeExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 140
	p.EnterRecursionRule(localctx, 140, ManuscriptRULE_multiplicativeExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(888)
		p.UnaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewMultiplicativeExprContext(p, _parentctx, _parentState)
			localctx.(*MultiplicativeExprContext).left = _prevctx
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_multiplicativeExpr)
			p.SetState(890)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(891)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*MultiplicativeExprContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2305843009213693952) != 0) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*MultiplicativeExprContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(892)

				var _x = p.UnaryExpr()

				localctx.(*MultiplicativeExprContext).right = _x
			}

		}
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExprContext is an interface to support dynamic dispatch.
type IUnaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUnaryExprContext differentiates from other interfaces.
	IsUnaryExprContext()
}

type UnaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExprContext() *UnaryExprContext {
	var p = new(UnaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
	return p
}

func InitEmptyUnaryExprContext(p *UnaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_unaryExpr
}

func (*UnaryExprContext) IsUnaryExprContext() {}

func NewUnaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExprContext {
	var p = new(UnaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_unaryExpr

	return p
}

func (s *UnaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExprContext) CopyAll(ctx *UnaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UnaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UnaryOpExprContext struct {
	UnaryExprContext
	op    antlr.Token
	unary IUnaryExprContext
}

func NewUnaryOpExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryOpExprContext {
	var p = new(UnaryOpExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *UnaryOpExprContext) GetOp() antlr.Token { return s.op }

func (s *UnaryOpExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryOpExprContext) GetUnary() IUnaryExprContext { return s.unary }

func (s *UnaryOpExprContext) SetUnary(v IUnaryExprContext) { s.unary = v }

func (s *UnaryOpExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOpExprContext) UnaryExpr() IUnaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExprContext)
}

func (s *UnaryOpExprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptPLUS, 0)
}

func (s *UnaryOpExprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(ManuscriptMINUS, 0)
}

func (s *UnaryOpExprContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ManuscriptEXCLAMATION, 0)
}

func (s *UnaryOpExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *UnaryOpExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterUnaryOpExpr(s)
	}
}

func (s *UnaryOpExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitUnaryOpExpr(s)
	}
}

func (s *UnaryOpExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitUnaryOpExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryAwaitExprContext struct {
	UnaryExprContext
}

func NewUnaryAwaitExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryAwaitExprContext {
	var p = new(UnaryAwaitExprContext)

	InitEmptyUnaryExprContext(&p.UnaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*UnaryExprContext))

	return p
}

func (s *UnaryAwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryAwaitExprContext) AwaitExpr() IAwaitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAwaitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAwaitExprContext)
}

func (s *UnaryAwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterUnaryAwaitExpr(s)
	}
}

func (s *UnaryAwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitUnaryAwaitExpr(s)
	}
}

func (s *UnaryAwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitUnaryAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) UnaryExpr() (localctx IUnaryExprContext) {
	localctx = NewUnaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ManuscriptRULE_unaryExpr)
	var _la int

	p.SetState(901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnaryOpExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(898)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryOpExprContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-16)) & ^0x3f) == 0 && ((int64(1)<<(_la-16))&283124244152321) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryOpExprContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(899)

			var _x = p.UnaryExpr()

			localctx.(*UnaryOpExprContext).unary = _x
		}

	case 2:
		localctx = NewUnaryAwaitExprContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.AwaitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAwaitExprContext is an interface to support dynamic dispatch.
type IAwaitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpr() IPostfixExprContext
	TRY() antlr.TerminalNode
	AWAIT() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAwaitExprContext differentiates from other interfaces.
	IsAwaitExprContext()
}

type AwaitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAwaitExprContext() *AwaitExprContext {
	var p = new(AwaitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
	return p
}

func InitEmptyAwaitExprContext(p *AwaitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_awaitExpr
}

func (*AwaitExprContext) IsAwaitExprContext() {}

func NewAwaitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AwaitExprContext {
	var p = new(AwaitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_awaitExpr

	return p
}

func (s *AwaitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *AwaitExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *AwaitExprContext) TRY() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRY, 0)
}

func (s *AwaitExprContext) AWAIT() antlr.TerminalNode {
	return s.GetToken(ManuscriptAWAIT, 0)
}

func (s *AwaitExprContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(ManuscriptASYNC, 0)
}

func (s *AwaitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AwaitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AwaitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterAwaitExpr(s)
	}
}

func (s *AwaitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitAwaitExpr(s)
	}
}

func (s *AwaitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitAwaitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) AwaitExpr() (localctx IAwaitExprContext) {
	localctx = NewAwaitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ManuscriptRULE_awaitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptTRY {
		{
			p.SetState(903)
			p.Match(ManuscriptTRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptAWAIT {
		{
			p.SetState(906)
			p.Match(ManuscriptAWAIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptASYNC {
		{
			p.SetState(909)
			p.Match(ManuscriptASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

	{
		p.SetState(912)
		p.postfixExpr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExprContext is an interface to support dynamic dispatch.
type IPostfixExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpr() IPrimaryExprContext
	PostfixExpr() IPostfixExprContext
	PostfixOp() IPostfixOpContext

	// IsPostfixExprContext differentiates from other interfaces.
	IsPostfixExprContext()
}

type PostfixExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExprContext() *PostfixExprContext {
	var p = new(PostfixExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
	return p
}

func InitEmptyPostfixExprContext(p *PostfixExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixExpr
}

func (*PostfixExprContext) IsPostfixExprContext() {}

func NewPostfixExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExprContext {
	var p = new(PostfixExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixExpr

	return p
}

func (s *PostfixExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExprContext) PrimaryExpr() IPrimaryExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExprContext)
}

func (s *PostfixExprContext) PostfixExpr() IPostfixExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExprContext)
}

func (s *PostfixExprContext) PostfixOp() IPostfixOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOpContext)
}

func (s *PostfixExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixExpr(s)
	}
}

func (s *PostfixExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixExpr(s)
	}
}

func (s *PostfixExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixExpr() (localctx IPostfixExprContext) {
	return p.postfixExpr(0)
}

func (p *Manuscript) postfixExpr(_p int) (localctx IPostfixExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 146
	p.EnterRecursionRule(localctx, 146, ManuscriptRULE_postfixExpr, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(915)
		p.PrimaryExpr()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewPostfixExprContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, ManuscriptRULE_postfixExpr)
			p.SetState(917)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(918)
				p.PostfixOp()
			}

		}
		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOpContext is an interface to support dynamic dispatch.
type IPostfixOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPostfixOpContext differentiates from other interfaces.
	IsPostfixOpContext()
}

type PostfixOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOpContext() *PostfixOpContext {
	var p = new(PostfixOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
	return p
}

func InitEmptyPostfixOpContext(p *PostfixOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_postfixOp
}

func (*PostfixOpContext) IsPostfixOpContext() {}

func NewPostfixOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOpContext {
	var p = new(PostfixOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_postfixOp

	return p
}

func (s *PostfixOpContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOpContext) CopyAll(ctx *PostfixOpContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PostfixOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PostfixDotContext struct {
	PostfixOpContext
}

func NewPostfixDotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixDotContext {
	var p = new(PostfixDotContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *PostfixDotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixDotContext) DOT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOT, 0)
}

func (s *PostfixDotContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PostfixDotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixDot(s)
	}
}

func (s *PostfixDotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixDot(s)
	}
}

func (s *PostfixDotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixDot(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostfixCallContext struct {
	PostfixOpContext
}

func NewPostfixCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixCallContext {
	var p = new(PostfixCallContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *PostfixCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *PostfixCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *PostfixCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PostfixCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixCall(s)
	}
}

func (s *PostfixCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixCall(s)
	}
}

func (s *PostfixCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixCall(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostfixIndexContext struct {
	PostfixOpContext
}

func NewPostfixIndexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostfixIndexContext {
	var p = new(PostfixIndexContext)

	InitEmptyPostfixOpContext(&p.PostfixOpContext)
	p.parser = parser
	p.CopyAll(ctx.(*PostfixOpContext))

	return p
}

func (s *PostfixIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixIndexContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *PostfixIndexContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PostfixIndexContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *PostfixIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPostfixIndex(s)
	}
}

func (s *PostfixIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPostfixIndex(s)
	}
}

func (s *PostfixIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPostfixIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PostfixOp() (localctx IPostfixOpContext) {
	localctx = NewPostfixOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ManuscriptRULE_postfixOp)
	var _la int

	p.SetState(935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptLPAREN:
		localctx = NewPostfixCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(924)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(925)
				p.ExprList()
			}

		}
		{
			p.SetState(928)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOT:
		localctx = NewPostfixDotContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(929)
			p.Match(ManuscriptDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(930)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptLSQBR:
		localctx = NewPostfixIndexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(931)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(932)
			p.Expr()
		}
		{
			p.SetState(933)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExprContext is an interface to support dynamic dispatch.
type IPrimaryExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExprContext differentiates from other interfaces.
	IsPrimaryExprContext()
}

type PrimaryExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExprContext() *PrimaryExprContext {
	var p = new(PrimaryExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
	return p
}

func InitEmptyPrimaryExprContext(p *PrimaryExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_primaryExpr
}

func (*PrimaryExprContext) IsPrimaryExprContext() {}

func NewPrimaryExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExprContext {
	var p = new(PrimaryExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_primaryExpr

	return p
}

func (s *PrimaryExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExprContext) CopyAll(ctx *PrimaryExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PrimaryVoidContext struct {
	PrimaryExprContext
}

func NewPrimaryVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryVoidContext {
	var p = new(PrimaryVoidContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *PrimaryVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryVoid(s)
	}
}

func (s *PrimaryVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryVoid(s)
	}
}

func (s *PrimaryVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryFnContext struct {
	PrimaryExprContext
}

func NewPrimaryFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryFnContext {
	var p = new(PrimaryFnContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryFnContext) FnExpr() IFnExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnExprContext)
}

func (s *PrimaryFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryFn(s)
	}
}

func (s *PrimaryFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryFn(s)
	}
}

func (s *PrimaryFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryObjectContext struct {
	PrimaryExprContext
}

func NewPrimaryObjectContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryObjectContext {
	var p = new(PrimaryObjectContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryObjectContext) ObjectLiteral() IObjectLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectLiteralContext)
}

func (s *PrimaryObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryObject(s)
	}
}

func (s *PrimaryObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryObject(s)
	}
}

func (s *PrimaryObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryObject(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryParenContext struct {
	PrimaryExprContext
}

func NewPrimaryParenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryParenContext {
	var p = new(PrimaryParenContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryParenContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *PrimaryParenContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PrimaryParenContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *PrimaryParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryParen(s)
	}
}

func (s *PrimaryParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryParen(s)
	}
}

func (s *PrimaryParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryParen(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryArrayContext struct {
	PrimaryExprContext
}

func NewPrimaryArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryArrayContext {
	var p = new(PrimaryArrayContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryArrayContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *PrimaryArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryArray(s)
	}
}

func (s *PrimaryArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryArray(s)
	}
}

func (s *PrimaryArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryMapContext struct {
	PrimaryExprContext
}

func NewPrimaryMapContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryMapContext {
	var p = new(PrimaryMapContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryMapContext) MapLiteral() IMapLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapLiteralContext)
}

func (s *PrimaryMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryMap(s)
	}
}

func (s *PrimaryMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryMap(s)
	}
}

func (s *PrimaryMapContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryMap(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryStructInitContext struct {
	PrimaryExprContext
}

func NewPrimaryStructInitContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryStructInitContext {
	var p = new(PrimaryStructInitContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryStructInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryStructInitContext) StructInitExpr() IStructInitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructInitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructInitExprContext)
}

func (s *PrimaryStructInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryStructInit(s)
	}
}

func (s *PrimaryStructInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryStructInit(s)
	}
}

func (s *PrimaryStructInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryStructInit(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryLiteralContext struct {
	PrimaryExprContext
}

func NewPrimaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryLiteralContext {
	var p = new(PrimaryLiteralContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryLiteral(s)
	}
}

func (s *PrimaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryLiteral(s)
	}
}

func (s *PrimaryLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimarySetContext struct {
	PrimaryExprContext
}

func NewPrimarySetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimarySetContext {
	var p = new(PrimarySetContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimarySetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimarySetContext) SetLiteral() ISetLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetLiteralContext)
}

func (s *PrimarySetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimarySet(s)
	}
}

func (s *PrimarySetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimarySet(s)
	}
}

func (s *PrimarySetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimarySet(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryMatchContext struct {
	PrimaryExprContext
}

func NewPrimaryMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryMatchContext {
	var p = new(PrimaryMatchContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryMatchContext) MatchExpr() IMatchExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatchExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatchExprContext)
}

func (s *PrimaryMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryMatch(s)
	}
}

func (s *PrimaryMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryMatch(s)
	}
}

func (s *PrimaryMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryNullContext struct {
	PrimaryExprContext
}

func NewPrimaryNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryNullContext {
	var p = new(PrimaryNullContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *PrimaryNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryNull(s)
	}
}

func (s *PrimaryNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryNull(s)
	}
}

func (s *PrimaryNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryTaggedBlockContext struct {
	PrimaryExprContext
}

func NewPrimaryTaggedBlockContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryTaggedBlockContext {
	var p = new(PrimaryTaggedBlockContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryTaggedBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryTaggedBlockContext) TaggedBlockString() ITaggedBlockStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaggedBlockStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaggedBlockStringContext)
}

func (s *PrimaryTaggedBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryTaggedBlock(s)
	}
}

func (s *PrimaryTaggedBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryTaggedBlock(s)
	}
}

func (s *PrimaryTaggedBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryTaggedBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryIDContext struct {
	PrimaryExprContext
}

func NewPrimaryIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryIDContext {
	var p = new(PrimaryIDContext)

	InitEmptyPrimaryExprContext(&p.PrimaryExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExprContext))

	return p
}

func (s *PrimaryIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *PrimaryIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterPrimaryID(s)
	}
}

func (s *PrimaryIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitPrimaryID(s)
	}
}

func (s *PrimaryIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitPrimaryID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) PrimaryExpr() (localctx IPrimaryExprContext) {
	localctx = NewPrimaryExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ManuscriptRULE_primaryExpr)
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(937)
			p.Literal()
		}

	case 2:
		localctx = NewPrimaryIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(938)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPrimaryParenContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(939)
			p.Match(ManuscriptLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(940)
			p.Expr()
		}
		{
			p.SetState(941)
			p.Match(ManuscriptRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewPrimaryArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(943)
			p.ArrayLiteral()
		}

	case 5:
		localctx = NewPrimaryObjectContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(944)
			p.ObjectLiteral()
		}

	case 6:
		localctx = NewPrimaryMapContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(945)
			p.MapLiteral()
		}

	case 7:
		localctx = NewPrimarySetContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(946)
			p.SetLiteral()
		}

	case 8:
		localctx = NewPrimaryFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(947)
			p.FnExpr()
		}

	case 9:
		localctx = NewPrimaryMatchContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(948)
			p.MatchExpr()
		}

	case 10:
		localctx = NewPrimaryVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(949)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewPrimaryNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(950)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewPrimaryTaggedBlockContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(951)
			p.TaggedBlockString()
		}

	case 13:
		localctx = NewPrimaryStructInitContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(952)
			p.StructInitExpr()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnExprContext is an interface to support dynamic dispatch.
type IFnExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnExprContext differentiates from other interfaces.
	IsFnExprContext()
}

type FnExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnExprContext() *FnExprContext {
	var p = new(FnExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
	return p
}

func InitEmptyFnExprContext(p *FnExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnExpr
}

func (*FnExprContext) IsFnExprContext() {}

func NewFnExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnExprContext {
	var p = new(FnExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnExpr

	return p
}

func (s *FnExprContext) GetParser() antlr.Parser { return s.parser }

func (s *FnExprContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnExprContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FnExprContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnExprContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnExpr(s)
	}
}

func (s *FnExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnExpr(s)
	}
}

func (s *FnExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnExpr() (localctx IFnExprContext) {
	localctx = NewFnExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ManuscriptRULE_fnExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(956)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(958)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(957)
			p.Parameters()
		}

	}
	{
		p.SetState(960)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(961)
			p.TypeAnnotation()
		}

	}
	{
		p.SetState(964)
		p.CodeBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatchExprContext is an interface to support dynamic dispatch.
type IMatchExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATCH() antlr.TerminalNode
	Expr() IExprContext
	LBRACE() antlr.TerminalNode
	AllCaseClause() []ICaseClauseContext
	CaseClause(i int) ICaseClauseContext
	RBRACE() antlr.TerminalNode
	AllStmt_sep() []IStmt_sepContext
	Stmt_sep(i int) IStmt_sepContext
	DefaultClause() IDefaultClauseContext

	// IsMatchExprContext differentiates from other interfaces.
	IsMatchExprContext()
}

type MatchExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMatchExprContext() *MatchExprContext {
	var p = new(MatchExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
	return p
}

func InitEmptyMatchExprContext(p *MatchExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_matchExpr
}

func (*MatchExprContext) IsMatchExprContext() {}

func NewMatchExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatchExprContext {
	var p = new(MatchExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_matchExpr

	return p
}

func (s *MatchExprContext) GetParser() antlr.Parser { return s.parser }

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(ManuscriptMATCH, 0)
}

func (s *MatchExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MatchExprContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *MatchExprContext) AllCaseClause() []ICaseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseClauseContext); ok {
			len++
		}
	}

	tst := make([]ICaseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseClauseContext); ok {
			tst[i] = t.(ICaseClauseContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) CaseClause(i int) ICaseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseClauseContext)
}

func (s *MatchExprContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *MatchExprContext) AllStmt_sep() []IStmt_sepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStmt_sepContext); ok {
			len++
		}
	}

	tst := make([]IStmt_sepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStmt_sepContext); ok {
			tst[i] = t.(IStmt_sepContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) Stmt_sep(i int) IStmt_sepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStmt_sepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStmt_sepContext)
}

func (s *MatchExprContext) DefaultClause() IDefaultClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultClauseContext)
}

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

func (s *MatchExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMatchExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MatchExpr() (localctx IMatchExprContext) {
	localctx = NewMatchExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ManuscriptRULE_matchExpr)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(966)
		p.Match(ManuscriptMATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(967)
		p.Expr()
	}
	{
		p.SetState(968)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(969)
			p.Stmt_sep()
		}

		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(975)
		p.CaseClause()
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(977)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
				{
					p.SetState(976)
					p.Stmt_sep()
				}

				p.SetState(979)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(981)
				p.CaseClause()
			}

		}
		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON {
		{
			p.SetState(988)
			p.Stmt_sep()
		}

		p.SetState(993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptDEFAULT {
		{
			p.SetState(994)
			p.DefaultClause()
		}

	}
	{
		p.SetState(997)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseClauseContext is an interface to support dynamic dispatch.
type ICaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsCaseClauseContext differentiates from other interfaces.
	IsCaseClauseContext()
}

type CaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseClauseContext() *CaseClauseContext {
	var p = new(CaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
	return p
}

func InitEmptyCaseClauseContext(p *CaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_caseClause
}

func (*CaseClauseContext) IsCaseClauseContext() {}

func NewCaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseClauseContext {
	var p = new(CaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_caseClause

	return p
}

func (s *CaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseClauseContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *CaseClauseContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *CaseClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *CaseClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *CaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterCaseClause(s)
	}
}

func (s *CaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitCaseClause(s)
	}
}

func (s *CaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitCaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) CaseClause() (localctx ICaseClauseContext) {
	localctx = NewCaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ManuscriptRULE_caseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(999)
		p.Expr()
	}
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1000)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1001)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1002)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1006)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1005)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultClauseContext is an interface to support dynamic dispatch.
type IDefaultClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext
	CodeBlock() ICodeBlockContext
	SEMICOLON() antlr.TerminalNode

	// IsDefaultClauseContext differentiates from other interfaces.
	IsDefaultClauseContext()
}

type DefaultClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultClauseContext() *DefaultClauseContext {
	var p = new(DefaultClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
	return p
}

func InitEmptyDefaultClauseContext(p *DefaultClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_defaultClause
}

func (*DefaultClauseContext) IsDefaultClauseContext() {}

func NewDefaultClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultClauseContext {
	var p = new(DefaultClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_defaultClause

	return p
}

func (s *DefaultClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDEFAULT, 0)
}

func (s *DefaultClauseContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *DefaultClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DefaultClauseContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *DefaultClauseContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *DefaultClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDefaultClause(s)
	}
}

func (s *DefaultClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDefaultClause(s)
	}
}

func (s *DefaultClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDefaultClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DefaultClause() (localctx IDefaultClauseContext) {
	localctx = NewDefaultClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ManuscriptRULE_defaultClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(ManuscriptDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptCOLON:
		{
			p.SetState(1009)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1010)
			p.Expr()
		}

	case ManuscriptLBRACE:
		{
			p.SetState(1011)
			p.CodeBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptSEMICOLON {
		{
			p.SetState(1014)
			p.Match(ManuscriptSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleQuotedStringContext is an interface to support dynamic dispatch.
type ISingleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTE_START() antlr.TerminalNode
	SINGLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsSingleQuotedStringContext differentiates from other interfaces.
	IsSingleQuotedStringContext()
}

type SingleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleQuotedStringContext() *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
	return p
}

func InitEmptySingleQuotedStringContext(p *SingleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_singleQuotedString
}

func (*SingleQuotedStringContext) IsSingleQuotedStringContext() {}

func NewSingleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleQuotedStringContext {
	var p = new(SingleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_singleQuotedString

	return p
}

func (s *SingleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleQuotedStringContext) SINGLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_QUOTE_START, 0)
}

func (s *SingleQuotedStringContext) SINGLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_END, 0)
}

func (s *SingleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *SingleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *SingleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSingleQuotedString(s)
	}
}

func (s *SingleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSingleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SingleQuotedString() (localctx ISingleQuotedStringContext) {
	localctx = NewSingleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ManuscriptRULE_singleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(ManuscriptSINGLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1018)
			p.StringPart()
		}

		p.SetState(1023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1024)
		p.Match(ManuscriptSINGLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiQuotedStringContext is an interface to support dynamic dispatch.
type IMultiQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_QUOTE_START() antlr.TerminalNode
	MULTI_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiQuotedStringContext differentiates from other interfaces.
	IsMultiQuotedStringContext()
}

type MultiQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiQuotedStringContext() *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
	return p
}

func InitEmptyMultiQuotedStringContext(p *MultiQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiQuotedString
}

func (*MultiQuotedStringContext) IsMultiQuotedStringContext() {}

func NewMultiQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiQuotedStringContext {
	var p = new(MultiQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiQuotedString

	return p
}

func (s *MultiQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiQuotedStringContext) MULTI_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_QUOTE_START, 0)
}

func (s *MultiQuotedStringContext) MULTI_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_END, 0)
}

func (s *MultiQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiQuotedString(s)
	}
}

func (s *MultiQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiQuotedString() (localctx IMultiQuotedStringContext) {
	localctx = NewMultiQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ManuscriptRULE_multiQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(ManuscriptMULTI_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1027)
			p.StringPart()
		}

		p.SetState(1032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1033)
		p.Match(ManuscriptMULTI_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOUBLE_QUOTE_START() antlr.TerminalNode
	DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsDoubleQuotedStringContext differentiates from other interfaces.
	IsDoubleQuotedStringContext()
}

type DoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoubleQuotedStringContext() *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
	return p
}

func InitEmptyDoubleQuotedStringContext(p *DoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_doubleQuotedString
}

func (*DoubleQuotedStringContext) IsDoubleQuotedStringContext() {}

func NewDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoubleQuotedStringContext {
	var p = new(DoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_doubleQuotedString

	return p
}

func (s *DoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *DoubleQuotedStringContext) DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_QUOTE_START, 0)
}

func (s *DoubleQuotedStringContext) DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_END, 0)
}

func (s *DoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *DoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *DoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitDoubleQuotedString(s)
	}
}

func (s *DoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) DoubleQuotedString() (localctx IDoubleQuotedStringContext) {
	localctx = NewDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, ManuscriptRULE_doubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1035)
		p.Match(ManuscriptDOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1036)
			p.StringPart()
		}

		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1042)
		p.Match(ManuscriptDOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiDoubleQuotedStringContext is an interface to support dynamic dispatch.
type IMultiDoubleQuotedStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_END() antlr.TerminalNode
	AllStringPart() []IStringPartContext
	StringPart(i int) IStringPartContext

	// IsMultiDoubleQuotedStringContext differentiates from other interfaces.
	IsMultiDoubleQuotedStringContext()
}

type MultiDoubleQuotedStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiDoubleQuotedStringContext() *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
	return p
}

func InitEmptyMultiDoubleQuotedStringContext(p *MultiDoubleQuotedStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString
}

func (*MultiDoubleQuotedStringContext) IsMultiDoubleQuotedStringContext() {}

func NewMultiDoubleQuotedStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiDoubleQuotedStringContext {
	var p = new(MultiDoubleQuotedStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_multiDoubleQuotedString

	return p
}

func (s *MultiDoubleQuotedStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_QUOTE_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_QUOTE_START, 0)
}

func (s *MultiDoubleQuotedStringContext) MULTI_DOUBLE_STR_END() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_END, 0)
}

func (s *MultiDoubleQuotedStringContext) AllStringPart() []IStringPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringPartContext); ok {
			len++
		}
	}

	tst := make([]IStringPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringPartContext); ok {
			tst[i] = t.(IStringPartContext)
			i++
		}
	}

	return tst
}

func (s *MultiDoubleQuotedStringContext) StringPart(i int) IStringPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringPartContext)
}

func (s *MultiDoubleQuotedStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiDoubleQuotedStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiDoubleQuotedStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMultiDoubleQuotedString(s)
	}
}

func (s *MultiDoubleQuotedStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMultiDoubleQuotedString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MultiDoubleQuotedString() (localctx IMultiDoubleQuotedStringContext) {
	localctx = NewMultiDoubleQuotedStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, ManuscriptRULE_multiDoubleQuotedString)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1044)
		p.Match(ManuscriptMULTI_DOUBLE_QUOTE_START)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&1755) != 0 {
		{
			p.SetState(1045)
			p.StringPart()
		}

		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1051)
		p.Match(ManuscriptMULTI_DOUBLE_STR_END)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringPartContext is an interface to support dynamic dispatch.
type IStringPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringPartContext differentiates from other interfaces.
	IsStringPartContext()
}

type StringPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringPartContext() *StringPartContext {
	var p = new(StringPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
	return p
}

func InitEmptyStringPartContext(p *StringPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringPart
}

func (*StringPartContext) IsStringPartContext() {}

func NewStringPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringPartContext {
	var p = new(StringPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringPart

	return p
}

func (s *StringPartContext) GetParser() antlr.Parser { return s.parser }

func (s *StringPartContext) CopyAll(ctx *StringPartContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringPartSingleContext struct {
	StringPartContext
}

func NewStringPartSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringPartSingleContext {
	var p = new(StringPartSingleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *StringPartSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartSingleContext) SINGLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_CONTENT, 0)
}

func (s *StringPartSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPartSingle(s)
	}
}

func (s *StringPartSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPartSingle(s)
	}
}

func (s *StringPartSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPartSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringPartMultiDoubleContext struct {
	StringPartContext
}

func NewStringPartMultiDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringPartMultiDoubleContext {
	var p = new(StringPartMultiDoubleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *StringPartMultiDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartMultiDoubleContext) MULTI_DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_CONTENT, 0)
}

func (s *StringPartMultiDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPartMultiDouble(s)
	}
}

func (s *StringPartMultiDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPartMultiDouble(s)
	}
}

func (s *StringPartMultiDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPartMultiDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringPartInterpContext struct {
	StringPartContext
}

func NewStringPartInterpContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringPartInterpContext {
	var p = new(StringPartInterpContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *StringPartInterpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartInterpContext) Interpolation() IInterpolationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterpolationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterpolationContext)
}

func (s *StringPartInterpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPartInterp(s)
	}
}

func (s *StringPartInterpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPartInterp(s)
	}
}

func (s *StringPartInterpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPartInterp(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringPartDoubleContext struct {
	StringPartContext
}

func NewStringPartDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringPartDoubleContext {
	var p = new(StringPartDoubleContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *StringPartDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartDoubleContext) DOUBLE_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_CONTENT, 0)
}

func (s *StringPartDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPartDouble(s)
	}
}

func (s *StringPartDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPartDouble(s)
	}
}

func (s *StringPartDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPartDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringPartMultiContext struct {
	StringPartContext
}

func NewStringPartMultiContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringPartMultiContext {
	var p = new(StringPartMultiContext)

	InitEmptyStringPartContext(&p.StringPartContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringPartContext))

	return p
}

func (s *StringPartMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringPartMultiContext) MULTI_STR_CONTENT() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_CONTENT, 0)
}

func (s *StringPartMultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringPartMulti(s)
	}
}

func (s *StringPartMultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringPartMulti(s)
	}
}

func (s *StringPartMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringPartMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringPart() (localctx IStringPartContext) {
	localctx = NewStringPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, ManuscriptRULE_stringPart)
	p.SetState(1058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_STR_CONTENT:
		localctx = NewStringPartSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1053)
			p.Match(ManuscriptSINGLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_STR_CONTENT:
		localctx = NewStringPartMultiContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1054)
			p.Match(ManuscriptMULTI_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptDOUBLE_STR_CONTENT:
		localctx = NewStringPartDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1055)
			p.Match(ManuscriptDOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptMULTI_DOUBLE_STR_CONTENT:
		localctx = NewStringPartMultiDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1056)
			p.Match(ManuscriptMULTI_DOUBLE_STR_CONTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_STR_INTERP_START, ManuscriptMULTI_STR_INTERP_START, ManuscriptDOUBLE_STR_INTERP_START, ManuscriptMULTI_DOUBLE_STR_INTERP_START:
		localctx = NewStringPartInterpContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1057)
			p.Interpolation()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterpolationContext is an interface to support dynamic dispatch.
type IInterpolationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	INTERP_RBRACE() antlr.TerminalNode
	SINGLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_STR_INTERP_START() antlr.TerminalNode
	DOUBLE_STR_INTERP_START() antlr.TerminalNode
	MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode

	// IsInterpolationContext differentiates from other interfaces.
	IsInterpolationContext()
}

type InterpolationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterpolationContext() *InterpolationContext {
	var p = new(InterpolationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
	return p
}

func InitEmptyInterpolationContext(p *InterpolationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_interpolation
}

func (*InterpolationContext) IsInterpolationContext() {}

func NewInterpolationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterpolationContext {
	var p = new(InterpolationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_interpolation

	return p
}

func (s *InterpolationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterpolationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InterpolationContext) INTERP_RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTERP_RBRACE, 0)
}

func (s *InterpolationContext) SINGLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptSINGLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_STR_INTERP_START, 0)
}

func (s *InterpolationContext) DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptDOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) MULTI_DOUBLE_STR_INTERP_START() antlr.TerminalNode {
	return s.GetToken(ManuscriptMULTI_DOUBLE_STR_INTERP_START, 0)
}

func (s *InterpolationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterpolationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterpolationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterInterpolation(s)
	}
}

func (s *InterpolationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitInterpolation(s)
	}
}

func (s *InterpolationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitInterpolation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Interpolation() (localctx IInterpolationContext) {
	localctx = NewInterpolationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, ManuscriptRULE_interpolation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1060)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-89)) & ^0x3f) == 0 && ((int64(1)<<(_la-89))&585) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1061)
		p.Expr()
	}
	{
		p.SetState(1062)
		p.Match(ManuscriptINTERP_RBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LiteralBoolContext struct {
	LiteralContext
}

func NewLiteralBoolContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralBoolContext {
	var p = new(LiteralBoolContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LiteralBoolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralBoolContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralBoolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteralBool(s)
	}
}

func (s *LiteralBoolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteralBool(s)
	}
}

func (s *LiteralBoolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteralBool(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralStringContext struct {
	LiteralContext
}

func NewLiteralStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralStringContext {
	var p = new(LiteralStringContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LiteralStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralStringContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *LiteralStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteralString(s)
	}
}

func (s *LiteralStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteralString(s)
	}
}

func (s *LiteralStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteralString(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralNullContext struct {
	LiteralContext
}

func NewLiteralNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralNullContext {
	var p = new(LiteralNullContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LiteralNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(ManuscriptNULL, 0)
}

func (s *LiteralNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteralNull(s)
	}
}

func (s *LiteralNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteralNull(s)
	}
}

func (s *LiteralNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteralNull(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralVoidContext struct {
	LiteralContext
}

func NewLiteralVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralVoidContext {
	var p = new(LiteralVoidContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LiteralVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *LiteralVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteralVoid(s)
	}
}

func (s *LiteralVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteralVoid(s)
	}
}

func (s *LiteralVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteralVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralNumberContext struct {
	LiteralContext
}

func NewLiteralNumberContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralNumberContext {
	var p = new(LiteralNumberContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LiteralNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralNumberContext) NumberLiteral() INumberLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberLiteralContext)
}

func (s *LiteralNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterLiteralNumber(s)
	}
}

func (s *LiteralNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitLiteralNumber(s)
	}
}

func (s *LiteralNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitLiteralNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, ManuscriptRULE_literal)
	p.SetState(1069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewLiteralStringContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1064)
			p.StringLiteral()
		}

	case ManuscriptHEX_LITERAL, ManuscriptBINARY_LITERAL, ManuscriptOCTAL_LITERAL, ManuscriptFLOAT, ManuscriptINTEGER:
		localctx = NewLiteralNumberContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1065)
			p.NumberLiteral()
		}

	case ManuscriptTRUE, ManuscriptFALSE:
		localctx = NewLiteralBoolContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1066)
			p.BooleanLiteral()
		}

	case ManuscriptNULL:
		localctx = NewLiteralNullContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1067)
			p.Match(ManuscriptNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptVOID:
		localctx = NewLiteralVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1068)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringLiteralContext is an interface to support dynamic dispatch.
type IStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsStringLiteralContext differentiates from other interfaces.
	IsStringLiteralContext()
}

type StringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringLiteralContext() *StringLiteralContext {
	var p = new(StringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
	return p
}

func InitEmptyStringLiteralContext(p *StringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stringLiteral
}

func (*StringLiteralContext) IsStringLiteralContext() {}

func NewStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringLiteralContext {
	var p = new(StringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stringLiteral

	return p
}

func (s *StringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *StringLiteralContext) CopyAll(ctx *StringLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type StringLiteralMultiContext struct {
	StringLiteralContext
}

func NewStringLiteralMultiContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralMultiContext {
	var p = new(StringLiteralMultiContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteralMultiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralMultiContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *StringLiteralMultiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteralMulti(s)
	}
}

func (s *StringLiteralMultiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteralMulti(s)
	}
}

func (s *StringLiteralMultiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteralMulti(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralDoubleContext struct {
	StringLiteralContext
}

func NewStringLiteralDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralDoubleContext {
	var p = new(StringLiteralDoubleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteralDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralDoubleContext) DoubleQuotedString() IDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoubleQuotedStringContext)
}

func (s *StringLiteralDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteralDouble(s)
	}
}

func (s *StringLiteralDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteralDouble(s)
	}
}

func (s *StringLiteralDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteralDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralMultiDoubleContext struct {
	StringLiteralContext
}

func NewStringLiteralMultiDoubleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralMultiDoubleContext {
	var p = new(StringLiteralMultiDoubleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteralMultiDoubleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralMultiDoubleContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *StringLiteralMultiDoubleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteralMultiDouble(s)
	}
}

func (s *StringLiteralMultiDoubleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteralMultiDouble(s)
	}
}

func (s *StringLiteralMultiDoubleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteralMultiDouble(s)

	default:
		return t.VisitChildren(s)
	}
}

type StringLiteralSingleContext struct {
	StringLiteralContext
}

func NewStringLiteralSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralSingleContext {
	var p = new(StringLiteralSingleContext)

	InitEmptyStringLiteralContext(&p.StringLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*StringLiteralContext))

	return p
}

func (s *StringLiteralSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralSingleContext) SingleQuotedString() ISingleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleQuotedStringContext)
}

func (s *StringLiteralSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStringLiteralSingle(s)
	}
}

func (s *StringLiteralSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStringLiteralSingle(s)
	}
}

func (s *StringLiteralSingleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStringLiteralSingle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StringLiteral() (localctx IStringLiteralContext) {
	localctx = NewStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, ManuscriptRULE_stringLiteral)
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptSINGLE_QUOTE_START:
		localctx = NewStringLiteralSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1071)
			p.SingleQuotedString()
		}

	case ManuscriptMULTI_QUOTE_START:
		localctx = NewStringLiteralMultiContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1072)
			p.MultiQuotedString()
		}

	case ManuscriptDOUBLE_QUOTE_START:
		localctx = NewStringLiteralDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1073)
			p.DoubleQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewStringLiteralMultiDoubleContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1074)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberLiteralContext is an interface to support dynamic dispatch.
type INumberLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberLiteralContext differentiates from other interfaces.
	IsNumberLiteralContext()
}

type NumberLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberLiteralContext() *NumberLiteralContext {
	var p = new(NumberLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
	return p
}

func InitEmptyNumberLiteralContext(p *NumberLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_numberLiteral
}

func (*NumberLiteralContext) IsNumberLiteralContext() {}

func NewNumberLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_numberLiteral

	return p
}

func (s *NumberLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberLiteralContext) CopyAll(ctx *NumberLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NumberLiteralFloatContext struct {
	NumberLiteralContext
}

func NewNumberLiteralFloatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralFloatContext {
	var p = new(NumberLiteralFloatContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *NumberLiteralFloatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralFloatContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ManuscriptFLOAT, 0)
}

func (s *NumberLiteralFloatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteralFloat(s)
	}
}

func (s *NumberLiteralFloatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteralFloat(s)
	}
}

func (s *NumberLiteralFloatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteralFloat(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumberLiteralIntContext struct {
	NumberLiteralContext
}

func NewNumberLiteralIntContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralIntContext {
	var p = new(NumberLiteralIntContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *NumberLiteralIntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralIntContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(ManuscriptINTEGER, 0)
}

func (s *NumberLiteralIntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteralInt(s)
	}
}

func (s *NumberLiteralIntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteralInt(s)
	}
}

func (s *NumberLiteralIntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteralInt(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumberLiteralOctContext struct {
	NumberLiteralContext
}

func NewNumberLiteralOctContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralOctContext {
	var p = new(NumberLiteralOctContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *NumberLiteralOctContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralOctContext) OCTAL_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptOCTAL_LITERAL, 0)
}

func (s *NumberLiteralOctContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteralOct(s)
	}
}

func (s *NumberLiteralOctContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteralOct(s)
	}
}

func (s *NumberLiteralOctContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteralOct(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumberLiteralHexContext struct {
	NumberLiteralContext
}

func NewNumberLiteralHexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralHexContext {
	var p = new(NumberLiteralHexContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *NumberLiteralHexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralHexContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptHEX_LITERAL, 0)
}

func (s *NumberLiteralHexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteralHex(s)
	}
}

func (s *NumberLiteralHexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteralHex(s)
	}
}

func (s *NumberLiteralHexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteralHex(s)

	default:
		return t.VisitChildren(s)
	}
}

type NumberLiteralBinContext struct {
	NumberLiteralContext
}

func NewNumberLiteralBinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralBinContext {
	var p = new(NumberLiteralBinContext)

	InitEmptyNumberLiteralContext(&p.NumberLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberLiteralContext))

	return p
}

func (s *NumberLiteralBinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralBinContext) BINARY_LITERAL() antlr.TerminalNode {
	return s.GetToken(ManuscriptBINARY_LITERAL, 0)
}

func (s *NumberLiteralBinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterNumberLiteralBin(s)
	}
}

func (s *NumberLiteralBinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitNumberLiteralBin(s)
	}
}

func (s *NumberLiteralBinContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitNumberLiteralBin(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) NumberLiteral() (localctx INumberLiteralContext) {
	localctx = NewNumberLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, ManuscriptRULE_numberLiteral)
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptINTEGER:
		localctx = NewNumberLiteralIntContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1077)
			p.Match(ManuscriptINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFLOAT:
		localctx = NewNumberLiteralFloatContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1078)
			p.Match(ManuscriptFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptHEX_LITERAL:
		localctx = NewNumberLiteralHexContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1079)
			p.Match(ManuscriptHEX_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptBINARY_LITERAL:
		localctx = NewNumberLiteralBinContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1080)
			p.Match(ManuscriptBINARY_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptOCTAL_LITERAL:
		localctx = NewNumberLiteralOctContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1081)
			p.Match(ManuscriptOCTAL_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) CopyAll(ctx *BooleanLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoolLiteralTrueContext struct {
	BooleanLiteralContext
}

func NewBoolLiteralTrueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoolLiteralTrueContext {
	var p = new(BoolLiteralTrueContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *BoolLiteralTrueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralTrueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(ManuscriptTRUE, 0)
}

func (s *BoolLiteralTrueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBoolLiteralTrue(s)
	}
}

func (s *BoolLiteralTrueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBoolLiteralTrue(s)
	}
}

func (s *BoolLiteralTrueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBoolLiteralTrue(s)

	default:
		return t.VisitChildren(s)
	}
}

type BoolLiteralFalseContext struct {
	BooleanLiteralContext
}

func NewBoolLiteralFalseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoolLiteralFalseContext {
	var p = new(BoolLiteralFalseContext)

	InitEmptyBooleanLiteralContext(&p.BooleanLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanLiteralContext))

	return p
}

func (s *BoolLiteralFalseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralFalseContext) FALSE() antlr.TerminalNode {
	return s.GetToken(ManuscriptFALSE, 0)
}

func (s *BoolLiteralFalseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterBoolLiteralFalse(s)
	}
}

func (s *BoolLiteralFalseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitBoolLiteralFalse(s)
	}
}

func (s *BoolLiteralFalseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitBoolLiteralFalse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, ManuscriptRULE_booleanLiteral)
	p.SetState(1086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptTRUE:
		localctx = NewBoolLiteralTrueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1084)
			p.Match(ManuscriptTRUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptFALSE:
		localctx = NewBoolLiteralFalseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1085)
			p.Match(ManuscriptFALSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode
	ExprList() IExprListContext

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayLiteralContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayLiteralContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, ManuscriptRULE_arrayLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1090)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1089)
			p.ExprList()
		}

	}
	{
		p.SetState(1092)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectLiteralContext is an interface to support dynamic dispatch.
type IObjectLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectFieldList() IObjectFieldListContext

	// IsObjectLiteralContext differentiates from other interfaces.
	IsObjectLiteralContext()
}

type ObjectLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectLiteralContext() *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
	return p
}

func InitEmptyObjectLiteralContext(p *ObjectLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectLiteral
}

func (*ObjectLiteralContext) IsObjectLiteralContext() {}

func NewObjectLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectLiteralContext {
	var p = new(ObjectLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectLiteral

	return p
}

func (s *ObjectLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptLBRACE, 0)
}

func (s *ObjectLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(ManuscriptRBRACE, 0)
}

func (s *ObjectLiteralContext) ObjectFieldList() IObjectFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldListContext)
}

func (s *ObjectLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectLiteral(s)
	}
}

func (s *ObjectLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectLiteral() (localctx IObjectLiteralContext) {
	localctx = NewObjectLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, ManuscriptRULE_objectLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1094)
		p.Match(ManuscriptLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-84)) & ^0x3f) == 0 && ((int64(1)<<(_la-84))&31) != 0 {
		{
			p.SetState(1095)
			p.ObjectFieldList()
		}

	}
	{
		p.SetState(1098)
		p.Match(ManuscriptRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldListContext is an interface to support dynamic dispatch.
type IObjectFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectField() []IObjectFieldContext
	ObjectField(i int) IObjectFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectFieldListContext differentiates from other interfaces.
	IsObjectFieldListContext()
}

type ObjectFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldListContext() *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
	return p
}

func InitEmptyObjectFieldListContext(p *ObjectFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldList
}

func (*ObjectFieldListContext) IsObjectFieldListContext() {}

func NewObjectFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldListContext {
	var p = new(ObjectFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldList

	return p
}

func (s *ObjectFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldListContext) AllObjectField() []IObjectFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectFieldContext); ok {
			len++
		}
	}

	tst := make([]IObjectFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectFieldContext); ok {
			tst[i] = t.(IObjectFieldContext)
			i++
		}
	}

	return tst
}

func (s *ObjectFieldListContext) ObjectField(i int) IObjectFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldContext)
}

func (s *ObjectFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *ObjectFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *ObjectFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldList(s)
	}
}

func (s *ObjectFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldList() (localctx IObjectFieldListContext) {
	localctx = NewObjectFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, ManuscriptRULE_objectFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1100)
		p.ObjectField()
	}
	p.SetState(1105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1101)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1102)
				p.ObjectField()
			}

		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 130, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1108)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldContext is an interface to support dynamic dispatch.
type IObjectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ObjectFieldName() IObjectFieldNameContext
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsObjectFieldContext differentiates from other interfaces.
	IsObjectFieldContext()
}

type ObjectFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldContext() *ObjectFieldContext {
	var p = new(ObjectFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
	return p
}

func InitEmptyObjectFieldContext(p *ObjectFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectField
}

func (*ObjectFieldContext) IsObjectFieldContext() {}

func NewObjectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldContext {
	var p = new(ObjectFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectField

	return p
}

func (s *ObjectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldContext) ObjectFieldName() IObjectFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectFieldNameContext)
}

func (s *ObjectFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *ObjectFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ObjectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectField(s)
	}
}

func (s *ObjectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectField(s)
	}
}

func (s *ObjectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectField() (localctx IObjectFieldContext) {
	localctx = NewObjectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, ManuscriptRULE_objectField)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.ObjectFieldName()
	}
	p.SetState(1114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOLON {
		{
			p.SetState(1112)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1113)
			p.Expr()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectFieldNameContext is an interface to support dynamic dispatch.
type IObjectFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObjectFieldNameContext differentiates from other interfaces.
	IsObjectFieldNameContext()
}

type ObjectFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectFieldNameContext() *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
	return p
}

func InitEmptyObjectFieldNameContext(p *ObjectFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_objectFieldName
}

func (*ObjectFieldNameContext) IsObjectFieldNameContext() {}

func NewObjectFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectFieldNameContext {
	var p = new(ObjectFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_objectFieldName

	return p
}

func (s *ObjectFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectFieldNameContext) CopyAll(ctx *ObjectFieldNameContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ObjectFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ObjectFieldNameIDContext struct {
	ObjectFieldNameContext
}

func NewObjectFieldNameIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectFieldNameIDContext {
	var p = new(ObjectFieldNameIDContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *ObjectFieldNameIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ObjectFieldNameIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldNameID(s)
	}
}

func (s *ObjectFieldNameIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldNameID(s)
	}
}

func (s *ObjectFieldNameIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldNameID(s)

	default:
		return t.VisitChildren(s)
	}
}

type ObjectFieldNameStrContext struct {
	ObjectFieldNameContext
}

func NewObjectFieldNameStrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ObjectFieldNameStrContext {
	var p = new(ObjectFieldNameStrContext)

	InitEmptyObjectFieldNameContext(&p.ObjectFieldNameContext)
	p.parser = parser
	p.CopyAll(ctx.(*ObjectFieldNameContext))

	return p
}

func (s *ObjectFieldNameStrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectFieldNameStrContext) StringLiteral() IStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringLiteralContext)
}

func (s *ObjectFieldNameStrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterObjectFieldNameStr(s)
	}
}

func (s *ObjectFieldNameStrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitObjectFieldNameStr(s)
	}
}

func (s *ObjectFieldNameStrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitObjectFieldNameStr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ObjectFieldName() (localctx IObjectFieldNameContext) {
	localctx = NewObjectFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, ManuscriptRULE_objectFieldName)
	p.SetState(1118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptID:
		localctx = NewObjectFieldNameIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1116)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ManuscriptSINGLE_QUOTE_START, ManuscriptMULTI_QUOTE_START, ManuscriptDOUBLE_QUOTE_START, ManuscriptMULTI_DOUBLE_QUOTE_START:
		localctx = NewObjectFieldNameStrContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1117)
			p.StringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapLiteralContext is an interface to support dynamic dispatch.
type IMapLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsMapLiteralContext differentiates from other interfaces.
	IsMapLiteralContext()
}

type MapLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapLiteralContext() *MapLiteralContext {
	var p = new(MapLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
	return p
}

func InitEmptyMapLiteralContext(p *MapLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapLiteral
}

func (*MapLiteralContext) IsMapLiteralContext() {}

func NewMapLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapLiteralContext {
	var p = new(MapLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapLiteral

	return p
}

func (s *MapLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *MapLiteralContext) CopyAll(ctx *MapLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *MapLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MapLiteralEmptyContext struct {
	MapLiteralContext
}

func NewMapLiteralEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralEmptyContext {
	var p = new(MapLiteralEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *MapLiteralEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *MapLiteralEmptyContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapLiteralEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *MapLiteralEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapLiteralEmpty(s)
	}
}

func (s *MapLiteralEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapLiteralEmpty(s)
	}
}

func (s *MapLiteralEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapLiteralEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

type MapLiteralNonEmptyContext struct {
	MapLiteralContext
}

func NewMapLiteralNonEmptyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapLiteralNonEmptyContext {
	var p = new(MapLiteralNonEmptyContext)

	InitEmptyMapLiteralContext(&p.MapLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*MapLiteralContext))

	return p
}

func (s *MapLiteralNonEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapLiteralNonEmptyContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *MapLiteralNonEmptyContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *MapLiteralNonEmptyContext) MapFieldList() IMapFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldListContext)
}

func (s *MapLiteralNonEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapLiteralNonEmpty(s)
	}
}

func (s *MapLiteralNonEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapLiteralNonEmpty(s)
	}
}

func (s *MapLiteralNonEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapLiteralNonEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapLiteral() (localctx IMapLiteralContext) {
	localctx = NewMapLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, ManuscriptRULE_mapLiteral)
	var _la int

	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		localctx = NewMapLiteralEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1120)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1121)
			p.Match(ManuscriptCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1122)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewMapLiteralNonEmptyContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1123)
			p.Match(ManuscriptLSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1125)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
			{
				p.SetState(1124)
				p.MapFieldList()
			}

		}
		{
			p.SetState(1127)
			p.Match(ManuscriptRSQBR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldListContext is an interface to support dynamic dispatch.
type IMapFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapField() []IMapFieldContext
	MapField(i int) IMapFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMapFieldListContext differentiates from other interfaces.
	IsMapFieldListContext()
}

type MapFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldListContext() *MapFieldListContext {
	var p = new(MapFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
	return p
}

func InitEmptyMapFieldListContext(p *MapFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapFieldList
}

func (*MapFieldListContext) IsMapFieldListContext() {}

func NewMapFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldListContext {
	var p = new(MapFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapFieldList

	return p
}

func (s *MapFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldListContext) AllMapField() []IMapFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapFieldContext); ok {
			len++
		}
	}

	tst := make([]IMapFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapFieldContext); ok {
			tst[i] = t.(IMapFieldContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldListContext) MapField(i int) IMapFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapFieldContext)
}

func (s *MapFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *MapFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *MapFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapFieldList(s)
	}
}

func (s *MapFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapFieldList(s)
	}
}

func (s *MapFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapFieldList() (localctx IMapFieldListContext) {
	localctx = NewMapFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, ManuscriptRULE_mapFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.MapField()
	}
	p.SetState(1135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1131)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1132)
				p.MapField()
			}

		}
		p.SetState(1137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 136, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1139)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1138)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapFieldContext is an interface to support dynamic dispatch.
type IMapFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COLON() antlr.TerminalNode

	// IsMapFieldContext differentiates from other interfaces.
	IsMapFieldContext()
}

type MapFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapFieldContext() *MapFieldContext {
	var p = new(MapFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
	return p
}

func InitEmptyMapFieldContext(p *MapFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_mapField
}

func (*MapFieldContext) IsMapFieldContext() {}

func NewMapFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapFieldContext {
	var p = new(MapFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_mapField

	return p
}

func (s *MapFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *MapFieldContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *MapFieldContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *MapFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *MapFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterMapField(s)
	}
}

func (s *MapFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitMapField(s)
	}
}

func (s *MapFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitMapField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) MapField() (localctx IMapFieldContext) {
	localctx = NewMapFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, ManuscriptRULE_mapField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		p.Expr()
	}
	{
		p.SetState(1142)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1143)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetLiteralContext is an interface to support dynamic dispatch.
type ISetLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetLiteralContext differentiates from other interfaces.
	IsSetLiteralContext()
}

type SetLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetLiteralContext() *SetLiteralContext {
	var p = new(SetLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
	return p
}

func InitEmptySetLiteralContext(p *SetLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_setLiteral
}

func (*SetLiteralContext) IsSetLiteralContext() {}

func NewSetLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetLiteralContext {
	var p = new(SetLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_setLiteral

	return p
}

func (s *SetLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SetLiteralContext) LT() antlr.TerminalNode {
	return s.GetToken(ManuscriptLT, 0)
}

func (s *SetLiteralContext) GT() antlr.TerminalNode {
	return s.GetToken(ManuscriptGT, 0)
}

func (s *SetLiteralContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SetLiteralContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *SetLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *SetLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterSetLiteral(s)
	}
}

func (s *SetLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitSetLiteral(s)
	}
}

func (s *SetLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitSetLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) SetLiteral() (localctx ISetLiteralContext) {
	localctx = NewSetLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, ManuscriptRULE_setLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.Match(ManuscriptLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&108179864317673536) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&33521665) != 0) {
		{
			p.SetState(1146)
			p.Expr()
		}
		p.SetState(1151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1147)
					p.Match(ManuscriptCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1148)
					p.Expr()
				}

			}
			p.SetState(1153)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ManuscriptCOMMA {
			{
				p.SetState(1154)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1159)
		p.Match(ManuscriptGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaggedBlockStringContext is an interface to support dynamic dispatch.
type ITaggedBlockStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	MultiQuotedString() IMultiQuotedStringContext
	MultiDoubleQuotedString() IMultiDoubleQuotedStringContext

	// IsTaggedBlockStringContext differentiates from other interfaces.
	IsTaggedBlockStringContext()
}

type TaggedBlockStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaggedBlockStringContext() *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
	return p
}

func InitEmptyTaggedBlockStringContext(p *TaggedBlockStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_taggedBlockString
}

func (*TaggedBlockStringContext) IsTaggedBlockStringContext() {}

func NewTaggedBlockStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaggedBlockStringContext {
	var p = new(TaggedBlockStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_taggedBlockString

	return p
}

func (s *TaggedBlockStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TaggedBlockStringContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TaggedBlockStringContext) MultiQuotedString() IMultiQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiQuotedStringContext)
}

func (s *TaggedBlockStringContext) MultiDoubleQuotedString() IMultiDoubleQuotedStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiDoubleQuotedStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiDoubleQuotedStringContext)
}

func (s *TaggedBlockStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaggedBlockStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaggedBlockStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTaggedBlockString(s)
	}
}

func (s *TaggedBlockStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTaggedBlockString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TaggedBlockString() (localctx ITaggedBlockStringContext) {
	localctx = NewTaggedBlockStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, ManuscriptRULE_taggedBlockString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1161)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ManuscriptMULTI_QUOTE_START:
		{
			p.SetState(1162)
			p.MultiQuotedString()
		}

	case ManuscriptMULTI_DOUBLE_QUOTE_START:
		{
			p.SetState(1163)
			p.MultiDoubleQuotedString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructInitExprContext is an interface to support dynamic dispatch.
type IStructInitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	StructFieldList() IStructFieldListContext

	// IsStructInitExprContext differentiates from other interfaces.
	IsStructInitExprContext()
}

type StructInitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructInitExprContext() *StructInitExprContext {
	var p = new(StructInitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
	return p
}

func InitEmptyStructInitExprContext(p *StructInitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structInitExpr
}

func (*StructInitExprContext) IsStructInitExprContext() {}

func NewStructInitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructInitExprContext {
	var p = new(StructInitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structInitExpr

	return p
}

func (s *StructInitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *StructInitExprContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructInitExprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *StructInitExprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *StructInitExprContext) StructFieldList() IStructFieldListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldListContext)
}

func (s *StructInitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructInitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructInitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructInitExpr(s)
	}
}

func (s *StructInitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructInitExpr(s)
	}
}

func (s *StructInitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructInitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructInitExpr() (localctx IStructInitExprContext) {
	localctx = NewStructInitExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, ManuscriptRULE_structInitExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1166)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1167)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1168)
			p.StructFieldList()
		}

	}
	{
		p.SetState(1171)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldListContext is an interface to support dynamic dispatch.
type IStructFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStructField() []IStructFieldContext
	StructField(i int) IStructFieldContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsStructFieldListContext differentiates from other interfaces.
	IsStructFieldListContext()
}

type StructFieldListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldListContext() *StructFieldListContext {
	var p = new(StructFieldListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
	return p
}

func InitEmptyStructFieldListContext(p *StructFieldListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structFieldList
}

func (*StructFieldListContext) IsStructFieldListContext() {}

func NewStructFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldListContext {
	var p = new(StructFieldListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structFieldList

	return p
}

func (s *StructFieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldListContext) AllStructField() []IStructFieldContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStructFieldContext); ok {
			len++
		}
	}

	tst := make([]IStructFieldContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStructFieldContext); ok {
			tst[i] = t.(IStructFieldContext)
			i++
		}
	}

	return tst
}

func (s *StructFieldListContext) StructField(i int) IStructFieldContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructFieldContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructFieldContext)
}

func (s *StructFieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(ManuscriptCOMMA)
}

func (s *StructFieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(ManuscriptCOMMA, i)
}

func (s *StructFieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructFieldList(s)
	}
}

func (s *StructFieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructFieldList(s)
	}
}

func (s *StructFieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructFieldList() (localctx IStructFieldListContext) {
	localctx = NewStructFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, ManuscriptRULE_structFieldList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1173)
		p.StructField()
	}
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1174)
				p.Match(ManuscriptCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1175)
				p.StructField()
			}

		}
		p.SetState(1180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 143, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptCOMMA {
		{
			p.SetState(1181)
			p.Match(ManuscriptCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructFieldContext is an interface to support dynamic dispatch.
type IStructFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	COLON() antlr.TerminalNode
	Expr() IExprContext

	// IsStructFieldContext differentiates from other interfaces.
	IsStructFieldContext()
}

type StructFieldContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructFieldContext() *StructFieldContext {
	var p = new(StructFieldContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
	return p
}

func InitEmptyStructFieldContext(p *StructFieldContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_structField
}

func (*StructFieldContext) IsStructFieldContext() {}

func NewStructFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructFieldContext {
	var p = new(StructFieldContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_structField

	return p
}

func (s *StructFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *StructFieldContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *StructFieldContext) COLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptCOLON, 0)
}

func (s *StructFieldContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StructFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStructField(s)
	}
}

func (s *StructFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStructField(s)
	}
}

func (s *StructFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStructField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) StructField() (localctx IStructFieldContext) {
	localctx = NewStructFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, ManuscriptRULE_structField)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1184)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1185)
		p.Match(ManuscriptCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1186)
		p.Expr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeAnnotationContext is an interface to support dynamic dispatch.
type ITypeAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeAnnotationContext differentiates from other interfaces.
	IsTypeAnnotationContext()
}

type TypeAnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeAnnotationContext() *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
	return p
}

func InitEmptyTypeAnnotationContext(p *TypeAnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_typeAnnotation
}

func (*TypeAnnotationContext) IsTypeAnnotationContext() {}

func NewTypeAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeAnnotationContext {
	var p = new(TypeAnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_typeAnnotation

	return p
}

func (s *TypeAnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeAnnotationContext) CopyAll(ctx *TypeAnnotationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TypeAnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TypeAnnFnContext struct {
	TypeAnnotationContext
}

func NewTypeAnnFnContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeAnnFnContext {
	var p = new(TypeAnnFnContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *TypeAnnFnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnFnContext) FnType() IFnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFnTypeContext)
}

func (s *TypeAnnFnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnFn(s)
	}
}

func (s *TypeAnnFnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnFn(s)
	}
}

func (s *TypeAnnFnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnFn(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeAnnVoidContext struct {
	TypeAnnotationContext
}

func NewTypeAnnVoidContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeAnnVoidContext {
	var p = new(TypeAnnVoidContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *TypeAnnVoidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnVoidContext) VOID() antlr.TerminalNode {
	return s.GetToken(ManuscriptVOID, 0)
}

func (s *TypeAnnVoidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnVoid(s)
	}
}

func (s *TypeAnnVoidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnVoid(s)
	}
}

func (s *TypeAnnVoidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnVoid(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeAnnTupleContext struct {
	TypeAnnotationContext
}

func NewTypeAnnTupleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeAnnTupleContext {
	var p = new(TypeAnnTupleContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *TypeAnnTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnTupleContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *TypeAnnTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnTuple(s)
	}
}

func (s *TypeAnnTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnTuple(s)
	}
}

func (s *TypeAnnTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeAnnArrayContext struct {
	TypeAnnotationContext
}

func NewTypeAnnArrayContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeAnnArrayContext {
	var p = new(TypeAnnArrayContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *TypeAnnArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnArrayContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeAnnArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnArray(s)
	}
}

func (s *TypeAnnArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnArray(s)
	}
}

func (s *TypeAnnArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnArray(s)

	default:
		return t.VisitChildren(s)
	}
}

type TypeAnnIDContext struct {
	TypeAnnotationContext
}

func NewTypeAnnIDContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeAnnIDContext {
	var p = new(TypeAnnIDContext)

	InitEmptyTypeAnnotationContext(&p.TypeAnnotationContext)
	p.parser = parser
	p.CopyAll(ctx.(*TypeAnnotationContext))

	return p
}

func (s *TypeAnnIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeAnnIDContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *TypeAnnIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTypeAnnID(s)
	}
}

func (s *TypeAnnIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTypeAnnID(s)
	}
}

func (s *TypeAnnIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTypeAnnID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TypeAnnotation() (localctx ITypeAnnotationContext) {
	localctx = NewTypeAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, ManuscriptRULE_typeAnnotation)
	p.SetState(1193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTypeAnnIDContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1188)
			p.Match(ManuscriptID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewTypeAnnArrayContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1189)
			p.ArrayType()
		}

	case 3:
		localctx = NewTypeAnnTupleContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1190)
			p.TupleType()
		}

	case 4:
		localctx = NewTypeAnnFnContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1191)
			p.FnType()
		}

	case 5:
		localctx = NewTypeAnnVoidContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1192)
			p.Match(ManuscriptVOID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	TypeList() ITypeListContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *TupleTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *TupleTypeContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, ManuscriptRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&17592186060864) != 0) || _la == ManuscriptID {
		{
			p.SetState(1196)
			p.TypeList()
		}

	}
	{
		p.SetState(1199)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID() antlr.TerminalNode
	LSQBR() antlr.TerminalNode
	RSQBR() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ID() antlr.TerminalNode {
	return s.GetToken(ManuscriptID, 0)
}

func (s *ArrayTypeContext) LSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptLSQBR, 0)
}

func (s *ArrayTypeContext) RSQBR() antlr.TerminalNode {
	return s.GetToken(ManuscriptRSQBR, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, ManuscriptRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Match(ManuscriptID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1202)
		p.Match(ManuscriptLSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1203)
		p.Match(ManuscriptRSQBR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFnTypeContext is an interface to support dynamic dispatch.
type IFnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Parameters() IParametersContext
	TypeAnnotation() ITypeAnnotationContext

	// IsFnTypeContext differentiates from other interfaces.
	IsFnTypeContext()
}

type FnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFnTypeContext() *FnTypeContext {
	var p = new(FnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
	return p
}

func InitEmptyFnTypeContext(p *FnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_fnType
}

func (*FnTypeContext) IsFnTypeContext() {}

func NewFnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FnTypeContext {
	var p = new(FnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_fnType

	return p
}

func (s *FnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *FnTypeContext) FN() antlr.TerminalNode {
	return s.GetToken(ManuscriptFN, 0)
}

func (s *FnTypeContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptLPAREN, 0)
}

func (s *FnTypeContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(ManuscriptRPAREN, 0)
}

func (s *FnTypeContext) Parameters() IParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersContext)
}

func (s *FnTypeContext) TypeAnnotation() ITypeAnnotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeAnnotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeAnnotationContext)
}

func (s *FnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterFnType(s)
	}
}

func (s *FnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitFnType(s)
	}
}

func (s *FnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitFnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) FnType() (localctx IFnTypeContext) {
	localctx = NewFnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, ManuscriptRULE_fnType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1205)
		p.Match(ManuscriptFN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1206)
		p.Match(ManuscriptLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ManuscriptID {
		{
			p.SetState(1207)
			p.Parameters()
		}

	}
	{
		p.SetState(1210)
		p.Match(ManuscriptRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1211)
			p.TypeAnnotation()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStmt_sepContext is an interface to support dynamic dispatch.
type IStmt_sepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode
	NEWLINE() antlr.TerminalNode

	// IsStmt_sepContext differentiates from other interfaces.
	IsStmt_sepContext()
}

type Stmt_sepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStmt_sepContext() *Stmt_sepContext {
	var p = new(Stmt_sepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
	return p
}

func InitEmptyStmt_sepContext(p *Stmt_sepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ManuscriptRULE_stmt_sep
}

func (*Stmt_sepContext) IsStmt_sepContext() {}

func NewStmt_sepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Stmt_sepContext {
	var p = new(Stmt_sepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ManuscriptRULE_stmt_sep

	return p
}

func (s *Stmt_sepContext) GetParser() antlr.Parser { return s.parser }

func (s *Stmt_sepContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ManuscriptSEMICOLON, 0)
}

func (s *Stmt_sepContext) NEWLINE() antlr.TerminalNode {
	return s.GetToken(ManuscriptNEWLINE, 0)
}

func (s *Stmt_sepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Stmt_sepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Stmt_sepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.EnterStmt_sep(s)
	}
}

func (s *Stmt_sepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ManuscriptListener); ok {
		listenerT.ExitStmt_sep(s)
	}
}

func (s *Stmt_sepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ManuscriptVisitor:
		return t.VisitStmt_sep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Manuscript) Stmt_sep() (localctx IStmt_sepContext) {
	localctx = NewStmt_sepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, ManuscriptRULE_stmt_sep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ManuscriptNEWLINE || _la == ManuscriptSEMICOLON) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *Manuscript) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 60:
		var t *LogicalOrExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalOrExprContext)
		}
		return p.LogicalOrExpr_Sempred(t, predIndex)

	case 61:
		var t *LogicalAndExprContext = nil
		if localctx != nil {
			t = localctx.(*LogicalAndExprContext)
		}
		return p.LogicalAndExpr_Sempred(t, predIndex)

	case 62:
		var t *BitwiseOrExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseOrExprContext)
		}
		return p.BitwiseOrExpr_Sempred(t, predIndex)

	case 63:
		var t *BitwiseXorExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseXorExprContext)
		}
		return p.BitwiseXorExpr_Sempred(t, predIndex)

	case 64:
		var t *BitwiseAndExprContext = nil
		if localctx != nil {
			t = localctx.(*BitwiseAndExprContext)
		}
		return p.BitwiseAndExpr_Sempred(t, predIndex)

	case 65:
		var t *EqualityExprContext = nil
		if localctx != nil {
			t = localctx.(*EqualityExprContext)
		}
		return p.EqualityExpr_Sempred(t, predIndex)

	case 67:
		var t *ComparisonExprContext = nil
		if localctx != nil {
			t = localctx.(*ComparisonExprContext)
		}
		return p.ComparisonExpr_Sempred(t, predIndex)

	case 68:
		var t *ShiftExprContext = nil
		if localctx != nil {
			t = localctx.(*ShiftExprContext)
		}
		return p.ShiftExpr_Sempred(t, predIndex)

	case 69:
		var t *AdditiveExprContext = nil
		if localctx != nil {
			t = localctx.(*AdditiveExprContext)
		}
		return p.AdditiveExpr_Sempred(t, predIndex)

	case 70:
		var t *MultiplicativeExprContext = nil
		if localctx != nil {
			t = localctx.(*MultiplicativeExprContext)
		}
		return p.MultiplicativeExpr_Sempred(t, predIndex)

	case 73:
		var t *PostfixExprContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExprContext)
		}
		return p.PostfixExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *Manuscript) LogicalOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) LogicalAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseOrExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseXorExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) BitwiseAndExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) EqualityExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ComparisonExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) ShiftExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) AdditiveExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) MultiplicativeExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *Manuscript) PostfixExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
