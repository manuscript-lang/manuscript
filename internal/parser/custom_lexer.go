package parser

import (
	"github.com/antlr4-go/antlr/v4"
)

// CustomManuscriptLexer wraps the ANTLR-generated ManuscriptLexer to add custom state
// needed for handling newline-to-semicolon conversion logic.
type CustomManuscriptLexer struct {
	*ManuscriptLexer // Embed the ANTLR-generated lexer

	// Fields to track depths for newline handling.
	// These are accessed and modified by actions in ManuscriptLexer.g4,
	// which will perform a type assertion to this CustomManuscriptLexer type.
	parenDepth   int
	bracketDepth int
	braceDepth   int
}

// NewCustomManuscriptLexer creates a new instance of CustomManuscriptLexer.
// It initializes the embedded ANTLR lexer and the custom depth tracking fields.
func NewCustomManuscriptLexer(input antlr.CharStream) *CustomManuscriptLexer {
	// Create the ANTLR-generated lexer instance.
	// Note: NewManuscriptLexer is the function generated by ANTLR based on ManuscriptLexer.g4.
	antlrLexer := NewManuscriptLexer(input)

	// Create our custom lexer instance, embedding the ANTLR one.
	customLexer := &CustomManuscriptLexer{
		ManuscriptLexer: antlrLexer,
		parenDepth:      0, // Initialize custom state
		bracketDepth:    0,
		braceDepth:      0,
	}

	// The 'l' variable in the .g4 actions (e.g., { cl := l.(*CustomManuscriptLexer); ... })
	// refers to the antlr.Lexer interface. For the type assertion to work, the actual
	// instance implementing this interface and on which ANTLR's core methods (like NextToken)
	// are called must be this 'customLexer'.
	// When the parser is constructed, it needs to be given this 'customLexer' instance.
	// ANTLR's runtime mechanisms will then ensure that when actions are triggered during
	// the lexing process (which happens inside methods of the embedded ManuscriptLexer),
	// the 'l' context variable correctly points to 'customLexer'.
	// No explicit assignment like `antlrLexer.self = customLexer` is typically needed here
	// as long as the parser uses the CustomManuscriptLexer instance from the start.

	return customLexer
}
